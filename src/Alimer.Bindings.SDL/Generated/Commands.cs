// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#nullable enable

using System;
using System.Runtime.InteropServices;
using System.Drawing;

namespace SDL3;

public unsafe partial class SDL3
{
	/// <summary>
	/// Try to lock a spin lock by setting it to a non-zero value.<br/>
	/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
	/// doing. Please be careful using any sort of spinlock!***<br/>
	/// <br/>
	/// @param lock a pointer to a lock variable.<br/>
	/// @returns true if the lock succeeded, false if the lock is already held.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockSpinlock<br/>
	/// @sa SDL_UnlockSpinlock
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_TryLockSpinlock")]
	public static partial SDLBool SDL_TryLockSpinlock(SDL_SpinLock* @lock);

	/// <summary>
	/// Lock a spin lock by setting it to a non-zero value.<br/>
	/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
	/// doing. Please be careful using any sort of spinlock!***<br/>
	/// <br/>
	/// @param lock a pointer to a lock variable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_TryLockSpinlock<br/>
	/// @sa SDL_UnlockSpinlock
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LockSpinlock")]
	public static partial void SDL_LockSpinlock(SDL_SpinLock* @lock);

	/// <summary>
	/// Unlock a spin lock by setting it to 0.<br/>
	/// Always returns immediately.<br/>
	/// ***Please note that spinlocks are dangerous if you don't know what you're<br/>
	/// doing. Please be careful using any sort of spinlock!***<br/>
	/// <br/>
	/// @param lock a pointer to a lock variable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockSpinlock<br/>
	/// @sa SDL_TryLockSpinlock
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnlockSpinlock")]
	public static partial void SDL_UnlockSpinlock(SDL_SpinLock* @lock);

	/// <summary>
	/// Insert a memory release barrier.<br/>
	/// Memory barriers are designed to prevent reads and writes from being<br/>
	/// reordered by the compiler and being seen out of order on multi-core CPUs.<br/>
	/// A typical pattern would be for thread A to write some data and a flag, and<br/>
	/// for thread B to read the flag and get the data. In this case you would<br/>
	/// insert a release barrier between writing the data and the flag,<br/>
	/// guaranteeing that the data write completes no later than the flag is<br/>
	/// written, and you would insert an acquire barrier between reading the flag<br/>
	/// and reading the data, to ensure that all the reads associated with the flag<br/>
	/// have completed.<br/>
	/// In this pattern you should always see a release barrier paired with an<br/>
	/// acquire barrier and you should gate the data reads/writes with a single<br/>
	/// flag variable.<br/>
	/// For more information on these semantics, take a look at the blog post:<br/>
	/// http://preshing.com/20120913/acquire-and-release-semantics<br/>
	/// @threadsafety Obviously this macro is safe to use from any thread at any<br/>
	/// time, but if you find yourself needing this, you are probably<br/>
	/// dealing with some very sensitive code; be careful!<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_MemoryBarrierReleaseFunction")]
	public static partial void SDL_MemoryBarrierReleaseFunction();

	/// <summary>
	/// Insert a memory acquire barrier.<br/>
	/// Please refer to SDL_MemoryBarrierReleaseFunction for the details!<br/>
	/// @threadsafety Obviously this function is safe to use from any thread at any<br/>
	/// time, but if you find yourself needing this, you are probably<br/>
	/// dealing with some very sensitive code; be careful!<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_MemoryBarrierReleaseFunction
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_MemoryBarrierAcquireFunction")]
	public static partial void SDL_MemoryBarrierAcquireFunction();

	/// <summary>
	/// Set an atomic variable to a new value if it is currently an old value.<br/>
	/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
	/// it!***<br/>
	/// <br/>
	/// @param a a pointer to an SDL_AtomicInt variable to be modified.<br/>
	/// @param oldval the old value.<br/>
	/// @param newval the new value.<br/>
	/// @returns true if the atomic variable was set, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAtomicInt<br/>
	/// @sa SDL_SetAtomicInt
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CompareAndSwapAtomicInt")]
	public static partial SDLBool SDL_CompareAndSwapAtomicInt(SDL_AtomicInt* a, int oldval, int newval);

	/// <summary>
	/// Set an atomic variable to a value.<br/>
	/// This function also acts as a full memory barrier.<br/>
	/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
	/// it!***<br/>
	/// <br/>
	/// @param a a pointer to an SDL_AtomicInt variable to be modified.<br/>
	/// @param v the desired value.<br/>
	/// @returns the previous value of the atomic variable.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAtomicInt
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAtomicInt")]
	public static partial int SDL_SetAtomicInt(SDL_AtomicInt* a, int v);

	/// <summary>
	/// Get the value of an atomic variable.<br/>
	/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
	/// it!***<br/>
	/// <br/>
	/// @param a a pointer to an SDL_AtomicInt variable.<br/>
	/// @returns the current value of an atomic variable.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAtomicInt
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAtomicInt")]
	public static partial int SDL_GetAtomicInt(SDL_AtomicInt* a);

	/// <summary>
	/// Add to an atomic variable.<br/>
	/// This function also acts as a full memory barrier.<br/>
	/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
	/// it!***<br/>
	/// <br/>
	/// @param a a pointer to an SDL_AtomicInt variable to be modified.<br/>
	/// @param v the desired value to add.<br/>
	/// @returns the previous value of the atomic variable.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AtomicDecRef<br/>
	/// @sa SDL_AtomicIncRef
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AddAtomicInt")]
	public static partial int SDL_AddAtomicInt(SDL_AtomicInt* a, int v);

	/// <summary>
	/// Set an atomic variable to a new value if it is currently an old value.<br/>
	/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
	/// it!***<br/>
	/// <br/>
	/// @param a a pointer to an SDL_AtomicU32 variable to be modified.<br/>
	/// @param oldval the old value.<br/>
	/// @param newval the new value.<br/>
	/// @returns true if the atomic variable was set, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAtomicU32<br/>
	/// @sa SDL_SetAtomicU32
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CompareAndSwapAtomicU32")]
	public static partial SDLBool SDL_CompareAndSwapAtomicU32(SDL_AtomicU32* a, uint oldval, uint newval);

	/// <summary>
	/// Set an atomic variable to a value.<br/>
	/// This function also acts as a full memory barrier.<br/>
	/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
	/// it!***<br/>
	/// <br/>
	/// @param a a pointer to an SDL_AtomicU32 variable to be modified.<br/>
	/// @param v the desired value.<br/>
	/// @returns the previous value of the atomic variable.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAtomicU32
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAtomicU32")]
	public static partial uint SDL_SetAtomicU32(SDL_AtomicU32* a, uint v);

	/// <summary>
	/// Get the value of an atomic variable.<br/>
	/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
	/// it!***<br/>
	/// <br/>
	/// @param a a pointer to an SDL_AtomicU32 variable.<br/>
	/// @returns the current value of an atomic variable.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAtomicU32
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAtomicU32")]
	public static partial uint SDL_GetAtomicU32(SDL_AtomicU32* a);

	/// <summary>
	/// Set a pointer to a new value if it is currently an old value.<br/>
	/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
	/// it!***<br/>
	/// <br/>
	/// @param a a pointer to a pointer.<br/>
	/// @param oldval the old pointer value.<br/>
	/// @param newval the new pointer value.<br/>
	/// @returns true if the pointer was set, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CompareAndSwapAtomicInt<br/>
	/// @sa SDL_GetAtomicPointer<br/>
	/// @sa SDL_SetAtomicPointer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CompareAndSwapAtomicPointer")]
	public static partial SDLBool SDL_CompareAndSwapAtomicPointer(nint a, nint oldval, nint newval);

	/// <summary>
	/// Set a pointer to a value atomically.<br/>
	/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
	/// it!***<br/>
	/// <br/>
	/// @param a a pointer to a pointer.<br/>
	/// @param v the desired pointer value.<br/>
	/// @returns the previous value of the pointer.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CompareAndSwapAtomicPointer<br/>
	/// @sa SDL_GetAtomicPointer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAtomicPointer")]
	public static partial nint SDL_SetAtomicPointer(nint a, nint v);

	/// <summary>
	/// Get the value of a pointer atomically.<br/>
	/// ***Note: If you don't know what this function is for, you shouldn't use<br/>
	/// it!***<br/>
	/// <br/>
	/// @param a a pointer to a pointer.<br/>
	/// @returns the current value of a pointer.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CompareAndSwapAtomicPointer<br/>
	/// @sa SDL_SetAtomicPointer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAtomicPointer")]
	public static partial nint SDL_GetAtomicPointer(nint a);

	/// <summary>
	/// Use this function to get the number of built-in audio drivers.<br/>
	/// This function returns a hardcoded number. This never returns a negative<br/>
	/// value; if there are no drivers compiled into this build of SDL, this<br/>
	/// function returns zero. The presence of a driver in this list does not mean<br/>
	/// it will function, it just means SDL is capable of interacting with that<br/>
	/// interface. For example, a build of SDL might have esound support, but if<br/>
	/// there's no esound server available, SDL's esound driver would fail if used.<br/>
	/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
	/// found to be usable.<br/>
	/// <br/>
	/// @returns the number of built-in audio drivers.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAudioDriver
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumAudioDrivers")]
	public static partial int SDL_GetNumAudioDrivers();

	/// <summary>
	/// Use this function to get the name of a built in audio driver.<br/>
	/// The list of audio drivers is given in the order that they are normally<br/>
	/// initialized by default; the drivers that seem more reasonable to choose<br/>
	/// first (as far as the SDL developers believe) are earlier in the list.<br/>
	/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
	/// "coreaudio" or "wasapi". These never have Unicode characters, and are not<br/>
	/// meant to be proper names.<br/>
	/// <br/>
	/// @param index the index of the audio driver; the value ranges from 0 to<br/>
	/// SDL_GetNumAudioDrivers() - 1.<br/>
	/// @returns the name of the audio driver at the requested index, or NULL if an<br/>
	/// invalid index was specified.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumAudioDrivers
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioDriver")]
	public static partial byte* SDL_GetAudioDriverPtr(int index);

	public static string? SDL_GetAudioDriver(int index)
	{
		return ConvertToManaged(SDL_GetAudioDriverPtr(index));
	}

	/// <summary>
	/// Get the name of the current audio driver.<br/>
	/// The names of drivers are all simple, low-ASCII identifiers, like "alsa",<br/>
	/// "coreaudio" or "wasapi". These never have Unicode characters, and are not<br/>
	/// meant to be proper names.<br/>
	/// <br/>
	/// @returns the name of the current audio driver or NULL if no driver has been<br/>
	/// initialized.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentAudioDriver")]
	public static partial byte* SDL_GetCurrentAudioDriverPtr();

	public static string? SDL_GetCurrentAudioDriver()
	{
		return ConvertToManaged(SDL_GetCurrentAudioDriverPtr());
	}

	/// <summary>
	/// Get a list of currently-connected audio playback devices.<br/>
	/// This returns of list of available devices that play sound, perhaps to<br/>
	/// speakers or headphones ("playback" devices). If you want devices that<br/>
	/// record audio, like a microphone ("recording" devices), use<br/>
	/// SDL_GetAudioRecordingDevices() instead.<br/>
	/// This only returns a list of physical devices; it will not have any device<br/>
	/// IDs returned by SDL_OpenAudioDevice().<br/>
	/// If this function returns NULL, to signify an error, `*count` will be set to<br/>
	/// zero.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of devices returned, may<br/>
	/// be NULL.<br/>
	/// @returns a 0 terminated array of device instance IDs or NULL on error; call<br/>
	/// SDL_GetError() for more information. This should be freed with<br/>
	/// SDL_free() when it is no longer needed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenAudioDevice<br/>
	/// @sa SDL_GetAudioRecordingDevices
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioPlaybackDevices")]
	public static partial SDL_AudioDeviceID* SDL_GetAudioPlaybackDevices(out int count);

	/// <summary>
	/// Get a list of currently-connected audio recording devices.<br/>
	/// This returns of list of available devices that record audio, like a<br/>
	/// microphone ("recording" devices). If you want devices that play sound,<br/>
	/// perhaps to speakers or headphones ("playback" devices), use<br/>
	/// SDL_GetAudioPlaybackDevices() instead.<br/>
	/// This only returns a list of physical devices; it will not have any device<br/>
	/// IDs returned by SDL_OpenAudioDevice().<br/>
	/// If this function returns NULL, to signify an error, `*count` will be set to<br/>
	/// zero.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of devices returned, may<br/>
	/// be NULL.<br/>
	/// @returns a 0 terminated array of device instance IDs, or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This should be freed<br/>
	/// with SDL_free() when it is no longer needed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenAudioDevice<br/>
	/// @sa SDL_GetAudioPlaybackDevices
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioRecordingDevices")]
	public static partial SDL_AudioDeviceID* SDL_GetAudioRecordingDevices(out int count);

	/// <summary>
	/// Get the human-readable name of a specific audio device.<br/>
	/// <br/>
	/// @param devid the instance ID of the device to query.<br/>
	/// @returns the name of the audio device, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAudioPlaybackDevices<br/>
	/// @sa SDL_GetAudioRecordingDevices<br/>
	/// @sa SDL_GetDefaultAudioInfo
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioDeviceName")]
	public static partial byte* SDL_GetAudioDeviceNamePtr(SDL_AudioDeviceID devid);

	public static string? SDL_GetAudioDeviceName(SDL_AudioDeviceID devid)
	{
		return ConvertToManaged(SDL_GetAudioDeviceNamePtr(devid));
	}

	/// <summary>
	/// Get the current audio format of a specific audio device.<br/>
	/// For an opened device, this will report the format the device is currently<br/>
	/// using. If the device isn't yet opened, this will report the device's<br/>
	/// preferred format (or a reasonable default if this can't be determined).<br/>
	/// You may also specify SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or<br/>
	/// SDL_AUDIO_DEVICE_DEFAULT_RECORDING here, which is useful for getting a<br/>
	/// reasonable recommendation before opening the system-recommended default<br/>
	/// device.<br/>
	/// You can also use this to request the current device buffer size. This is<br/>
	/// specified in sample frames and represents the amount of data SDL will feed<br/>
	/// to the physical hardware in each chunk. This can be converted to<br/>
	/// milliseconds of audio with the following equation:<br/>
	/// `ms = (int) ((((Sint64) frames) * 1000) / spec.freq);`<br/>
	/// Buffer size is only important if you need low-level control over the audio<br/>
	/// playback timing. Most apps do not need this.<br/>
	/// <br/>
	/// @param devid the instance ID of the device to query.<br/>
	/// @param spec on return, will be filled with device details.<br/>
	/// @param sample_frames pointer to store device buffer size, in sample frames.<br/>
	/// Can be NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioDeviceFormat")]
	public static partial SDLBool SDL_GetAudioDeviceFormat(SDL_AudioDeviceID devid, SDL_AudioSpec* spec, int* sample_frames);

	/// <summary>
	/// Get the current channel map of an audio device.<br/>
	/// Channel maps are optional; most things do not need them, instead passing<br/>
	/// data in the [order that SDL expects](CategoryAudio#channel-layouts).<br/>
	/// Audio devices usually have no remapping applied. This is represented by<br/>
	/// returning NULL, and does not signify an error.<br/>
	/// <br/>
	/// @param devid the instance ID of the device to query.<br/>
	/// @param count On output, set to number of channels in the map. Can be NULL.<br/>
	/// @returns an array of the current channel mapping, with as many elements as<br/>
	/// the current output spec's channels, or NULL if default. This<br/>
	/// should be freed with SDL_free() when it is no longer needed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioStreamInputChannelMap
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioDeviceChannelMap")]
	public static partial int* SDL_GetAudioDeviceChannelMap(SDL_AudioDeviceID devid, out int count);

	/// <summary>
	/// Open a specific audio device.<br/>
	/// You can open both playback and recording devices through this function.<br/>
	/// Playback devices will take data from bound audio streams, mix it, and send<br/>
	/// it to the hardware. Recording devices will feed any bound audio streams<br/>
	/// with a copy of any incoming data.<br/>
	/// An opened audio device starts out with no audio streams bound. To start<br/>
	/// audio playing, bind a stream and supply audio data to it. Unlike SDL2,<br/>
	/// there is no audio callback; you only bind audio streams and make sure they<br/>
	/// have data flowing into them (however, you can simulate SDL2's semantics<br/>
	/// fairly closely by using SDL_OpenAudioDeviceStream instead of this<br/>
	/// function).<br/>
	/// If you don't care about opening a specific device, pass a `devid` of either<br/>
	/// `SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK` or<br/>
	/// `SDL_AUDIO_DEVICE_DEFAULT_RECORDING`. In this case, SDL will try to pick<br/>
	/// the most reasonable default, and may also switch between physical devices<br/>
	/// seamlessly later, if the most reasonable default changes during the<br/>
	/// lifetime of this opened device (user changed the default in the OS's system<br/>
	/// preferences, the default got unplugged so the system jumped to a new<br/>
	/// default, the user plugged in headphones on a mobile device, etc). Unless<br/>
	/// you have a good reason to choose a specific device, this is probably what<br/>
	/// you want.<br/>
	/// You may request a specific format for the audio device, but there is no<br/>
	/// promise the device will honor that request for several reasons. As such,<br/>
	/// it's only meant to be a hint as to what data your app will provide. Audio<br/>
	/// streams will accept data in whatever format you specify and manage<br/>
	/// conversion for you as appropriate. SDL_GetAudioDeviceFormat can tell you<br/>
	/// the preferred format for the device before opening and the actual format<br/>
	/// the device is using after opening.<br/>
	/// It's legal to open the same device ID more than once; each successful open<br/>
	/// will generate a new logical SDL_AudioDeviceID that is managed separately<br/>
	/// from others on the same physical device. This allows libraries to open a<br/>
	/// device separately from the main app and bind its own streams without<br/>
	/// conflicting.<br/>
	/// It is also legal to open a device ID returned by a previous call to this<br/>
	/// function; doing so just creates another logical device on the same physical<br/>
	/// device. This may be useful for making logical groupings of audio streams.<br/>
	/// This function returns the opened device ID on success. This is a new,<br/>
	/// unique SDL_AudioDeviceID that represents a logical device.<br/>
	/// Some backends might offer arbitrary devices (for example, a networked audio<br/>
	/// protocol that can connect to an arbitrary server). For these, as a change<br/>
	/// from SDL2, you should open a default device ID and use an SDL hint to<br/>
	/// specify the target if you care, or otherwise let the backend figure out a<br/>
	/// reasonable default. Most backends don't offer anything like this, and often<br/>
	/// this would be an end user setting an environment variable for their custom<br/>
	/// need, and not something an application should specifically manage.<br/>
	/// When done with an audio device, possibly at the end of the app's life, one<br/>
	/// should call SDL_CloseAudioDevice() on the returned device id.<br/>
	/// <br/>
	/// @param devid the device instance id to open, or<br/>
	/// SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK or<br/>
	/// SDL_AUDIO_DEVICE_DEFAULT_RECORDING for the most reasonable<br/>
	/// default device.<br/>
	/// @param spec the requested device configuration. Can be NULL to use<br/>
	/// reasonable defaults.<br/>
	/// @returns the device ID on success or 0 on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseAudioDevice<br/>
	/// @sa SDL_GetAudioDeviceFormat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenAudioDevice")]
	public static partial SDL_AudioDeviceID SDL_OpenAudioDevice(SDL_AudioDeviceID devid, SDL_AudioSpec* spec);

	/// <summary>
	/// Use this function to pause audio playback on a specified device.<br/>
	/// This function pauses audio processing for a given device. Any bound audio<br/>
	/// streams will not progress, and no audio will be generated. Pausing one<br/>
	/// device does not prevent other unpaused devices from running.<br/>
	/// Unlike in SDL2, audio devices start in an _unpaused_ state, since an app<br/>
	/// has to bind a stream before any audio will flow. Pausing a paused device is<br/>
	/// a legal no-op.<br/>
	/// Pausing a device can be useful to halt all audio without unbinding all the<br/>
	/// audio streams. This might be useful while a game is paused, or a level is<br/>
	/// loading, etc.<br/>
	/// Physical devices can not be paused or unpaused, only logical devices<br/>
	/// created through SDL_OpenAudioDevice() can be.<br/>
	/// <br/>
	/// @param dev a device opened by SDL_OpenAudioDevice().<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ResumeAudioDevice<br/>
	/// @sa SDL_AudioDevicePaused
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PauseAudioDevice")]
	public static partial SDLBool SDL_PauseAudioDevice(SDL_AudioDeviceID dev);

	/// <summary>
	/// Use this function to unpause audio playback on a specified device.<br/>
	/// This function unpauses audio processing for a given device that has<br/>
	/// previously been paused with SDL_PauseAudioDevice(). Once unpaused, any<br/>
	/// bound audio streams will begin to progress again, and audio can be<br/>
	/// generated.<br/>
	/// Unlike in SDL2, audio devices start in an _unpaused_ state, since an app<br/>
	/// has to bind a stream before any audio will flow. Unpausing an unpaused<br/>
	/// device is a legal no-op.<br/>
	/// Physical devices can not be paused or unpaused, only logical devices<br/>
	/// created through SDL_OpenAudioDevice() can be.<br/>
	/// <br/>
	/// @param dev a device opened by SDL_OpenAudioDevice().<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AudioDevicePaused<br/>
	/// @sa SDL_PauseAudioDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ResumeAudioDevice")]
	public static partial SDLBool SDL_ResumeAudioDevice(SDL_AudioDeviceID dev);

	/// <summary>
	/// Use this function to query if an audio device is paused.<br/>
	/// Unlike in SDL2, audio devices start in an _unpaused_ state, since an app<br/>
	/// has to bind a stream before any audio will flow.<br/>
	/// Physical devices can not be paused or unpaused, only logical devices<br/>
	/// created through SDL_OpenAudioDevice() can be. Physical and invalid device<br/>
	/// IDs will report themselves as unpaused here.<br/>
	/// <br/>
	/// @param dev a device opened by SDL_OpenAudioDevice().<br/>
	/// @returns true if device is valid and paused, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PauseAudioDevice<br/>
	/// @sa SDL_ResumeAudioDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AudioDevicePaused")]
	public static partial SDLBool SDL_AudioDevicePaused(SDL_AudioDeviceID dev);

	/// <summary>
	/// Get the gain of an audio device.<br/>
	/// The gain of a device is its volume; a larger gain means a louder output,<br/>
	/// with a gain of zero being silence.<br/>
	/// Audio devices default to a gain of 1.0f (no change in output).<br/>
	/// Physical devices may not have their gain changed, only logical devices, and<br/>
	/// this function will always return -1.0f when used on physical devices.<br/>
	/// <br/>
	/// @param devid the audio device to query.<br/>
	/// @returns the gain of the device or -1.0f on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioDeviceGain
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioDeviceGain")]
	public static partial float SDL_GetAudioDeviceGain(SDL_AudioDeviceID devid);

	/// <summary>
	/// Change the gain of an audio device.<br/>
	/// The gain of a device is its volume; a larger gain means a louder output,<br/>
	/// with a gain of zero being silence.<br/>
	/// Audio devices default to a gain of 1.0f (no change in output).<br/>
	/// Physical devices may not have their gain changed, only logical devices, and<br/>
	/// this function will always return false when used on physical devices. While<br/>
	/// it might seem attractive to adjust several logical devices at once in this<br/>
	/// way, it would allow an app or library to interfere with another portion of<br/>
	/// the program's otherwise-isolated devices.<br/>
	/// This is applied, along with any per-audiostream gain, during playback to<br/>
	/// the hardware, and can be continuously changed to create various effects. On<br/>
	/// recording devices, this will adjust the gain before passing the data into<br/>
	/// an audiostream; that recording audiostream can then adjust its gain further<br/>
	/// when outputting the data elsewhere, if it likes, but that second gain is<br/>
	/// not applied until the data leaves the audiostream again.<br/>
	/// <br/>
	/// @param devid the audio device on which to change gain.<br/>
	/// @param gain the gain. 1.0f is no change, 0.0f is silence.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAudioDeviceGain
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAudioDeviceGain")]
	public static partial SDLBool SDL_SetAudioDeviceGain(SDL_AudioDeviceID devid, float gain);

	/// <summary>
	/// Close a previously-opened audio device.<br/>
	/// The application should close open audio devices once they are no longer<br/>
	/// needed.<br/>
	/// This function may block briefly while pending audio data is played by the<br/>
	/// hardware, so that applications don't drop the last buffer of data they<br/>
	/// supplied if terminating immediately afterwards.<br/>
	/// <br/>
	/// @param devid an audio device id previously returned by<br/>
	/// SDL_OpenAudioDevice().<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenAudioDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CloseAudioDevice")]
	public static partial void SDL_CloseAudioDevice(SDL_AudioDeviceID devid);

	/// <summary>
	/// Bind a list of audio streams to an audio device.<br/>
	/// Audio data will flow through any bound streams. For a playback device, data<br/>
	/// for all bound streams will be mixed together and fed to the device. For a<br/>
	/// recording device, a copy of recorded data will be provided to each bound<br/>
	/// stream.<br/>
	/// Audio streams can only be bound to an open device. This operation is<br/>
	/// atomic--all streams bound in the same call will start processing at the<br/>
	/// same time, so they can stay in sync. Also: either all streams will be bound<br/>
	/// or none of them will be.<br/>
	/// It is an error to bind an already-bound stream; it must be explicitly<br/>
	/// unbound first.<br/>
	/// Binding a stream to a device will set its output format for playback<br/>
	/// devices, and its input format for recording devices, so they match the<br/>
	/// device's settings. The caller is welcome to change the other end of the<br/>
	/// stream's format at any time.<br/>
	/// <br/>
	/// @param devid an audio device to bind a stream to.<br/>
	/// @param streams an array of audio streams to bind.<br/>
	/// @param num_streams number streams listed in the `streams` array.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BindAudioStreams<br/>
	/// @sa SDL_UnbindAudioStream<br/>
	/// @sa SDL_GetAudioStreamDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindAudioStreams")]
	public static partial SDLBool SDL_BindAudioStreams(SDL_AudioDeviceID devid, SDL_AudioStream streams, int num_streams);

	/// <summary>
	/// Bind a single audio stream to an audio device.<br/>
	/// This is a convenience function, equivalent to calling<br/>
	/// `SDL_BindAudioStreams(devid,<br/>
	/// &stream<br/>
	/// , 1)`.<br/>
	/// <br/>
	/// @param devid an audio device to bind a stream to.<br/>
	/// @param stream an audio stream to bind to a device.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BindAudioStreams<br/>
	/// @sa SDL_UnbindAudioStream<br/>
	/// @sa SDL_GetAudioStreamDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindAudioStream")]
	public static partial SDLBool SDL_BindAudioStream(SDL_AudioDeviceID devid, SDL_AudioStream stream);

	/// <summary>
	/// Unbind a list of audio streams from their audio devices.<br/>
	/// The streams being unbound do not all have to be on the same device. All<br/>
	/// streams on the same device will be unbound atomically (data will stop<br/>
	/// flowing through all unbound streams on the same device at the same time).<br/>
	/// Unbinding a stream that isn't bound to a device is a legal no-op.<br/>
	/// <br/>
	/// @param streams an array of audio streams to unbind.<br/>
	/// @param num_streams number streams listed in the `streams` array.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BindAudioStreams
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnbindAudioStreams")]
	public static partial void SDL_UnbindAudioStreams(SDL_AudioStream streams, int num_streams);

	/// <summary>
	/// Unbind a single audio stream from its audio device.<br/>
	/// This is a convenience function, equivalent to calling<br/>
	/// `SDL_UnbindAudioStreams(<br/>
	/// &stream<br/>
	/// , 1)`.<br/>
	/// <br/>
	/// @param stream an audio stream to unbind from a device.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BindAudioStream
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnbindAudioStream")]
	public static partial void SDL_UnbindAudioStream(SDL_AudioStream stream);

	/// <summary>
	/// Query an audio stream for its currently-bound device.<br/>
	/// This reports the audio device that an audio stream is currently bound to.<br/>
	/// If not bound, or invalid, this returns zero, which is not a valid device<br/>
	/// ID.<br/>
	/// <br/>
	/// @param stream the audio stream to query.<br/>
	/// @returns the bound audio device, or 0 if not bound or invalid.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BindAudioStream<br/>
	/// @sa SDL_BindAudioStreams
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStreamDevice")]
	public static partial SDL_AudioDeviceID SDL_GetAudioStreamDevice(SDL_AudioStream stream);

	/// <summary>
	/// Create a new audio stream.<br/>
	/// <br/>
	/// @param src_spec the format details of the input audio.<br/>
	/// @param dst_spec the format details of the output audio.<br/>
	/// @returns a new audio stream on success or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PutAudioStreamData<br/>
	/// @sa SDL_GetAudioStreamData<br/>
	/// @sa SDL_GetAudioStreamAvailable<br/>
	/// @sa SDL_FlushAudioStream<br/>
	/// @sa SDL_ClearAudioStream<br/>
	/// @sa SDL_SetAudioStreamFormat<br/>
	/// @sa SDL_DestroyAudioStream
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateAudioStream")]
	public static partial SDL_AudioStream SDL_CreateAudioStream(SDL_AudioSpec* src_spec, SDL_AudioSpec* dst_spec);

	/// <summary>
	/// Get the properties associated with an audio stream.<br/>
	/// <br/>
	/// @param stream the SDL_AudioStream to query.<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStreamProperties")]
	public static partial SDL_PropertiesID SDL_GetAudioStreamProperties(SDL_AudioStream stream);

	/// <summary>
	/// Query the current format of an audio stream.<br/>
	/// <br/>
	/// @param stream the SDL_AudioStream to query.<br/>
	/// @param src_spec where to store the input audio format; ignored if NULL.<br/>
	/// @param dst_spec where to store the output audio format; ignored if NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioStreamFormat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStreamFormat")]
	public static partial SDLBool SDL_GetAudioStreamFormat(SDL_AudioStream stream, SDL_AudioSpec* src_spec, SDL_AudioSpec* dst_spec);

	/// <summary>
	/// Change the input and output formats of an audio stream.<br/>
	/// Future calls to and SDL_GetAudioStreamAvailable and SDL_GetAudioStreamData<br/>
	/// will reflect the new format, and future calls to SDL_PutAudioStreamData<br/>
	/// must provide data in the new input formats.<br/>
	/// Data that was previously queued in the stream will still be operated on in<br/>
	/// the format that was current when it was added, which is to say you can put<br/>
	/// the end of a sound file in one format to a stream, change formats for the<br/>
	/// next sound file, and start putting that new data while the previous sound<br/>
	/// file is still queued, and everything will still play back correctly.<br/>
	/// <br/>
	/// @param stream the stream the format is being changed.<br/>
	/// @param src_spec the new format of the audio input; if NULL, it is not<br/>
	/// changed.<br/>
	/// @param dst_spec the new format of the audio output; if NULL, it is not<br/>
	/// changed.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAudioStreamFormat<br/>
	/// @sa SDL_SetAudioStreamFrequencyRatio
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAudioStreamFormat")]
	public static partial SDLBool SDL_SetAudioStreamFormat(SDL_AudioStream stream, SDL_AudioSpec* src_spec, SDL_AudioSpec* dst_spec);

	/// <summary>
	/// Get the frequency ratio of an audio stream.<br/>
	/// <br/>
	/// @param stream the SDL_AudioStream to query.<br/>
	/// @returns the frequency ratio of the stream or 0.0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioStreamFrequencyRatio
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStreamFrequencyRatio")]
	public static partial float SDL_GetAudioStreamFrequencyRatio(SDL_AudioStream stream);

	/// <summary>
	/// Change the frequency ratio of an audio stream.<br/>
	/// The frequency ratio is used to adjust the rate at which input data is<br/>
	/// consumed. Changing this effectively modifies the speed and pitch of the<br/>
	/// audio. A value greater than 1.0 will play the audio faster, and at a higher<br/>
	/// pitch. A value less than 1.0 will play the audio slower, and at a lower<br/>
	/// pitch.<br/>
	/// This is applied during SDL_GetAudioStreamData, and can be continuously<br/>
	/// changed to create various effects.<br/>
	/// <br/>
	/// @param stream the stream the frequency ratio is being changed.<br/>
	/// @param ratio the frequency ratio. 1.0 is normal speed. Must be between 0.01<br/>
	/// and 100.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAudioStreamFrequencyRatio<br/>
	/// @sa SDL_SetAudioStreamFormat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAudioStreamFrequencyRatio")]
	public static partial SDLBool SDL_SetAudioStreamFrequencyRatio(SDL_AudioStream stream, float ratio);

	/// <summary>
	/// Get the gain of an audio stream.<br/>
	/// The gain of a stream is its volume; a larger gain means a louder output,<br/>
	/// with a gain of zero being silence.<br/>
	/// Audio streams default to a gain of 1.0f (no change in output).<br/>
	/// <br/>
	/// @param stream the SDL_AudioStream to query.<br/>
	/// @returns the gain of the stream or -1.0f on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioStreamGain
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStreamGain")]
	public static partial float SDL_GetAudioStreamGain(SDL_AudioStream stream);

	/// <summary>
	/// Change the gain of an audio stream.<br/>
	/// The gain of a stream is its volume; a larger gain means a louder output,<br/>
	/// with a gain of zero being silence.<br/>
	/// Audio streams default to a gain of 1.0f (no change in output).<br/>
	/// This is applied during SDL_GetAudioStreamData, and can be continuously<br/>
	/// changed to create various effects.<br/>
	/// <br/>
	/// @param stream the stream on which the gain is being changed.<br/>
	/// @param gain the gain. 1.0f is no change, 0.0f is silence.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAudioStreamGain
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAudioStreamGain")]
	public static partial SDLBool SDL_SetAudioStreamGain(SDL_AudioStream stream, float gain);

	/// <summary>
	/// Get the current input channel map of an audio stream.<br/>
	/// Channel maps are optional; most things do not need them, instead passing<br/>
	/// data in the [order that SDL expects](CategoryAudio#channel-layouts).<br/>
	/// Audio streams default to no remapping applied. This is represented by<br/>
	/// returning NULL, and does not signify an error.<br/>
	/// <br/>
	/// @param stream the SDL_AudioStream to query.<br/>
	/// @param count On output, set to number of channels in the map. Can be NULL.<br/>
	/// @returns an array of the current channel mapping, with as many elements as<br/>
	/// the current output spec's channels, or NULL if default. This<br/>
	/// should be freed with SDL_free() when it is no longer needed.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioStreamInputChannelMap
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStreamInputChannelMap")]
	public static partial int* SDL_GetAudioStreamInputChannelMap(SDL_AudioStream stream, out int count);

	/// <summary>
	/// Get the current output channel map of an audio stream.<br/>
	/// Channel maps are optional; most things do not need them, instead passing<br/>
	/// data in the [order that SDL expects](CategoryAudio#channel-layouts).<br/>
	/// Audio streams default to no remapping applied. This is represented by<br/>
	/// returning NULL, and does not signify an error.<br/>
	/// <br/>
	/// @param stream the SDL_AudioStream to query.<br/>
	/// @param count On output, set to number of channels in the map. Can be NULL.<br/>
	/// @returns an array of the current channel mapping, with as many elements as<br/>
	/// the current output spec's channels, or NULL if default. This<br/>
	/// should be freed with SDL_free() when it is no longer needed.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioStreamInputChannelMap
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStreamOutputChannelMap")]
	public static partial int* SDL_GetAudioStreamOutputChannelMap(SDL_AudioStream stream, out int count);

	/// <summary>
	/// Set the current input channel map of an audio stream.<br/>
	/// Channel maps are optional; most things do not need them, instead passing<br/>
	/// data in the [order that SDL expects](CategoryAudio#channel-layouts).<br/>
	/// The input channel map reorders data that is added to a stream via<br/>
	/// SDL_PutAudioStreamData. Future calls to SDL_PutAudioStreamData must provide<br/>
	/// data in the new channel order.<br/>
	/// Each item in the array represents an input channel, and its value is the<br/>
	/// channel that it should be remapped to. To reverse a stereo signal's left<br/>
	/// and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap<br/>
	/// multiple channels to the same thing, so `{ 1, 1 }` would duplicate the<br/>
	/// right channel to both channels of a stereo signal. You cannot change the<br/>
	/// number of channels through a channel map, just reorder them.<br/>
	/// Data that was previously queued in the stream will still be operated on in<br/>
	/// the order that was current when it was added, which is to say you can put<br/>
	/// the end of a sound file in one order to a stream, change orders for the<br/>
	/// next sound file, and start putting that new data while the previous sound<br/>
	/// file is still queued, and everything will still play back correctly.<br/>
	/// Audio streams default to no remapping applied. Passing a NULL channel map<br/>
	/// is legal, and turns off remapping.<br/>
	/// SDL will copy the channel map; the caller does not have to save this array<br/>
	/// after this call.<br/>
	/// If `count` is not equal to the current number of channels in the audio<br/>
	/// stream's format, this will fail. This is a safety measure to make sure a a<br/>
	/// race condition hasn't changed the format while you this call is setting the<br/>
	/// channel map.<br/>
	/// <br/>
	/// @param stream the SDL_AudioStream to change.<br/>
	/// @param chmap the new channel map, NULL to reset to default.<br/>
	/// @param count The number of channels in the map.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running. Don't change the<br/>
	/// stream's format to have a different number of channels from a<br/>
	/// a different thread at the same time, though!<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioStreamInputChannelMap
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAudioStreamInputChannelMap")]
	public static partial SDLBool SDL_SetAudioStreamInputChannelMap(SDL_AudioStream stream, int* chmap, int count);

	/// <summary>
	/// Set the current output channel map of an audio stream.<br/>
	/// Channel maps are optional; most things do not need them, instead passing<br/>
	/// data in the [order that SDL expects](CategoryAudio#channel-layouts).<br/>
	/// The output channel map reorders data that leaving a stream via<br/>
	/// SDL_GetAudioStreamData.<br/>
	/// Each item in the array represents an output channel, and its value is the<br/>
	/// channel that it should be remapped to. To reverse a stereo signal's left<br/>
	/// and right values, you'd have an array of `{ 1, 0 }`. It is legal to remap<br/>
	/// multiple channels to the same thing, so `{ 1, 1 }` would duplicate the<br/>
	/// right channel to both channels of a stereo signal. You cannot change the<br/>
	/// number of channels through a channel map, just reorder them.<br/>
	/// The output channel map can be changed at any time, as output remapping is<br/>
	/// applied during SDL_GetAudioStreamData.<br/>
	/// Audio streams default to no remapping applied. Passing a NULL channel map<br/>
	/// is legal, and turns off remapping.<br/>
	/// SDL will copy the channel map; the caller does not have to save this array<br/>
	/// after this call.<br/>
	/// If `count` is not equal to the current number of channels in the audio<br/>
	/// stream's format, this will fail. This is a safety measure to make sure a a<br/>
	/// race condition hasn't changed the format while you this call is setting the<br/>
	/// channel map.<br/>
	/// <br/>
	/// @param stream the SDL_AudioStream to change.<br/>
	/// @param chmap the new channel map, NULL to reset to default.<br/>
	/// @param count The number of channels in the map.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread, as it holds<br/>
	/// a stream-specific mutex while running. Don't change the<br/>
	/// stream's format to have a different number of channels from a<br/>
	/// a different thread at the same time, though!<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioStreamInputChannelMap
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAudioStreamOutputChannelMap")]
	public static partial SDLBool SDL_SetAudioStreamOutputChannelMap(SDL_AudioStream stream, int* chmap, int count);

	/// <summary>
	/// Add data to the stream.<br/>
	/// This data must match the format/channels/samplerate specified in the latest<br/>
	/// call to SDL_SetAudioStreamFormat, or the format specified when creating the<br/>
	/// stream if it hasn't been changed.<br/>
	/// Note that this call simply copies the unconverted data for later. This is<br/>
	/// different than SDL2, where data was converted during the Put call and the<br/>
	/// Get call would just dequeue the previously-converted data.<br/>
	/// <br/>
	/// @param stream the stream the audio data is being added to.<br/>
	/// @param buf a pointer to the audio data to add.<br/>
	/// @param len the number of bytes to write to the stream.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread, but if the<br/>
	/// stream has a callback set, the caller might need to manage<br/>
	/// extra locking.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ClearAudioStream<br/>
	/// @sa SDL_FlushAudioStream<br/>
	/// @sa SDL_GetAudioStreamData<br/>
	/// @sa SDL_GetAudioStreamQueued
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PutAudioStreamData")]
	public static partial SDLBool SDL_PutAudioStreamData(SDL_AudioStream stream, nint buf, int len);

	/// <summary>
	/// Get converted/resampled data from the stream.<br/>
	/// The input/output data format/channels/samplerate is specified when creating<br/>
	/// the stream, and can be changed after creation by calling<br/>
	/// SDL_SetAudioStreamFormat.<br/>
	/// Note that any conversion and resampling necessary is done during this call,<br/>
	/// and SDL_PutAudioStreamData simply queues unconverted data for later. This<br/>
	/// is different than SDL2, where that work was done while inputting new data<br/>
	/// to the stream and requesting the output just copied the converted data.<br/>
	/// <br/>
	/// @param stream the stream the audio is being requested from.<br/>
	/// @param buf a buffer to fill with audio data.<br/>
	/// @param len the maximum number of bytes to fill.<br/>
	/// @returns the number of bytes read from the stream or -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread, but if the<br/>
	/// stream has a callback set, the caller might need to manage<br/>
	/// extra locking.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ClearAudioStream<br/>
	/// @sa SDL_GetAudioStreamAvailable<br/>
	/// @sa SDL_PutAudioStreamData
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStreamData")]
	public static partial int SDL_GetAudioStreamData(SDL_AudioStream stream, nint buf, int len);

	/// <summary>
	/// Get the number of converted/resampled bytes available.<br/>
	/// The stream may be buffering data behind the scenes until it has enough to<br/>
	/// resample correctly, so this number might be lower than what you expect, or<br/>
	/// even be zero. Add more data or flush the stream if you need the data now.<br/>
	/// If the stream has so much data that it would overflow an int, the return<br/>
	/// value is clamped to a maximum value, but no queued data is lost; if there<br/>
	/// are gigabytes of data queued, the app might need to read some of it with<br/>
	/// SDL_GetAudioStreamData before this function's return value is no longer<br/>
	/// clamped.<br/>
	/// <br/>
	/// @param stream the audio stream to query.<br/>
	/// @returns the number of converted/resampled bytes available or -1 on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAudioStreamData<br/>
	/// @sa SDL_PutAudioStreamData
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStreamAvailable")]
	public static partial int SDL_GetAudioStreamAvailable(SDL_AudioStream stream);

	/// <summary>
	/// Get the number of bytes currently queued.<br/>
	/// This is the number of bytes put into a stream as input, not the number that<br/>
	/// can be retrieved as output. Because of several details, it's not possible<br/>
	/// to calculate one number directly from the other. If you need to know how<br/>
	/// much usable data can be retrieved right now, you should use<br/>
	/// SDL_GetAudioStreamAvailable() and not this function.<br/>
	/// Note that audio streams can change their input format at any time, even if<br/>
	/// there is still data queued in a different format, so the returned byte<br/>
	/// count will not necessarily match the number of _sample frames_ available.<br/>
	/// Users of this API should be aware of format changes they make when feeding<br/>
	/// a stream and plan accordingly.<br/>
	/// Queued data is not converted until it is consumed by<br/>
	/// SDL_GetAudioStreamData, so this value should be representative of the exact<br/>
	/// data that was put into the stream.<br/>
	/// If the stream has so much data that it would overflow an int, the return<br/>
	/// value is clamped to a maximum value, but no queued data is lost; if there<br/>
	/// are gigabytes of data queued, the app might need to read some of it with<br/>
	/// SDL_GetAudioStreamData before this function's return value is no longer<br/>
	/// clamped.<br/>
	/// <br/>
	/// @param stream the audio stream to query.<br/>
	/// @returns the number of bytes queued or -1 on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PutAudioStreamData<br/>
	/// @sa SDL_ClearAudioStream
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioStreamQueued")]
	public static partial int SDL_GetAudioStreamQueued(SDL_AudioStream stream);

	/// <summary>
	/// Tell the stream that you're done sending data, and anything being buffered<br/>
	/// should be converted/resampled and made available immediately.<br/>
	/// It is legal to add more data to a stream after flushing, but there may be<br/>
	/// audio gaps in the output. Generally this is intended to signal the end of<br/>
	/// input, so the complete output becomes available.<br/>
	/// <br/>
	/// @param stream the audio stream to flush.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PutAudioStreamData
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_FlushAudioStream")]
	public static partial SDLBool SDL_FlushAudioStream(SDL_AudioStream stream);

	/// <summary>
	/// Clear any pending data in the stream.<br/>
	/// This drops any queued data, so there will be nothing to read from the<br/>
	/// stream until more is added.<br/>
	/// <br/>
	/// @param stream the audio stream to clear.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAudioStreamAvailable<br/>
	/// @sa SDL_GetAudioStreamData<br/>
	/// @sa SDL_GetAudioStreamQueued<br/>
	/// @sa SDL_PutAudioStreamData
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ClearAudioStream")]
	public static partial SDLBool SDL_ClearAudioStream(SDL_AudioStream stream);

	/// <summary>
	/// Use this function to pause audio playback on the audio device associated<br/>
	/// with an audio stream.<br/>
	/// This function pauses audio processing for a given device. Any bound audio<br/>
	/// streams will not progress, and no audio will be generated. Pausing one<br/>
	/// device does not prevent other unpaused devices from running.<br/>
	/// Pausing a device can be useful to halt all audio without unbinding all the<br/>
	/// audio streams. This might be useful while a game is paused, or a level is<br/>
	/// loading, etc.<br/>
	/// <br/>
	/// @param stream the audio stream associated with the audio device to pause.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ResumeAudioStreamDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PauseAudioStreamDevice")]
	public static partial SDLBool SDL_PauseAudioStreamDevice(SDL_AudioStream stream);

	/// <summary>
	/// Use this function to unpause audio playback on the audio device associated<br/>
	/// with an audio stream.<br/>
	/// This function unpauses audio processing for a given device that has<br/>
	/// previously been paused. Once unpaused, any bound audio streams will begin<br/>
	/// to progress again, and audio can be generated.<br/>
	/// <br/>
	/// @param stream the audio stream associated with the audio device to resume.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PauseAudioStreamDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ResumeAudioStreamDevice")]
	public static partial SDLBool SDL_ResumeAudioStreamDevice(SDL_AudioStream stream);

	/// <summary>
	/// Lock an audio stream for serialized access.<br/>
	/// Each SDL_AudioStream has an internal mutex it uses to protect its data<br/>
	/// structures from threading conflicts. This function allows an app to lock<br/>
	/// that mutex, which could be useful if registering callbacks on this stream.<br/>
	/// One does not need to lock a stream to use in it most cases, as the stream<br/>
	/// manages this lock internally. However, this lock is held during callbacks,<br/>
	/// which may run from arbitrary threads at any time, so if an app needs to<br/>
	/// protect shared data during those callbacks, locking the stream guarantees<br/>
	/// that the callback is not running while the lock is held.<br/>
	/// As this is just a wrapper over SDL_LockMutex for an internal lock; it has<br/>
	/// all the same attributes (recursive locks are allowed, etc).<br/>
	/// <br/>
	/// @param stream the audio stream to lock.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_UnlockAudioStream
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LockAudioStream")]
	public static partial SDLBool SDL_LockAudioStream(SDL_AudioStream stream);

	/// <summary>
	/// Unlock an audio stream for serialized access.<br/>
	/// This unlocks an audio stream after a call to SDL_LockAudioStream.<br/>
	/// <br/>
	/// @param stream the audio stream to unlock.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You should only call this from the same thread that<br/>
	/// previously called SDL_LockAudioStream.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockAudioStream
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnlockAudioStream")]
	public static partial SDLBool SDL_UnlockAudioStream(SDL_AudioStream stream);

	/// <summary>
	/// Set a callback that runs when data is requested from an audio stream.<br/>
	/// This callback is called _before_ data is obtained from the stream, giving<br/>
	/// the callback the chance to add more on-demand.<br/>
	/// The callback can (optionally) call SDL_PutAudioStreamData() to add more<br/>
	/// audio to the stream during this call; if needed, the request that triggered<br/>
	/// this callback will obtain the new data immediately.<br/>
	/// The callback's `approx_request` argument is roughly how many bytes of<br/>
	/// _unconverted_ data (in the stream's input format) is needed by the caller,<br/>
	/// although this may overestimate a little for safety. This takes into account<br/>
	/// how much is already in the stream and only asks for any extra necessary to<br/>
	/// resolve the request, which means the callback may be asked for zero bytes,<br/>
	/// and a different amount on each call.<br/>
	/// The callback is not required to supply exact amounts; it is allowed to<br/>
	/// supply too much or too little or none at all. The caller will get what's<br/>
	/// available, up to the amount they requested, regardless of this callback's<br/>
	/// outcome.<br/>
	/// Clearing or flushing an audio stream does not call this callback.<br/>
	/// This function obtains the stream's lock, which means any existing callback<br/>
	/// (get or put) in progress will finish running before setting the new<br/>
	/// callback.<br/>
	/// Setting a NULL function turns off the callback.<br/>
	/// <br/>
	/// @param stream the audio stream to set the new callback on.<br/>
	/// @param callback the new callback function to call when data is requested<br/>
	/// from the stream.<br/>
	/// @param userdata an opaque pointer provided to the callback for its own<br/>
	/// personal use.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information. This only fails if `stream` is NULL.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioStreamPutCallback
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAudioStreamGetCallback")]
	public static partial SDLBool SDL_SetAudioStreamGetCallback(SDL_AudioStream stream, delegate* unmanaged[Cdecl]<nint, SDL_AudioStream, int, int, void> callback, nint userdata);

	/// <summary>
	/// Set a callback that runs when data is added to an audio stream.<br/>
	/// This callback is called _after_ the data is added to the stream, giving the<br/>
	/// callback the chance to obtain it immediately.<br/>
	/// The callback can (optionally) call SDL_GetAudioStreamData() to obtain audio<br/>
	/// from the stream during this call.<br/>
	/// The callback's `approx_request` argument is how many bytes of _converted_<br/>
	/// data (in the stream's output format) was provided by the caller, although<br/>
	/// this may underestimate a little for safety. This value might be less than<br/>
	/// what is currently available in the stream, if data was already there, and<br/>
	/// might be less than the caller provided if the stream needs to keep a buffer<br/>
	/// to aid in resampling. Which means the callback may be provided with zero<br/>
	/// bytes, and a different amount on each call.<br/>
	/// The callback may call SDL_GetAudioStreamAvailable to see the total amount<br/>
	/// currently available to read from the stream, instead of the total provided<br/>
	/// by the current call.<br/>
	/// The callback is not required to obtain all data. It is allowed to read less<br/>
	/// or none at all. Anything not read now simply remains in the stream for<br/>
	/// later access.<br/>
	/// Clearing or flushing an audio stream does not call this callback.<br/>
	/// This function obtains the stream's lock, which means any existing callback<br/>
	/// (get or put) in progress will finish running before setting the new<br/>
	/// callback.<br/>
	/// Setting a NULL function turns off the callback.<br/>
	/// <br/>
	/// @param stream the audio stream to set the new callback on.<br/>
	/// @param callback the new callback function to call when data is added to the<br/>
	/// stream.<br/>
	/// @param userdata an opaque pointer provided to the callback for its own<br/>
	/// personal use.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information. This only fails if `stream` is NULL.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAudioStreamGetCallback
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAudioStreamPutCallback")]
	public static partial SDLBool SDL_SetAudioStreamPutCallback(SDL_AudioStream stream, delegate* unmanaged[Cdecl]<nint, SDL_AudioStream, int, int, void> callback, nint userdata);

	/// <summary>
	/// Free an audio stream.<br/>
	/// This will release all allocated data, including any audio that is still<br/>
	/// queued. You do not need to manually clear the stream first.<br/>
	/// If this stream was bound to an audio device, it is unbound during this<br/>
	/// call. If this stream was created with SDL_OpenAudioDeviceStream, the audio<br/>
	/// device that was opened alongside this stream's creation will be closed,<br/>
	/// too.<br/>
	/// <br/>
	/// @param stream the audio stream to destroy.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateAudioStream
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyAudioStream")]
	public static partial void SDL_DestroyAudioStream(SDL_AudioStream stream);

	/// <summary>
	/// Convenience function for straightforward audio init for the common case.<br/>
	/// If all your app intends to do is provide a single source of PCM audio, this<br/>
	/// function allows you to do all your audio setup in a single call.<br/>
	/// This is also intended to be a clean means to migrate apps from SDL2.<br/>
	/// This function will open an audio device, create a stream and bind it.<br/>
	/// Unlike other methods of setup, the audio device will be closed when this<br/>
	/// stream is destroyed, so the app can treat the returned SDL_AudioStream as<br/>
	/// the only object needed to manage audio playback.<br/>
	/// Also unlike other functions, the audio device begins paused. This is to map<br/>
	/// more closely to SDL2-style behavior, since there is no extra step here to<br/>
	/// bind a stream to begin audio flowing. The audio device should be resumed<br/>
	/// with `SDL_ResumeAudioStreamDevice(stream);`<br/>
	/// This function works with both playback and recording devices.<br/>
	/// The `spec` parameter represents the app's side of the audio stream. That<br/>
	/// is, for recording audio, this will be the output format, and for playing<br/>
	/// audio, this will be the input format. If spec is NULL, the system will<br/>
	/// choose the format, and the app can use SDL_GetAudioStreamFormat() to obtain<br/>
	/// this information later.<br/>
	/// If you don't care about opening a specific audio device, you can (and<br/>
	/// probably _should_), use SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK for playback and<br/>
	/// SDL_AUDIO_DEVICE_DEFAULT_RECORDING for recording.<br/>
	/// One can optionally provide a callback function; if NULL, the app is<br/>
	/// expected to queue audio data for playback (or unqueue audio data if<br/>
	/// capturing). Otherwise, the callback will begin to fire once the device is<br/>
	/// unpaused.<br/>
	/// Destroying the returned stream with SDL_DestroyAudioStream will also close<br/>
	/// the audio device associated with this stream.<br/>
	/// <br/>
	/// @param devid an audio device to open, or SDL_AUDIO_DEVICE_DEFAULT_PLAYBACK<br/>
	/// or SDL_AUDIO_DEVICE_DEFAULT_RECORDING.<br/>
	/// @param spec the audio stream's data format. Can be NULL.<br/>
	/// @param callback a callback where the app will provide new data for<br/>
	/// playback, or receive new data for recording. Can be NULL,<br/>
	/// in which case the app will need to call<br/>
	/// SDL_PutAudioStreamData or SDL_GetAudioStreamData as<br/>
	/// necessary.<br/>
	/// @param userdata app-controlled pointer passed to callback. Can be NULL.<br/>
	/// Ignored if callback is NULL.<br/>
	/// @returns an audio stream on success, ready to use, or NULL on failure; call<br/>
	/// SDL_GetError() for more information. When done with this stream,<br/>
	/// call SDL_DestroyAudioStream to free resources and close the<br/>
	/// device.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAudioStreamDevice<br/>
	/// @sa SDL_ResumeAudioStreamDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenAudioDeviceStream")]
	public static partial SDL_AudioStream SDL_OpenAudioDeviceStream(SDL_AudioDeviceID devid, SDL_AudioSpec* spec, delegate* unmanaged[Cdecl]<nint, SDL_AudioStream, int, int, void> callback, nint userdata);

	/// <summary>
	/// Set a callback that fires when data is about to be fed to an audio device.<br/>
	/// This is useful for accessing the final mix, perhaps for writing a<br/>
	/// visualizer or applying a final effect to the audio data before playback.<br/>
	/// The buffer is the final mix of all bound audio streams on an opened device;<br/>
	/// this callback will fire regularly for any device that is both opened and<br/>
	/// unpaused. If there is no new data to mix, either because no streams are<br/>
	/// bound to the device or all the streams are empty, this callback will still<br/>
	/// fire with the entire buffer set to silence.<br/>
	/// This callback is allowed to make changes to the data; the contents of the<br/>
	/// buffer after this call is what is ultimately passed along to the hardware.<br/>
	/// The callback is always provided the data in float format (values from -1.0f<br/>
	/// to 1.0f), but the number of channels or sample rate may be different than<br/>
	/// the format the app requested when opening the device; SDL might have had to<br/>
	/// manage a conversion behind the scenes, or the playback might have jumped to<br/>
	/// new physical hardware when a system default changed, etc. These details may<br/>
	/// change between calls. Accordingly, the size of the buffer might change<br/>
	/// between calls as well.<br/>
	/// This callback can run at any time, and from any thread; if you need to<br/>
	/// serialize access to your app's data, you should provide and use a mutex or<br/>
	/// other synchronization device.<br/>
	/// All of this to say: there are specific needs this callback can fulfill, but<br/>
	/// it is not the simplest interface. Apps should generally provide audio in<br/>
	/// their preferred format through an SDL_AudioStream and let SDL handle the<br/>
	/// difference.<br/>
	/// This function is extremely time-sensitive; the callback should do the least<br/>
	/// amount of work possible and return as quickly as it can. The longer the<br/>
	/// callback runs, the higher the risk of audio dropouts or other problems.<br/>
	/// This function will block until the audio device is in between iterations,<br/>
	/// so any existing callback that might be running will finish before this<br/>
	/// function sets the new callback and returns.<br/>
	/// Setting a NULL callback function disables any previously-set callback.<br/>
	/// <br/>
	/// @param devid the ID of an opened audio device.<br/>
	/// @param callback a callback function to be called. Can be NULL.<br/>
	/// @param userdata app-controlled pointer passed to callback. Can be NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAudioPostmixCallback")]
	public static partial SDLBool SDL_SetAudioPostmixCallback(SDL_AudioDeviceID devid, delegate* unmanaged[Cdecl]<nint, SDL_AudioSpec*, float*, int, void> callback, nint userdata);

	/// <summary>
	/// Load the audio data of a WAVE file into memory.<br/>
	/// Loading a WAVE file requires `src`, `spec`, `audio_buf` and `audio_len` to<br/>
	/// be valid pointers. The entire data portion of the file is then loaded into<br/>
	/// memory and decoded if necessary.<br/>
	/// Supported formats are RIFF WAVE files with the formats PCM (8, 16, 24, and<br/>
	/// 32 bits), IEEE Float (32 bits), Microsoft ADPCM and IMA ADPCM (4 bits), and<br/>
	/// A-law and mu-law (8 bits). Other formats are currently unsupported and<br/>
	/// cause an error.<br/>
	/// If this function succeeds, the return value is zero and the pointer to the<br/>
	/// audio data allocated by the function is written to `audio_buf` and its<br/>
	/// length in bytes to `audio_len`. The SDL_AudioSpec members `freq`,<br/>
	/// `channels`, and `format` are set to the values of the audio data in the<br/>
	/// buffer.<br/>
	/// It's necessary to use SDL_free() to free the audio data returned in<br/>
	/// `audio_buf` when it is no longer used.<br/>
	/// Because of the underspecification of the .WAV format, there are many<br/>
	/// problematic files in the wild that cause issues with strict decoders. To<br/>
	/// provide compatibility with these files, this decoder is lenient in regards<br/>
	/// to the truncation of the file, the fact chunk, and the size of the RIFF<br/>
	/// chunk. The hints `SDL_HINT_WAVE_RIFF_CHUNK_SIZE`,<br/>
	/// `SDL_HINT_WAVE_TRUNCATION`, and `SDL_HINT_WAVE_FACT_CHUNK` can be used to<br/>
	/// tune the behavior of the loading process.<br/>
	/// Any file that is invalid (due to truncation, corruption, or wrong values in<br/>
	/// the headers), too big, or unsupported causes an error. Additionally, any<br/>
	/// critical I/O error from the data source will terminate the loading process<br/>
	/// with an error. The function returns NULL on error and in all cases (with<br/>
	/// the exception of `src` being NULL), an appropriate error message will be<br/>
	/// set.<br/>
	/// It is required that the data source supports seeking.<br/>
	/// Example:<br/>
	/// ```c<br/>
	/// SDL_LoadWAV_IO(SDL_IOFromFile("sample.wav", "rb"), 1,<br/>
	/// &spec<br/>
	/// ,<br/>
	/// &buf<br/>
	/// ,<br/>
	/// &len<br/>
	/// );<br/>
	/// ```<br/>
	/// Note that the SDL_LoadWAV function does this same thing for you, but in a<br/>
	/// less messy way:<br/>
	/// ```c<br/>
	/// SDL_LoadWAV("sample.wav",<br/>
	/// &spec<br/>
	/// ,<br/>
	/// &buf<br/>
	/// ,<br/>
	/// &len<br/>
	/// );<br/>
	/// ```<br/>
	/// <br/>
	/// @param src the data source for the WAVE data.<br/>
	/// @param closeio if true, calls SDL_CloseIO() on `src` before returning, even<br/>
	/// in the case of an error.<br/>
	/// @param spec a pointer to an SDL_AudioSpec that will be set to the WAVE<br/>
	/// data's format details on successful return.<br/>
	/// @param audio_buf a pointer filled with the audio data, allocated by the<br/>
	/// function.<br/>
	/// @param audio_len a pointer filled with the length of the audio data buffer<br/>
	/// in bytes.<br/>
	/// @returns true on success. `audio_buf` will be filled with a pointer to an<br/>
	/// allocated buffer containing the audio data, and `audio_len` is<br/>
	/// filled with the length of that audio buffer in bytes.<br/>
	/// This function returns false if the .WAV file cannot be opened,<br/>
	/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// When the application is done with the data returned in<br/>
	/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_free<br/>
	/// @sa SDL_LoadWAV
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LoadWAV_IO")]
	public static partial SDLBool SDL_LoadWAV_IO(SDL_IOStream src, SDLBool closeio, SDL_AudioSpec* spec, byte** audio_buf, uint* audio_len);

	/// <summary>
	/// Loads a WAV from a file path.<br/>
	/// This is a convenience function that is effectively the same as:<br/>
	/// ```c<br/>
	/// SDL_LoadWAV_IO(SDL_IOFromFile(path, "rb"), true, spec, audio_buf, audio_len);<br/>
	/// ```<br/>
	/// <br/>
	/// @param path the file path of the WAV file to open.<br/>
	/// @param spec a pointer to an SDL_AudioSpec that will be set to the WAVE<br/>
	/// data's format details on successful return.<br/>
	/// @param audio_buf a pointer filled with the audio data, allocated by the<br/>
	/// function.<br/>
	/// @param audio_len a pointer filled with the length of the audio data buffer<br/>
	/// in bytes.<br/>
	/// @returns true on success. `audio_buf` will be filled with a pointer to an<br/>
	/// allocated buffer containing the audio data, and `audio_len` is<br/>
	/// filled with the length of that audio buffer in bytes.<br/>
	/// This function returns false if the .WAV file cannot be opened,<br/>
	/// uses an unknown data format, or is corrupt; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// When the application is done with the data returned in<br/>
	/// `audio_buf`, it should call SDL_free() to dispose of it.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_free<br/>
	/// @sa SDL_LoadWAV_IO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LoadWAV")]
	public static partial SDLBool SDL_LoadWAV(byte* path, SDL_AudioSpec* spec, byte** audio_buf, uint* audio_len);

	[LibraryImport(LibName, EntryPoint = "SDL_LoadWAV")]
	public static partial SDLBool SDL_LoadWAV(ReadOnlySpan<byte> path, SDL_AudioSpec* spec, byte** audio_buf, uint* audio_len);

	[LibraryImport(LibName, EntryPoint = "SDL_LoadWAV")]
	public static partial SDLBool SDL_LoadWAV([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, SDL_AudioSpec* spec, byte** audio_buf, uint* audio_len);

	/// <summary>
	/// Mix audio data in a specified format.<br/>
	/// This takes an audio buffer `src` of `len` bytes of `format` data and mixes<br/>
	/// it into `dst`, performing addition, volume adjustment, and overflow<br/>
	/// clipping. The buffer pointed to by `dst` must also be `len` bytes of<br/>
	/// `format` data.<br/>
	/// This is provided for convenience -- you can mix your own audio data.<br/>
	/// Do not use this function for mixing together more than two streams of<br/>
	/// sample data. The output from repeated application of this function may be<br/>
	/// distorted by clipping, because there is no accumulator with greater range<br/>
	/// than the input (not to mention this being an inefficient way of doing it).<br/>
	/// It is a common misconception that this function is required to write audio<br/>
	/// data to an output stream in an audio callback. While you can do that,<br/>
	/// SDL_MixAudio() is really only needed when you're mixing a single audio<br/>
	/// stream with a volume adjustment.<br/>
	/// <br/>
	/// @param dst the destination for the mixed audio.<br/>
	/// @param src the source audio buffer to be mixed.<br/>
	/// @param format the SDL_AudioFormat structure representing the desired audio<br/>
	/// format.<br/>
	/// @param len the length of the audio buffer in bytes.<br/>
	/// @param volume ranges from 0.0 - 1.0, and should be set to 1.0 for full<br/>
	/// audio volume.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_MixAudio")]
	public static partial SDLBool SDL_MixAudio(byte* dst, byte* src, SDL_AudioFormat format, uint len, float volume);

	/// <summary>
	/// Convert some audio data of one format to another format.<br/>
	/// Please note that this function is for convenience, but should not be used<br/>
	/// to resample audio in blocks, as it will introduce audio artifacts on the<br/>
	/// boundaries. You should only use this function if you are converting audio<br/>
	/// data in its entirety in one call. If you want to convert audio in smaller<br/>
	/// chunks, use an SDL_AudioStream, which is designed for this situation.<br/>
	/// Internally, this function creates and destroys an SDL_AudioStream on each<br/>
	/// use, so it's also less efficient than using one directly, if you need to<br/>
	/// convert multiple times.<br/>
	/// <br/>
	/// @param src_spec the format details of the input audio.<br/>
	/// @param src_data the audio data to be converted.<br/>
	/// @param src_len the len of src_data.<br/>
	/// @param dst_spec the format details of the output audio.<br/>
	/// @param dst_data will be filled with a pointer to converted audio data,<br/>
	/// which should be freed with SDL_free(). On error, it will be<br/>
	/// NULL.<br/>
	/// @param dst_len will be filled with the len of dst_data.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ConvertAudioSamples")]
	public static partial SDLBool SDL_ConvertAudioSamples(SDL_AudioSpec* src_spec, byte* src_data, int src_len, SDL_AudioSpec* dst_spec, byte** dst_data, int* dst_len);

	/// <summary>
	/// Get the human readable name of an audio format.<br/>
	/// <br/>
	/// @param format the audio format to query.<br/>
	/// @returns the human readable name of the specified audio format or<br/>
	/// "SDL_AUDIO_UNKNOWN" if the format isn't recognized.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAudioFormatName")]
	public static partial byte* SDL_GetAudioFormatNamePtr(SDL_AudioFormat format);

	public static string? SDL_GetAudioFormatName(SDL_AudioFormat format)
	{
		return ConvertToManaged(SDL_GetAudioFormatNamePtr(format));
	}

	/// <summary>
	/// Get the appropriate memset value for silencing an audio format.<br/>
	/// The value returned by this function can be used as the second argument to<br/>
	/// memset (or SDL_memset) to set an audio buffer in a specific format to<br/>
	/// silence.<br/>
	/// <br/>
	/// @param format the audio data format to query.<br/>
	/// @returns a byte value that can be passed to memset.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSilenceValueForFormat")]
	public static partial int SDL_GetSilenceValueForFormat(SDL_AudioFormat format);

	/// <summary>
	/// Compose a custom blend mode for renderers.<br/>
	/// The functions SDL_SetRenderDrawBlendMode and SDL_SetTextureBlendMode accept<br/>
	/// the SDL_BlendMode returned by this function if the renderer supports it.<br/>
	/// A blend mode controls how the pixels from a drawing operation (source) get<br/>
	/// combined with the pixels from the render target (destination). First, the<br/>
	/// components of the source and destination pixels get multiplied with their<br/>
	/// blend factors. Then, the blend operation takes the two products and<br/>
	/// calculates the result that will get stored in the render target.<br/>
	/// Expressed in pseudocode, it would look like this:<br/>
	/// ```c<br/>
	/// dstRGB = colorOperation(srcRGB * srcColorFactor, dstRGB * dstColorFactor);<br/>
	/// dstA = alphaOperation(srcA * srcAlphaFactor, dstA * dstAlphaFactor);<br/>
	/// ```<br/>
	/// Where the functions `colorOperation(src, dst)` and `alphaOperation(src,<br/>
	/// dst)` can return one of the following:<br/>
	/// - `src + dst`<br/>
	/// - `src - dst`<br/>
	/// - `dst - src`<br/>
	/// - `min(src, dst)`<br/>
	/// - `max(src, dst)`<br/>
	/// The red, green, and blue components are always multiplied with the first,<br/>
	/// second, and third components of the SDL_BlendFactor, respectively. The<br/>
	/// fourth component is not used.<br/>
	/// The alpha component is always multiplied with the fourth component of the<br/>
	/// SDL_BlendFactor. The other components are not used in the alpha<br/>
	/// calculation.<br/>
	/// Support for these blend modes varies for each renderer. To check if a<br/>
	/// specific SDL_BlendMode is supported, create a renderer and pass it to<br/>
	/// either SDL_SetRenderDrawBlendMode or SDL_SetTextureBlendMode. They will<br/>
	/// return with an error if the blend mode is not supported.<br/>
	/// This list describes the support of custom blend modes for each renderer.<br/>
	/// All renderers support the four blend modes listed in the SDL_BlendMode<br/>
	/// enumeration.<br/>
	/// - **direct3d**: Supports all operations with all factors. However, some<br/>
	/// factors produce unexpected results with `SDL_BLENDOPERATION_MINIMUM` and<br/>
	/// `SDL_BLENDOPERATION_MAXIMUM`.<br/>
	/// - **direct3d11**: Same as Direct3D 9.<br/>
	/// - **opengl**: Supports the `SDL_BLENDOPERATION_ADD` operation with all<br/>
	/// factors. OpenGL versions 1.1, 1.2, and 1.3 do not work correctly here.<br/>
	/// - **opengles2**: Supports the `SDL_BLENDOPERATION_ADD`,<br/>
	/// `SDL_BLENDOPERATION_SUBTRACT`, `SDL_BLENDOPERATION_REV_SUBTRACT`<br/>
	/// operations with all factors.<br/>
	/// - **psp**: No custom blend mode support.<br/>
	/// - **software**: No custom blend mode support.<br/>
	/// Some renderers do not provide an alpha component for the default render<br/>
	/// target. The `SDL_BLENDFACTOR_DST_ALPHA` and<br/>
	/// `SDL_BLENDFACTOR_ONE_MINUS_DST_ALPHA` factors do not have an effect in this<br/>
	/// case.<br/>
	/// <br/>
	/// @param srcColorFactor the SDL_BlendFactor applied to the red, green, and<br/>
	/// blue components of the source pixels.<br/>
	/// @param dstColorFactor the SDL_BlendFactor applied to the red, green, and<br/>
	/// blue components of the destination pixels.<br/>
	/// @param colorOperation the SDL_BlendOperation used to combine the red,<br/>
	/// green, and blue components of the source and<br/>
	/// destination pixels.<br/>
	/// @param srcAlphaFactor the SDL_BlendFactor applied to the alpha component of<br/>
	/// the source pixels.<br/>
	/// @param dstAlphaFactor the SDL_BlendFactor applied to the alpha component of<br/>
	/// the destination pixels.<br/>
	/// @param alphaOperation the SDL_BlendOperation used to combine the alpha<br/>
	/// component of the source and destination pixels.<br/>
	/// @returns an SDL_BlendMode that represents the chosen factors and<br/>
	/// operations.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderDrawBlendMode<br/>
	/// @sa SDL_GetRenderDrawBlendMode<br/>
	/// @sa SDL_SetTextureBlendMode<br/>
	/// @sa SDL_GetTextureBlendMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ComposeCustomBlendMode")]
	public static partial SDL_BlendMode SDL_ComposeCustomBlendMode(SDL_BlendFactor srcColorFactor, SDL_BlendFactor dstColorFactor, SDL_BlendOperation colorOperation, SDL_BlendFactor srcAlphaFactor, SDL_BlendFactor dstAlphaFactor, SDL_BlendOperation alphaOperation);

	/// <summary>
	/// Use this function to get the number of built-in camera drivers.<br/>
	/// This function returns a hardcoded number. This never returns a negative<br/>
	/// value; if there are no drivers compiled into this build of SDL, this<br/>
	/// function returns zero. The presence of a driver in this list does not mean<br/>
	/// it will function, it just means SDL is capable of interacting with that<br/>
	/// interface. For example, a build of SDL might have v4l2 support, but if<br/>
	/// there's no kernel support available, SDL's v4l2 driver would fail if used.<br/>
	/// By default, SDL tries all drivers, in its preferred order, until one is<br/>
	/// found to be usable.<br/>
	/// <br/>
	/// @returns the number of built-in camera drivers.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetCameraDriver
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumCameraDrivers")]
	public static partial int SDL_GetNumCameraDrivers();

	/// <summary>
	/// Use this function to get the name of a built in camera driver.<br/>
	/// The list of camera drivers is given in the order that they are normally<br/>
	/// initialized by default; the drivers that seem more reasonable to choose<br/>
	/// first (as far as the SDL developers believe) are earlier in the list.<br/>
	/// The names of drivers are all simple, low-ASCII identifiers, like "v4l2",<br/>
	/// "coremedia" or "android". These never have Unicode characters, and are not<br/>
	/// meant to be proper names.<br/>
	/// <br/>
	/// @param index the index of the camera driver; the value ranges from 0 to<br/>
	/// SDL_GetNumCameraDrivers() - 1.<br/>
	/// @returns the name of the camera driver at the requested index, or NULL if<br/>
	/// an invalid index was specified.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumCameraDrivers
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCameraDriver")]
	public static partial byte* SDL_GetCameraDriverPtr(int index);

	public static string? SDL_GetCameraDriver(int index)
	{
		return ConvertToManaged(SDL_GetCameraDriverPtr(index));
	}

	/// <summary>
	/// Get the name of the current camera driver.<br/>
	/// The names of drivers are all simple, low-ASCII identifiers, like "v4l2",<br/>
	/// "coremedia" or "android". These never have Unicode characters, and are not<br/>
	/// meant to be proper names.<br/>
	/// <br/>
	/// @returns the name of the current camera driver or NULL if no driver has<br/>
	/// been initialized.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentCameraDriver")]
	public static partial byte* SDL_GetCurrentCameraDriverPtr();

	public static string? SDL_GetCurrentCameraDriver()
	{
		return ConvertToManaged(SDL_GetCurrentCameraDriverPtr());
	}

	/// <summary>
	/// Get a list of currently connected camera devices.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of cameras returned, may<br/>
	/// be NULL.<br/>
	/// @returns a 0 terminated array of camera instance IDs or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This should be freed<br/>
	/// with SDL_free() when it is no longer needed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenCamera
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCameras")]
	public static partial SDL_CameraID* SDL_GetCameras(out int count);

	/// <summary>
	/// Get the list of native formats/sizes a camera supports.<br/>
	/// This returns a list of all formats and frame sizes that a specific camera<br/>
	/// can offer. This is useful if your app can accept a variety of image formats<br/>
	/// and sizes and so want to find the optimal spec that doesn't require<br/>
	/// conversion.<br/>
	/// This function isn't strictly required; if you call SDL_OpenCamera with a<br/>
	/// NULL spec, SDL will choose a native format for you, and if you instead<br/>
	/// specify a desired format, it will transparently convert to the requested<br/>
	/// format on your behalf.<br/>
	/// If `count` is not NULL, it will be filled with the number of elements in<br/>
	/// the returned array.<br/>
	/// Note that it's legal for a camera to supply an empty list. This is what<br/>
	/// will happen on Emscripten builds, since that platform won't tell _anything_<br/>
	/// about available cameras until you've opened one, and won't even tell if<br/>
	/// there _is_ a camera until the user has given you permission to check<br/>
	/// through a scary warning popup.<br/>
	/// <br/>
	/// @param devid the camera device instance ID to query.<br/>
	/// @param count a pointer filled in with the number of elements in the list,<br/>
	/// may be NULL.<br/>
	/// @returns a NULL terminated array of pointers to SDL_CameraSpec or NULL on<br/>
	/// failure; call SDL_GetError() for more information. This is a<br/>
	/// single allocation that should be freed with SDL_free() when it is<br/>
	/// no longer needed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetCameras<br/>
	/// @sa SDL_OpenCamera
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCameraSupportedFormats")]
	public static partial SDL_CameraSpec** SDL_GetCameraSupportedFormats(SDL_CameraID devid, out int count);

	/// <summary>
	/// Get the human-readable device name for a camera.<br/>
	/// <br/>
	/// @param instance_id the camera device instance ID.<br/>
	/// @returns a human-readable device name or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetCameras
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCameraName")]
	public static partial byte* SDL_GetCameraNamePtr(SDL_CameraID instance_id);

	public static string? SDL_GetCameraName(SDL_CameraID instance_id)
	{
		return ConvertToManaged(SDL_GetCameraNamePtr(instance_id));
	}

	/// <summary>
	/// Get the position of the camera in relation to the system.<br/>
	/// Most platforms will report UNKNOWN, but mobile devices, like phones, can<br/>
	/// often make a distinction between cameras on the front of the device (that<br/>
	/// points towards the user, for taking "selfies") and cameras on the back (for<br/>
	/// filming in the direction the user is facing).<br/>
	/// <br/>
	/// @param instance_id the camera device instance ID.<br/>
	/// @returns the position of the camera on the system hardware.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetCameras
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCameraPosition")]
	public static partial SDL_CameraPosition SDL_GetCameraPosition(SDL_CameraID instance_id);

	/// <summary>
	/// Open a video recording device (a "camera").<br/>
	/// You can open the device with any reasonable spec, and if the hardware can't<br/>
	/// directly support it, it will convert data seamlessly to the requested<br/>
	/// format. This might incur overhead, including scaling of image data.<br/>
	/// If you would rather accept whatever format the device offers, you can pass<br/>
	/// a NULL spec here and it will choose one for you (and you can use<br/>
	/// SDL_Surface's conversion/scaling functions directly if necessary).<br/>
	/// You can call SDL_GetCameraFormat() to get the actual data format if passing<br/>
	/// a NULL spec here. You can see the exact specs a device can support without<br/>
	/// conversion with SDL_GetCameraSupportedSpecs().<br/>
	/// SDL will not attempt to emulate framerate; it will try to set the hardware<br/>
	/// to the rate closest to the requested speed, but it won't attempt to limit<br/>
	/// or duplicate frames artificially; call SDL_GetCameraFormat() to see the<br/>
	/// actual framerate of the opened the device, and check your timestamps if<br/>
	/// this is crucial to your app!<br/>
	/// Note that the camera is not usable until the user approves its use! On some<br/>
	/// platforms, the operating system will prompt the user to permit access to<br/>
	/// the camera, and they can choose Yes or No at that point. Until they do, the<br/>
	/// camera will not be usable. The app should either wait for an<br/>
	/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,<br/>
	/// or poll SDL_IsCameraApproved() occasionally until it returns non-zero. On<br/>
	/// platforms that don't require explicit user approval (and perhaps in places<br/>
	/// where the user previously permitted access), the approval event might come<br/>
	/// immediately, but it might come seconds, minutes, or hours later!<br/>
	/// <br/>
	/// @param instance_id the camera device instance ID.<br/>
	/// @param spec the desired format for data the device will provide. Can be<br/>
	/// NULL.<br/>
	/// @returns an SDL_Camera object or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetCameras<br/>
	/// @sa SDL_GetCameraFormat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenCamera")]
	public static partial SDL_Camera SDL_OpenCamera(SDL_CameraID instance_id, SDL_CameraSpec* spec);

	/// <summary>
	/// Query if camera access has been approved by the user.<br/>
	/// Cameras will not function between when the device is opened by the app and<br/>
	/// when the user permits access to the hardware. On some platforms, this<br/>
	/// presents as a popup dialog where the user has to explicitly approve access;<br/>
	/// on others the approval might be implicit and not alert the user at all.<br/>
	/// This function can be used to check the status of that approval. It will<br/>
	/// return 0 if still waiting for user response, 1 if the camera is approved<br/>
	/// for use, and -1 if the user denied access.<br/>
	/// Instead of polling with this function, you can wait for a<br/>
	/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event<br/>
	/// in the standard SDL event loop, which is guaranteed to be sent once when<br/>
	/// permission to use the camera is decided.<br/>
	/// If a camera is declined, there's nothing to be done but call<br/>
	/// SDL_CloseCamera() to dispose of it.<br/>
	/// <br/>
	/// @param camera the opened camera device to query.<br/>
	/// @returns -1 if user denied access to the camera, 1 if user approved access,<br/>
	/// 0 if no decision has been made yet.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenCamera<br/>
	/// @sa SDL_CloseCamera
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCameraPermissionState")]
	public static partial int SDL_GetCameraPermissionState(SDL_Camera camera);

	/// <summary>
	/// Get the instance ID of an opened camera.<br/>
	/// <br/>
	/// @param camera an SDL_Camera to query.<br/>
	/// @returns the instance ID of the specified camera on success or 0 on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenCamera
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCameraID")]
	public static partial SDL_CameraID SDL_GetCameraID(SDL_Camera camera);

	/// <summary>
	/// Get the properties associated with an opened camera.<br/>
	/// <br/>
	/// @param camera the SDL_Camera obtained from SDL_OpenCamera().<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCameraProperties")]
	public static partial SDL_PropertiesID SDL_GetCameraProperties(SDL_Camera camera);

	/// <summary>
	/// Get the spec that a camera is using when generating images.<br/>
	/// Note that this might not be the native format of the hardware, as SDL might<br/>
	/// be converting to this format behind the scenes.<br/>
	/// If the system is waiting for the user to approve access to the camera, as<br/>
	/// some platforms require, this will return false, but this isn't necessarily<br/>
	/// a fatal error; you should either wait for an<br/>
	/// SDL_EVENT_CAMERA_DEVICE_APPROVED (or SDL_EVENT_CAMERA_DEVICE_DENIED) event,<br/>
	/// or poll SDL_IsCameraApproved() occasionally until it returns non-zero.<br/>
	/// <br/>
	/// @param camera opened camera device.<br/>
	/// @param spec the SDL_CameraSpec to be initialized by this function.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenCamera
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCameraFormat")]
	public static partial SDLBool SDL_GetCameraFormat(SDL_Camera camera, SDL_CameraSpec* spec);

	/// <summary>
	/// Acquire a frame.<br/>
	/// The frame is a memory pointer to the image data, whose size and format are<br/>
	/// given by the spec requested when opening the device.<br/>
	/// This is a non blocking API. If there is a frame available, a non-NULL<br/>
	/// surface is returned, and timestampNS will be filled with a non-zero value.<br/>
	/// Note that an error case can also return NULL, but a NULL by itself is<br/>
	/// normal and just signifies that a new frame is not yet available. Note that<br/>
	/// even if a camera device fails outright (a USB camera is unplugged while in<br/>
	/// use, etc), SDL will send an event separately to notify the app, but<br/>
	/// continue to provide blank frames at ongoing intervals until<br/>
	/// SDL_CloseCamera() is called, so real failure here is almost always an out<br/>
	/// of memory condition.<br/>
	/// After use, the frame should be released with SDL_ReleaseCameraFrame(). If<br/>
	/// you don't do this, the system may stop providing more video!<br/>
	/// Do not call SDL_FreeSurface() on the returned surface! It must be given<br/>
	/// back to the camera subsystem with SDL_ReleaseCameraFrame!<br/>
	/// If the system is waiting for the user to approve access to the camera, as<br/>
	/// some platforms require, this will return NULL (no frames available); you<br/>
	/// should either wait for an SDL_EVENT_CAMERA_DEVICE_APPROVED (or<br/>
	/// SDL_EVENT_CAMERA_DEVICE_DENIED) event, or poll SDL_IsCameraApproved()<br/>
	/// occasionally until it returns non-zero.<br/>
	/// <br/>
	/// @param camera opened camera device.<br/>
	/// @param timestampNS a pointer filled in with the frame's timestamp, or 0 on<br/>
	/// error. Can be NULL.<br/>
	/// @returns a new frame of video on success, NULL if none is currently<br/>
	/// available.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ReleaseCameraFrame
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AcquireCameraFrame")]
	public static partial SDL_Surface* SDL_AcquireCameraFrame(SDL_Camera camera, ulong* timestampNS);

	/// <summary>
	/// Release a frame of video acquired from a camera.<br/>
	/// Let the back-end re-use the internal buffer for camera.<br/>
	/// This function _must_ be called only on surface objects returned by<br/>
	/// SDL_AcquireCameraFrame(). This function should be called as quickly as<br/>
	/// possible after acquisition, as SDL keeps a small FIFO queue of surfaces for<br/>
	/// video frames; if surfaces aren't released in a timely manner, SDL may drop<br/>
	/// upcoming video frames from the camera.<br/>
	/// If the app needs to keep the surface for a significant time, they should<br/>
	/// make a copy of it and release the original.<br/>
	/// The app should not use the surface again after calling this function;<br/>
	/// assume the surface is freed and the pointer is invalid.<br/>
	/// <br/>
	/// @param camera opened camera device.<br/>
	/// @param frame the video frame surface to release.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AcquireCameraFrame
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReleaseCameraFrame")]
	public static partial void SDL_ReleaseCameraFrame(SDL_Camera camera, SDL_Surface* frame);

	/// <summary>
	/// Use this function to shut down camera processing and close the camera<br/>
	/// device.<br/>
	/// <br/>
	/// @param camera opened camera device.<br/>
	/// @threadsafety It is safe to call this function from any thread, but no<br/>
	/// thread may reference `device` once this function is called.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenCameraWithSpec<br/>
	/// @sa SDL_OpenCamera
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CloseCamera")]
	public static partial void SDL_CloseCamera(SDL_Camera camera);

	/// <summary>
	/// Put UTF-8 text into the clipboard.<br/>
	/// <br/>
	/// @param text the text to store in the clipboard.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetClipboardText<br/>
	/// @sa SDL_HasClipboardText
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetClipboardText")]
	public static partial SDLBool SDL_SetClipboardText(byte* text);

	[LibraryImport(LibName, EntryPoint = "SDL_SetClipboardText")]
	public static partial SDLBool SDL_SetClipboardText(ReadOnlySpan<byte> text);

	[LibraryImport(LibName, EntryPoint = "SDL_SetClipboardText")]
	public static partial SDLBool SDL_SetClipboardText([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> text);

	/// <summary>
	/// Get UTF-8 text from the clipboard.<br/>
	/// This functions returns empty string if there was not enough memory left for<br/>
	/// a copy of the clipboard's content.<br/>
	/// <br/>
	/// @returns the clipboard text on success or an empty string on failure; call<br/>
	/// SDL_GetError() for more information. This should be freed with<br/>
	/// SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasClipboardText<br/>
	/// @sa SDL_SetClipboardText
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetClipboardText")]
	public static partial byte* SDL_GetClipboardTextPtr();

	public static string? SDL_GetClipboardText()
	{
		byte* resultPtr = SDL_GetClipboardTextPtr();
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	/// <summary>
	/// Query whether the clipboard exists and contains a non-empty text string.<br/>
	/// <br/>
	/// @returns true if the clipboard has text, or false if it does not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetClipboardText<br/>
	/// @sa SDL_SetClipboardText
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasClipboardText")]
	public static partial SDLBool SDL_HasClipboardText();

	/// <summary>
	/// Put UTF-8 text into the primary selection.<br/>
	/// <br/>
	/// @param text the text to store in the primary selection.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPrimarySelectionText<br/>
	/// @sa SDL_HasPrimarySelectionText
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetPrimarySelectionText")]
	public static partial SDLBool SDL_SetPrimarySelectionText(byte* text);

	[LibraryImport(LibName, EntryPoint = "SDL_SetPrimarySelectionText")]
	public static partial SDLBool SDL_SetPrimarySelectionText(ReadOnlySpan<byte> text);

	[LibraryImport(LibName, EntryPoint = "SDL_SetPrimarySelectionText")]
	public static partial SDLBool SDL_SetPrimarySelectionText([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> text);

	/// <summary>
	/// Get UTF-8 text from the primary selection.<br/>
	/// This functions returns empty string if there was not enough memory left for<br/>
	/// a copy of the primary selection's content.<br/>
	/// <br/>
	/// @returns the primary selection text on success or an empty string on<br/>
	/// failure; call SDL_GetError() for more information. This should be<br/>
	/// freed with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasPrimarySelectionText<br/>
	/// @sa SDL_SetPrimarySelectionText
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPrimarySelectionText")]
	public static partial byte* SDL_GetPrimarySelectionTextPtr();

	public static string? SDL_GetPrimarySelectionText()
	{
		byte* resultPtr = SDL_GetPrimarySelectionTextPtr();
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	/// <summary>
	/// Query whether the primary selection exists and contains a non-empty text<br/>
	/// string.<br/>
	/// <br/>
	/// @returns true if the primary selection has text, or false if it does not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPrimarySelectionText<br/>
	/// @sa SDL_SetPrimarySelectionText
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasPrimarySelectionText")]
	public static partial SDLBool SDL_HasPrimarySelectionText();

	/// <summary>
	/// Offer clipboard data to the OS.<br/>
	/// Tell the operating system that the application is offering clipboard data<br/>
	/// for each of the proivded mime-types. Once another application requests the<br/>
	/// data the callback function will be called allowing it to generate and<br/>
	/// respond with the data for the requested mime-type.<br/>
	/// The size of text data does not include any terminator, and the text does<br/>
	/// not need to be null terminated (e.g. you can directly copy a portion of a<br/>
	/// document)<br/>
	/// <br/>
	/// @param callback a function pointer to the function that provides the<br/>
	/// clipboard data.<br/>
	/// @param cleanup a function pointer to the function that cleans up the<br/>
	/// clipboard data.<br/>
	/// @param userdata an opaque pointer that will be forwarded to the callbacks.<br/>
	/// @param mime_types a list of mime-types that are being offered.<br/>
	/// @param num_mime_types the number of mime-types in the mime_types list.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ClearClipboardData<br/>
	/// @sa SDL_GetClipboardData<br/>
	/// @sa SDL_HasClipboardData
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetClipboardData")]
	public static partial SDLBool SDL_SetClipboardData(delegate* unmanaged[Cdecl]<nint, byte*, nuint*, nint> callback, delegate* unmanaged[Cdecl]<nint, void> cleanup, nint userdata, byte** mime_types, nuint num_mime_types);

	/// <summary>
	/// Clear the clipboard data.<br/>
	/// <br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetClipboardData
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ClearClipboardData")]
	public static partial SDLBool SDL_ClearClipboardData();

	/// <summary>
	/// Get the data from clipboard for a given mime type.<br/>
	/// The size of text data does not include the terminator, but the text is<br/>
	/// guaranteed to be null terminated.<br/>
	/// <br/>
	/// @param mime_type the mime type to read from the clipboard.<br/>
	/// @param size a pointer filled in with the length of the returned data.<br/>
	/// @returns the retrieved data buffer or NULL on failure; call SDL_GetError()<br/>
	/// for more information. This should be freed with SDL_free() when it<br/>
	/// is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasClipboardData<br/>
	/// @sa SDL_SetClipboardData
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetClipboardData")]
	public static partial nint SDL_GetClipboardData(byte* mime_type, nuint* size);

	[LibraryImport(LibName, EntryPoint = "SDL_GetClipboardData")]
	public static partial nint SDL_GetClipboardData(ReadOnlySpan<byte> mime_type, nuint* size);

	[LibraryImport(LibName, EntryPoint = "SDL_GetClipboardData")]
	public static partial nint SDL_GetClipboardData([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> mime_type, nuint* size);

	/// <summary>
	/// Query whether there is data in the clipboard for the provided mime type.<br/>
	/// <br/>
	/// @param mime_type the mime type to check for data for.<br/>
	/// @returns true if there exists data in clipboard for the provided mime type,<br/>
	/// false if it does not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetClipboardData<br/>
	/// @sa SDL_GetClipboardData
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasClipboardData")]
	public static partial SDLBool SDL_HasClipboardData(byte* mime_type);

	[LibraryImport(LibName, EntryPoint = "SDL_HasClipboardData")]
	public static partial SDLBool SDL_HasClipboardData(ReadOnlySpan<byte> mime_type);

	[LibraryImport(LibName, EntryPoint = "SDL_HasClipboardData")]
	public static partial SDLBool SDL_HasClipboardData([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> mime_type);

	/// <summary>
	/// Retrieve the list of mime types available in the clipboard.<br/>
	/// <br/>
	/// @param num_mime_types a pointer filled with the number of mime types, may<br/>
	/// be NULL.<br/>
	/// @returns a null terminated array of strings with mime types, or NULL on<br/>
	/// failure; call SDL_GetError() for more information. This should be<br/>
	/// freed with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetClipboardData
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetClipboardMimeTypes")]
	public static partial byte** SDL_GetClipboardMimeTypes(nuint* num_mime_types);

	/// <summary>
	/// Get the number of logical CPU cores available.<br/>
	/// <br/>
	/// @returns the total number of logical CPU cores. On CPUs that include<br/>
	/// technologies such as hyperthreading, the number of logical cores<br/>
	/// may be more than the number of physical cores.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumLogicalCPUCores")]
	public static partial int SDL_GetNumLogicalCPUCores();

	/// <summary>
	/// Determine the L1 cache line size of the CPU.<br/>
	/// This is useful for determining multi-threaded structure padding or SIMD<br/>
	/// prefetch sizes.<br/>
	/// <br/>
	/// @returns the L1 cache line size of the CPU, in bytes.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCPUCacheLineSize")]
	public static partial int SDL_GetCPUCacheLineSize();

	/// <summary>
	/// Determine whether the CPU has AltiVec features.<br/>
	/// This always returns false on CPUs that aren't using PowerPC instruction<br/>
	/// sets.<br/>
	/// <br/>
	/// @returns true if the CPU has AltiVec features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasAltiVec")]
	public static partial SDLBool SDL_HasAltiVec();

	/// <summary>
	/// Determine whether the CPU has MMX features.<br/>
	/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has MMX features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasMMX")]
	public static partial SDLBool SDL_HasMMX();

	/// <summary>
	/// Determine whether the CPU has SSE features.<br/>
	/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has SSE features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasSSE2<br/>
	/// @sa SDL_HasSSE3<br/>
	/// @sa SDL_HasSSE41<br/>
	/// @sa SDL_HasSSE42
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasSSE")]
	public static partial SDLBool SDL_HasSSE();

	/// <summary>
	/// Determine whether the CPU has SSE2 features.<br/>
	/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has SSE2 features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasSSE<br/>
	/// @sa SDL_HasSSE3<br/>
	/// @sa SDL_HasSSE41<br/>
	/// @sa SDL_HasSSE42
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasSSE2")]
	public static partial SDLBool SDL_HasSSE2();

	/// <summary>
	/// Determine whether the CPU has SSE3 features.<br/>
	/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has SSE3 features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasSSE<br/>
	/// @sa SDL_HasSSE2<br/>
	/// @sa SDL_HasSSE41<br/>
	/// @sa SDL_HasSSE42
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasSSE3")]
	public static partial SDLBool SDL_HasSSE3();

	/// <summary>
	/// Determine whether the CPU has SSE4.1 features.<br/>
	/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has SSE4.1 features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasSSE<br/>
	/// @sa SDL_HasSSE2<br/>
	/// @sa SDL_HasSSE3<br/>
	/// @sa SDL_HasSSE42
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasSSE41")]
	public static partial SDLBool SDL_HasSSE41();

	/// <summary>
	/// Determine whether the CPU has SSE4.2 features.<br/>
	/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has SSE4.2 features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasSSE<br/>
	/// @sa SDL_HasSSE2<br/>
	/// @sa SDL_HasSSE3<br/>
	/// @sa SDL_HasSSE41
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasSSE42")]
	public static partial SDLBool SDL_HasSSE42();

	/// <summary>
	/// Determine whether the CPU has AVX features.<br/>
	/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has AVX features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasAVX2<br/>
	/// @sa SDL_HasAVX512F
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasAVX")]
	public static partial SDLBool SDL_HasAVX();

	/// <summary>
	/// Determine whether the CPU has AVX2 features.<br/>
	/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has AVX2 features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasAVX<br/>
	/// @sa SDL_HasAVX512F
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasAVX2")]
	public static partial SDLBool SDL_HasAVX2();

	/// <summary>
	/// Determine whether the CPU has AVX-512F (foundation) features.<br/>
	/// This always returns false on CPUs that aren't using Intel instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has AVX-512F features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasAVX<br/>
	/// @sa SDL_HasAVX2
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasAVX512F")]
	public static partial SDLBool SDL_HasAVX512F();

	/// <summary>
	/// Determine whether the CPU has ARM SIMD (ARMv6) features.<br/>
	/// This is different from ARM NEON, which is a different instruction set.<br/>
	/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has ARM SIMD features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasNEON
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasARMSIMD")]
	public static partial SDLBool SDL_HasARMSIMD();

	/// <summary>
	/// Determine whether the CPU has NEON (ARM SIMD) features.<br/>
	/// This always returns false on CPUs that aren't using ARM instruction sets.<br/>
	/// <br/>
	/// @returns true if the CPU has ARM NEON features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasNEON")]
	public static partial SDLBool SDL_HasNEON();

	/// <summary>
	/// Determine whether the CPU has LSX (LOONGARCH SIMD) features.<br/>
	/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
	/// sets.<br/>
	/// <br/>
	/// @returns true if the CPU has LOONGARCH LSX features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasLSX")]
	public static partial SDLBool SDL_HasLSX();

	/// <summary>
	/// Determine whether the CPU has LASX (LOONGARCH SIMD) features.<br/>
	/// This always returns false on CPUs that aren't using LOONGARCH instruction<br/>
	/// sets.<br/>
	/// <br/>
	/// @returns true if the CPU has LOONGARCH LASX features or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasLASX")]
	public static partial SDLBool SDL_HasLASX();

	/// <summary>
	/// Get the amount of RAM configured in the system.<br/>
	/// <br/>
	/// @returns the amount of RAM configured in the system in MiB.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSystemRAM")]
	public static partial int SDL_GetSystemRAM();

	/// <summary>
	/// Report the alignment this system needs for SIMD allocations.<br/>
	/// This will return the minimum number of bytes to which a pointer must be<br/>
	/// aligned to be compatible with SIMD instructions on the current machine. For<br/>
	/// example, if the machine supports SSE only, it will return 16, but if it<br/>
	/// supports AVX-512F, it'll return 64 (etc). This only reports values for<br/>
	/// instruction sets SDL knows about, so if your SDL build doesn't have<br/>
	/// SDL_HasAVX512F(), then it might return 16 for the SSE support it sees and<br/>
	/// not 64 for the AVX-512 instructions that exist but SDL doesn't know about.<br/>
	/// Plan accordingly.<br/>
	/// <br/>
	/// @returns the alignment in bytes needed for available, known SIMD<br/>
	/// instructions.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_aligned_alloc<br/>
	/// @sa SDL_aligned_free
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSIMDAlignment")]
	public static partial nuint SDL_GetSIMDAlignment();

	/// <summary>
	/// Displays a dialog that lets the user select a file on their filesystem.<br/>
	/// This function should only be invoked from the main thread.<br/>
	/// This is an asynchronous function; it will return immediately, and the<br/>
	/// result will be passed to the callback.<br/>
	/// The callback will be invoked with a null-terminated list of files the user<br/>
	/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
	/// be NULL if an error occurred.<br/>
	/// Note that the callback may be called from a different thread than the one<br/>
	/// the function was invoked on.<br/>
	/// Depending on the platform, the user may be allowed to input paths that<br/>
	/// don't yet exist.<br/>
	/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
	/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
	/// should add a call to SDL_PumpEvents in their main loop.<br/>
	/// <br/>
	/// @param callback an SDL_DialogFileCallback to be invoked when the user<br/>
	/// selects a file and accepts, or cancels the dialog, or an<br/>
	/// error occurs. The first argument is a null-terminated list<br/>
	/// of C strings, representing the paths chosen by the user.<br/>
	/// The list will be empty if the user canceled the dialog, and<br/>
	/// it will be NULL if an error occurred. If an error occurred,<br/>
	/// it can be fetched with SDL_GetError(). The second argument<br/>
	/// is the userdata pointer passed to the function. The third<br/>
	/// argument is the index of the filter selected by the user,<br/>
	/// or one past the index of the last filter (therefore the<br/>
	/// index of the terminating NULL filter) if no filter was<br/>
	/// chosen, or -1 if the platform does not support detecting<br/>
	/// the selected filter.<br/>
	/// @param userdata an optional pointer to pass extra data to the callback when<br/>
	/// it will be invoked.<br/>
	/// @param window the window that the dialog should be modal for, may be NULL.<br/>
	/// Not all platforms support this option.<br/>
	/// @param filters a list of SDL_DialogFileFilter's, may be NULL. Not all<br/>
	/// platforms support this option, and platforms that do support<br/>
	/// it may allow the user to ignore the filters.<br/>
	/// @param nfilters the number of filters. Ignored if filters is NULL.<br/>
	/// @param default_location the default folder or file to start the dialog at,<br/>
	/// may be NULL. Not all platforms support this option.<br/>
	/// @param allow_many if non-zero, the user will be allowed to select multiple<br/>
	/// entries. Not all platforms support this option.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DialogFileCallback<br/>
	/// @sa SDL_DialogFileFilter<br/>
	/// @sa SDL_ShowSaveFileDialog<br/>
	/// @sa SDL_ShowOpenFolderDialog
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShowOpenFileDialog")]
	public static partial void SDL_ShowOpenFileDialog(delegate* unmanaged[Cdecl]<nint, byte**, int, void> callback, nint userdata, SDL_Window window, SDL_DialogFileFilter* filters, int nfilters, byte* default_location, SDLBool allow_many);

	[LibraryImport(LibName, EntryPoint = "SDL_ShowOpenFileDialog")]
	public static partial void SDL_ShowOpenFileDialog(delegate* unmanaged[Cdecl]<nint, byte**, int, void> callback, nint userdata, SDL_Window window, SDL_DialogFileFilter* filters, int nfilters, ReadOnlySpan<byte> default_location, SDLBool allow_many);

	[LibraryImport(LibName, EntryPoint = "SDL_ShowOpenFileDialog")]
	public static partial void SDL_ShowOpenFileDialog(delegate* unmanaged[Cdecl]<nint, byte**, int, void> callback, nint userdata, SDL_Window window, SDL_DialogFileFilter* filters, int nfilters, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> default_location, SDLBool allow_many);

	/// <summary>
	/// Displays a dialog that lets the user choose a new or existing file on their<br/>
	/// filesystem.<br/>
	/// This function should only be invoked from the main thread.<br/>
	/// This is an asynchronous function; it will return immediately, and the<br/>
	/// result will be passed to the callback.<br/>
	/// The callback will be invoked with a null-terminated list of files the user<br/>
	/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
	/// be NULL if an error occurred.<br/>
	/// Note that the callback may be called from a different thread than the one<br/>
	/// the function was invoked on.<br/>
	/// The chosen file may or may not already exist.<br/>
	/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
	/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
	/// should add a call to SDL_PumpEvents in their main loop.<br/>
	/// <br/>
	/// @param callback an SDL_DialogFileCallback to be invoked when the user<br/>
	/// selects a file and accepts, or cancels the dialog, or an<br/>
	/// error occurs. The first argument is a null-terminated list<br/>
	/// of C strings, representing the paths chosen by the user.<br/>
	/// The list will be empty if the user canceled the dialog, and<br/>
	/// it will be NULL if an error occurred. If an error occurred,<br/>
	/// it can be fetched with SDL_GetError(). The second argument<br/>
	/// is the userdata pointer passed to the function. The third<br/>
	/// argument is the index of the filter selected by the user,<br/>
	/// or one past the index of the last filter (therefore the<br/>
	/// index of the terminating NULL filter) if no filter was<br/>
	/// chosen, or -1 if the platform does not support detecting<br/>
	/// the selected filter.<br/>
	/// @param userdata an optional pointer to pass extra data to the callback when<br/>
	/// it will be invoked.<br/>
	/// @param window the window that the dialog should be modal for, may be NULL.<br/>
	/// Not all platforms support this option.<br/>
	/// @param filters a list of SDL_DialogFileFilter's, may be NULL. Not all<br/>
	/// platforms support this option, and platforms that do support<br/>
	/// it may allow the user to ignore the filters.<br/>
	/// @param nfilters the number of filters. Ignored if filters is NULL.<br/>
	/// @param default_location the default folder or file to start the dialog at,<br/>
	/// may be NULL. Not all platforms support this option.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DialogFileCallback<br/>
	/// @sa SDL_DialogFileFilter<br/>
	/// @sa SDL_ShowOpenFileDialog<br/>
	/// @sa SDL_ShowOpenFolderDialog
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShowSaveFileDialog")]
	public static partial void SDL_ShowSaveFileDialog(delegate* unmanaged[Cdecl]<nint, byte**, int, void> callback, nint userdata, SDL_Window window, SDL_DialogFileFilter* filters, int nfilters, byte* default_location);

	[LibraryImport(LibName, EntryPoint = "SDL_ShowSaveFileDialog")]
	public static partial void SDL_ShowSaveFileDialog(delegate* unmanaged[Cdecl]<nint, byte**, int, void> callback, nint userdata, SDL_Window window, SDL_DialogFileFilter* filters, int nfilters, ReadOnlySpan<byte> default_location);

	[LibraryImport(LibName, EntryPoint = "SDL_ShowSaveFileDialog")]
	public static partial void SDL_ShowSaveFileDialog(delegate* unmanaged[Cdecl]<nint, byte**, int, void> callback, nint userdata, SDL_Window window, SDL_DialogFileFilter* filters, int nfilters, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> default_location);

	/// <summary>
	/// Displays a dialog that lets the user select a folder on their filesystem.<br/>
	/// This function should only be invoked from the main thread.<br/>
	/// This is an asynchronous function; it will return immediately, and the<br/>
	/// result will be passed to the callback.<br/>
	/// The callback will be invoked with a null-terminated list of files the user<br/>
	/// chose. The list will be empty if the user canceled the dialog, and it will<br/>
	/// be NULL if an error occurred.<br/>
	/// Note that the callback may be called from a different thread than the one<br/>
	/// the function was invoked on.<br/>
	/// Depending on the platform, the user may be allowed to input paths that<br/>
	/// don't yet exist.<br/>
	/// On Linux, dialogs may require XDG Portals, which requires DBus, which<br/>
	/// requires an event-handling loop. Apps that do not use SDL to handle events<br/>
	/// should add a call to SDL_PumpEvents in their main loop.<br/>
	/// <br/>
	/// @param callback an SDL_DialogFileCallback to be invoked when the user<br/>
	/// selects a file and accepts, or cancels the dialog, or an<br/>
	/// error occurs. The first argument is a null-terminated list<br/>
	/// of C strings, representing the paths chosen by the user.<br/>
	/// The list will be empty if the user canceled the dialog, and<br/>
	/// it will be NULL if an error occurred. If an error occurred,<br/>
	/// it can be fetched with SDL_GetError(). The second argument<br/>
	/// is the userdata pointer passed to the function. The third<br/>
	/// argument is always -1 for SDL_ShowOpenFolderDialog.<br/>
	/// @param userdata an optional pointer to pass extra data to the callback when<br/>
	/// it will be invoked.<br/>
	/// @param window the window that the dialog should be modal for, may be NULL.<br/>
	/// Not all platforms support this option.<br/>
	/// @param default_location the default folder or file to start the dialog at,<br/>
	/// may be NULL. Not all platforms support this option.<br/>
	/// @param allow_many if non-zero, the user will be allowed to select multiple<br/>
	/// entries. Not all platforms support this option.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DialogFileCallback<br/>
	/// @sa SDL_ShowOpenFileDialog<br/>
	/// @sa SDL_ShowSaveFileDialog
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShowOpenFolderDialog")]
	public static partial void SDL_ShowOpenFolderDialog(delegate* unmanaged[Cdecl]<nint, byte**, int, void> callback, nint userdata, SDL_Window window, byte* default_location, SDLBool allow_many);

	[LibraryImport(LibName, EntryPoint = "SDL_ShowOpenFolderDialog")]
	public static partial void SDL_ShowOpenFolderDialog(delegate* unmanaged[Cdecl]<nint, byte**, int, void> callback, nint userdata, SDL_Window window, ReadOnlySpan<byte> default_location, SDLBool allow_many);

	[LibraryImport(LibName, EntryPoint = "SDL_ShowOpenFolderDialog")]
	public static partial void SDL_ShowOpenFolderDialog(delegate* unmanaged[Cdecl]<nint, byte**, int, void> callback, nint userdata, SDL_Window window, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> default_location, SDLBool allow_many);

	/// <summary>
	/// Set the SDL error message for the current thread.<br/>
	/// Calling this function will replace any previous error message that was set.<br/>
	/// This function always returns false, since SDL frequently uses false to<br/>
	/// signify a failing result, leading to this idiom:<br/>
	/// ```c<br/>
	/// if (error_code) {<br/>
	/// return SDL_SetError("This operation has failed: %d", error_code);<br/>
	/// }<br/>
	/// ```<br/>
	/// <br/>
	/// @param fmt a printf()-style message format string.<br/>
	/// @param ... additional parameters matching % tokens in the `fmt` string, if<br/>
	/// any.<br/>
	/// @returns false.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ClearError<br/>
	/// @sa SDL_GetError
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetError")]
	public static partial SDLBool SDL_SetError(byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_SetError")]
	public static partial SDLBool SDL_SetError(ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_SetError")]
	public static partial SDLBool SDL_SetError([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	/// <summary>
	/// Set an error indicating that memory allocation failed.<br/>
	/// This function does not do any memory allocation.<br/>
	/// <br/>
	/// @returns false.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OutOfMemory")]
	public static partial SDLBool SDL_OutOfMemory();

	/// <summary>
	/// Retrieve a message about the last error that occurred on the current<br/>
	/// thread.<br/>
	/// It is possible for multiple errors to occur before calling SDL_GetError().<br/>
	/// Only the last error is returned.<br/>
	/// The message is only applicable when an SDL function has signaled an error.<br/>
	/// You must check the return values of SDL function calls to determine when to<br/>
	/// appropriately call SDL_GetError(). You should *not* use the results of<br/>
	/// SDL_GetError() to decide if an error has occurred! Sometimes SDL will set<br/>
	/// an error string even when reporting success.<br/>
	/// SDL will *not* clear the error string for successful API calls. You *must*<br/>
	/// check return values for failure cases before you can assume the error<br/>
	/// string applies.<br/>
	/// Error strings are set per-thread, so an error set in a different thread<br/>
	/// will not interfere with the current thread's operation.<br/>
	/// The returned value is a thread-local string which will remain valid until<br/>
	/// the current thread's error string is changed. The caller should make a copy<br/>
	/// if the value is needed after the next SDL API call.<br/>
	/// <br/>
	/// @returns a message with information about the specific error that occurred,<br/>
	/// or an empty string if there hasn't been an error message set since<br/>
	/// the last call to SDL_ClearError().<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ClearError<br/>
	/// @sa SDL_SetError
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetError")]
	public static partial byte* SDL_GetErrorPtr();

	public static string? SDL_GetError()
	{
		return ConvertToManaged(SDL_GetErrorPtr());
	}

	/// <summary>
	/// Clear any previous error message for this thread.<br/>
	/// <br/>
	/// @returns true.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetError<br/>
	/// @sa SDL_SetError
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ClearError")]
	public static partial SDLBool SDL_ClearError();

	/// <summary>
	/// Pump the event loop, gathering events from the input devices.<br/>
	/// This function updates the event queue and internal input device state.<br/>
	/// **WARNING**: This should only be run in the thread that initialized the<br/>
	/// video subsystem, and for extra safety, you should consider only doing those<br/>
	/// things on the main thread in any case.<br/>
	/// SDL_PumpEvents() gathers all the pending input information from devices and<br/>
	/// places it in the event queue. Without calls to SDL_PumpEvents() no events<br/>
	/// would ever be placed on the queue. Often the need for calls to<br/>
	/// SDL_PumpEvents() is hidden from the user since SDL_PollEvent() and<br/>
	/// SDL_WaitEvent() implicitly call SDL_PumpEvents(). However, if you are not<br/>
	/// polling or waiting for events (e.g. you are filtering them), then you must<br/>
	/// call SDL_PumpEvents() to force an event queue update.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PollEvent<br/>
	/// @sa SDL_WaitEvent
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PumpEvents")]
	public static partial void SDL_PumpEvents();

	/// <summary>
	/// Check the event queue for messages and optionally return them.<br/>
	/// `action` may be any of the following:<br/>
	/// - `SDL_ADDEVENT`: up to `numevents` events will be added to the back of the<br/>
	/// event queue.<br/>
	/// - `SDL_PEEKEVENT`: `numevents` events at the front of the event queue,<br/>
	/// within the specified minimum and maximum type, will be returned to the<br/>
	/// caller and will _not_ be removed from the queue. If you pass NULL for<br/>
	/// `events`, then `numevents` is ignored and the total number of matching<br/>
	/// events will be returned.<br/>
	/// - `SDL_GETEVENT`: up to `numevents` events at the front of the event queue,<br/>
	/// within the specified minimum and maximum type, will be returned to the<br/>
	/// caller and will be removed from the queue.<br/>
	/// You may have to call SDL_PumpEvents() before calling this function.<br/>
	/// Otherwise, the events may not be ready to be filtered when you call<br/>
	/// SDL_PeepEvents().<br/>
	/// This function is thread-safe.<br/>
	/// <br/>
	/// @param events destination buffer for the retrieved events, may be NULL to<br/>
	/// leave the events in the queue and return the number of events<br/>
	/// that would have been stored.<br/>
	/// @param numevents if action is SDL_ADDEVENT, the number of events to add<br/>
	/// back to the event queue; if action is SDL_PEEKEVENT or<br/>
	/// SDL_GETEVENT, the maximum number of events to retrieve.<br/>
	/// @param action action to take; see [[#action|Remarks]] for details.<br/>
	/// @param minType minimum value of the event type to be considered;<br/>
	/// SDL_EVENT_FIRST is a safe choice.<br/>
	/// @param maxType maximum value of the event type to be considered;<br/>
	/// SDL_EVENT_LAST is a safe choice.<br/>
	/// @returns the number of events actually stored or -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PollEvent<br/>
	/// @sa SDL_PumpEvents<br/>
	/// @sa SDL_PushEvent
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PeepEvents")]
	public static partial int SDL_PeepEvents(SDL_Event* events, int numevents, SDL_EventAction action, SDL_EventType minType, SDL_EventType maxType);

	/// <summary>
	/// Check for the existence of a certain event type in the event queue.<br/>
	/// If you need to check for a range of event types, use SDL_HasEvents()<br/>
	/// instead.<br/>
	/// <br/>
	/// @param type the type of event to be queried; see SDL_EventType for details.<br/>
	/// @returns true if events matching `type` are present, or false if events<br/>
	/// matching `type` are not present.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasEvents
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasEvent")]
	public static partial SDLBool SDL_HasEvent(SDL_EventType type);

	/// <summary>
	/// Check for the existence of certain event types in the event queue.<br/>
	/// If you need to check for a single event type, use SDL_HasEvent() instead.<br/>
	/// <br/>
	/// @param minType the low end of event type to be queried, inclusive; see<br/>
	/// SDL_EventType for details.<br/>
	/// @param maxType the high end of event type to be queried, inclusive; see<br/>
	/// SDL_EventType for details.<br/>
	/// @returns true if events with type >= `minType` and<br/>
	/// <<br/>
	/// = `maxType` are<br/>
	/// present, or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasEvents
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasEvents")]
	public static partial SDLBool SDL_HasEvents(SDL_EventType minType, SDL_EventType maxType);

	/// <summary>
	/// Clear events of a specific type from the event queue.<br/>
	/// This will unconditionally remove any events from the queue that match<br/>
	/// `type`. If you need to remove a range of event types, use SDL_FlushEvents()<br/>
	/// instead.<br/>
	/// It's also normal to just ignore events you don't care about in your event<br/>
	/// loop without calling this function.<br/>
	/// This function only affects currently queued events. If you want to make<br/>
	/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
	/// on the main thread immediately before the flush call.<br/>
	/// If you have user events with custom data that needs to be freed, you should<br/>
	/// use SDL_PeepEvents() to remove and clean up those events before calling<br/>
	/// this function.<br/>
	/// <br/>
	/// @param type the type of event to be cleared; see SDL_EventType for details.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_FlushEvents
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_FlushEvent")]
	public static partial void SDL_FlushEvent(SDL_EventType type);

	/// <summary>
	/// Clear events of a range of types from the event queue.<br/>
	/// This will unconditionally remove any events from the queue that are in the<br/>
	/// range of `minType` to `maxType`, inclusive. If you need to remove a single<br/>
	/// event type, use SDL_FlushEvent() instead.<br/>
	/// It's also normal to just ignore events you don't care about in your event<br/>
	/// loop without calling this function.<br/>
	/// This function only affects currently queued events. If you want to make<br/>
	/// sure that all pending OS events are flushed, you can call SDL_PumpEvents()<br/>
	/// on the main thread immediately before the flush call.<br/>
	/// <br/>
	/// @param minType the low end of event type to be cleared, inclusive; see<br/>
	/// SDL_EventType for details.<br/>
	/// @param maxType the high end of event type to be cleared, inclusive; see<br/>
	/// SDL_EventType for details.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_FlushEvent
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_FlushEvents")]
	public static partial void SDL_FlushEvents(SDL_EventType minType, SDL_EventType maxType);

	/// <summary>
	/// Poll for currently pending events.<br/>
	/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
	/// in the SDL_Event structure pointed to by `event`. The 1 returned refers to<br/>
	/// this event, immediately stored in the SDL Event structure -- not an event<br/>
	/// to follow.<br/>
	/// If `event` is NULL, it simply returns 1 if there is an event in the queue,<br/>
	/// but will not remove it from the queue.<br/>
	/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
	/// this function in the thread that set the video mode.<br/>
	/// SDL_PollEvent() is the favored way of receiving system events since it can<br/>
	/// be done from the main loop and does not suspend the main loop while waiting<br/>
	/// on an event to be posted.<br/>
	/// The common practice is to fully process the event queue once every frame,<br/>
	/// usually as a first step before updating the game's state:<br/>
	/// ```c<br/>
	/// while (game_is_still_running) {<br/>
	/// SDL_Event event;<br/>
	/// while (SDL_PollEvent(<br/>
	/// &event<br/>
	/// )) {  // poll until all events are handled!<br/>
	/// // decide what to do with this event.<br/>
	/// }<br/>
	/// // update game state, draw the current frame<br/>
	/// }<br/>
	/// ```<br/>
	/// <br/>
	/// @param event the SDL_Event structure to be filled with the next event from<br/>
	/// the queue, or NULL.<br/>
	/// @returns true if this got an event or false if there are none available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PushEvent<br/>
	/// @sa SDL_WaitEvent<br/>
	/// @sa SDL_WaitEventTimeout
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PollEvent")]
	public static partial SDLBool SDL_PollEvent(SDL_Event* @event);

	/// <summary>
	/// Wait indefinitely for the next available event.<br/>
	/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
	/// in the SDL_Event structure pointed to by `event`.<br/>
	/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
	/// this function in the thread that initialized the video subsystem.<br/>
	/// <br/>
	/// @param event the SDL_Event structure to be filled in with the next event<br/>
	/// from the queue, or NULL.<br/>
	/// @returns true on success or false if there was an error while waiting for<br/>
	/// events; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PollEvent<br/>
	/// @sa SDL_PushEvent<br/>
	/// @sa SDL_WaitEventTimeout
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WaitEvent")]
	public static partial SDLBool SDL_WaitEvent(SDL_Event* @event);

	/// <summary>
	/// Wait until the specified timeout (in milliseconds) for the next available<br/>
	/// event.<br/>
	/// If `event` is not NULL, the next event is removed from the queue and stored<br/>
	/// in the SDL_Event structure pointed to by `event`.<br/>
	/// As this function may implicitly call SDL_PumpEvents(), you can only call<br/>
	/// this function in the thread that initialized the video subsystem.<br/>
	/// The timeout is not guaranteed, the actual wait time could be longer due to<br/>
	/// system scheduling.<br/>
	/// <br/>
	/// @param event the SDL_Event structure to be filled in with the next event<br/>
	/// from the queue, or NULL.<br/>
	/// @param timeoutMS the maximum number of milliseconds to wait for the next<br/>
	/// available event.<br/>
	/// @returns true if this got an event or false if the timeout elapsed without<br/>
	/// any events available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PollEvent<br/>
	/// @sa SDL_PushEvent<br/>
	/// @sa SDL_WaitEvent
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WaitEventTimeout")]
	public static partial SDLBool SDL_WaitEventTimeout(SDL_Event* @event, int timeoutMS);

	/// <summary>
	/// Add an event to the event queue.<br/>
	/// The event queue can actually be used as a two way communication channel.<br/>
	/// Not only can events be read from the queue, but the user can also push<br/>
	/// their own events onto it. `event` is a pointer to the event structure you<br/>
	/// wish to push onto the queue. The event is copied into the queue, and the<br/>
	/// caller may dispose of the memory pointed to after SDL_PushEvent() returns.<br/>
	/// Note: Pushing device input events onto the queue doesn't modify the state<br/>
	/// of the device within SDL.<br/>
	/// This function is thread-safe, and can be called from other threads safely.<br/>
	/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
	/// the event filter but events added with SDL_PeepEvents() do not.<br/>
	/// For pushing application-specific events, please use SDL_RegisterEvents() to<br/>
	/// get an event type that does not conflict with other code that also wants<br/>
	/// its own custom event types.<br/>
	/// <br/>
	/// @param event the SDL_Event to be added to the queue.<br/>
	/// @returns true on success, false if the event was filtered or on failure;<br/>
	/// call SDL_GetError() for more information. A common reason for<br/>
	/// error is the event queue being full.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PeepEvents<br/>
	/// @sa SDL_PollEvent<br/>
	/// @sa SDL_RegisterEvents
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PushEvent")]
	public static partial SDLBool SDL_PushEvent(SDL_Event* @event);

	/// <summary>
	/// Set up a filter to process all events before they change internal state and<br/>
	/// are posted to the internal event queue.<br/>
	/// If the filter function returns true when called, then the event will be<br/>
	/// added to the internal queue. If it returns false, then the event will be<br/>
	/// dropped from the queue, but the internal state will still be updated. This<br/>
	/// allows selective filtering of dynamically arriving events.<br/>
	/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
	/// as it may run in a different thread!<br/>
	/// On platforms that support it, if the quit event is generated by an<br/>
	/// interrupt signal (e.g. pressing Ctrl-C), it will be delivered to the<br/>
	/// application at the next event poll.<br/>
	/// There is one caveat when dealing with the SDL_QuitEvent event type. The<br/>
	/// event filter is only called when the window manager desires to close the<br/>
	/// application window. If the event filter returns 1, then the window will be<br/>
	/// closed, otherwise the window will remain open if possible.<br/>
	/// Note: Disabled events never make it to the event filter function; see<br/>
	/// SDL_SetEventEnabled().<br/>
	/// Note: If you just want to inspect events without filtering, you should use<br/>
	/// SDL_AddEventWatch() instead.<br/>
	/// Note: Events pushed onto the queue with SDL_PushEvent() get passed through<br/>
	/// the event filter, but events pushed onto the queue with SDL_PeepEvents() do<br/>
	/// not.<br/>
	/// <br/>
	/// @param filter an SDL_EventFilter function to call when an event happens.<br/>
	/// @param userdata a pointer that is passed to `filter`.<br/>
	/// @threadsafety SDL may call the filter callback at any time from any thread;<br/>
	/// the application is responsible for locking resources the<br/>
	/// callback touches that need to be protected.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddEventWatch<br/>
	/// @sa SDL_SetEventEnabled<br/>
	/// @sa SDL_GetEventFilter<br/>
	/// @sa SDL_PeepEvents<br/>
	/// @sa SDL_PushEvent
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetEventFilter")]
	public static partial void SDL_SetEventFilter(delegate* unmanaged[Cdecl]<nint, SDL_Event*, SDLBool> filter, nint userdata);

	/// <summary>
	/// Query the current event filter.<br/>
	/// This function can be used to "chain" filters, by saving the existing filter<br/>
	/// before replacing it with a function that will call that saved filter.<br/>
	/// <br/>
	/// @param filter the current callback function will be stored here.<br/>
	/// @param userdata the pointer that is passed to the current event filter will<br/>
	/// be stored here.<br/>
	/// @returns true on success or false if there is no event filter set.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetEventFilter
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetEventFilter")]
	public static partial SDLBool SDL_GetEventFilter(delegate* unmanaged[Cdecl]<nint, SDL_Event*, SDLBool> filter, nint userdata);

	/// <summary>
	/// Add a callback to be triggered when an event is added to the event queue.<br/>
	/// `filter` will be called when an event happens, and its return value is<br/>
	/// ignored.<br/>
	/// **WARNING**: Be very careful of what you do in the event filter function,<br/>
	/// as it may run in a different thread!<br/>
	/// If the quit event is generated by a signal (e.g. SIGINT), it will bypass<br/>
	/// the internal queue and be delivered to the watch callback immediately, and<br/>
	/// arrive at the next event poll.<br/>
	/// Note: the callback is called for events posted by the user through<br/>
	/// SDL_PushEvent(), but not for disabled events, nor for events by a filter<br/>
	/// callback set with SDL_SetEventFilter(), nor for events posted by the user<br/>
	/// through SDL_PeepEvents().<br/>
	/// <br/>
	/// @param filter an SDL_EventFilter function to call when an event happens.<br/>
	/// @param userdata a pointer that is passed to `filter`.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RemoveEventWatch<br/>
	/// @sa SDL_SetEventFilter
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AddEventWatch")]
	public static partial SDLBool SDL_AddEventWatch(delegate* unmanaged[Cdecl]<nint, SDL_Event*, SDLBool> filter, nint userdata);

	/// <summary>
	/// Remove an event watch callback added with SDL_AddEventWatch().<br/>
	/// This function takes the same input as SDL_AddEventWatch() to identify and<br/>
	/// delete the corresponding callback.<br/>
	/// <br/>
	/// @param filter the function originally passed to SDL_AddEventWatch().<br/>
	/// @param userdata the pointer originally passed to SDL_AddEventWatch().<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddEventWatch
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RemoveEventWatch")]
	public static partial void SDL_RemoveEventWatch(delegate* unmanaged[Cdecl]<nint, SDL_Event*, SDLBool> filter, nint userdata);

	/// <summary>
	/// Run a specific filter function on the current event queue, removing any<br/>
	/// events for which the filter returns false.<br/>
	/// See SDL_SetEventFilter() for more information. Unlike SDL_SetEventFilter(),<br/>
	/// this function does not change the filter permanently, it only uses the<br/>
	/// supplied filter until this function returns.<br/>
	/// <br/>
	/// @param filter the SDL_EventFilter function to call when an event happens.<br/>
	/// @param userdata a pointer that is passed to `filter`.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetEventFilter<br/>
	/// @sa SDL_SetEventFilter
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_FilterEvents")]
	public static partial void SDL_FilterEvents(delegate* unmanaged[Cdecl]<nint, SDL_Event*, SDLBool> filter, nint userdata);

	/// <summary>
	/// Set the state of processing events by type.<br/>
	/// <br/>
	/// @param type the type of event; see SDL_EventType for details.<br/>
	/// @param enabled whether to process the event or not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_EventEnabled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetEventEnabled")]
	public static partial void SDL_SetEventEnabled(SDL_EventType type, SDLBool enabled);

	/// <summary>
	/// Query the state of processing events by type.<br/>
	/// <br/>
	/// @param type the type of event; see SDL_EventType for details.<br/>
	/// @returns true if the event is being processed, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetEventEnabled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EventEnabled")]
	public static partial SDLBool SDL_EventEnabled(SDL_EventType type);

	/// <summary>
	/// Allocate a set of user-defined events, and return the beginning event<br/>
	/// number for that set of events.<br/>
	/// <br/>
	/// @param numevents the number of events to be allocated.<br/>
	/// @returns the beginning event number, or 0 if numevents is invalid or if<br/>
	/// there are not enough user-defined events left.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PushEvent
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RegisterEvents")]
	public static partial uint SDL_RegisterEvents(int numevents);

	/// <summary>
	/// Get window associated with an event.<br/>
	/// <br/>
	/// @param event an event containing a `windowID`.<br/>
	/// @returns the associated window on success or NULL if there is none.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PollEvent<br/>
	/// @sa SDL_WaitEvent<br/>
	/// @sa SDL_WaitEventTimeout
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowFromEvent")]
	public static partial SDL_Window SDL_GetWindowFromEvent(SDL_Event* @event);

	/// <summary>
	/// Get the directory where the application was run from.<br/>
	/// SDL caches the result of this call internally, but the first call to this<br/>
	/// function is not necessarily fast, so plan accordingly.<br/>
	/// **macOS and iOS Specific Functionality**: If the application is in a ".app"<br/>
	/// bundle, this function returns the Resource directory (e.g.<br/>
	/// MyApp.app/Contents/Resources/). This behaviour can be overridden by adding<br/>
	/// a property to the Info.plist file. Adding a string key with the name<br/>
	/// SDL_FILESYSTEM_BASE_DIR_TYPE with a supported value will change the<br/>
	/// behaviour.<br/>
	/// Supported values for the SDL_FILESYSTEM_BASE_DIR_TYPE property (Given an<br/>
	/// application in /Applications/SDLApp/MyApp.app):<br/>
	/// - `resource`: bundle resource directory (the default). For example:<br/>
	/// `/Applications/SDLApp/MyApp.app/Contents/Resources`<br/>
	/// - `bundle`: the Bundle directory. For example:<br/>
	/// `/Applications/SDLApp/MyApp.app/`<br/>
	/// - `parent`: the containing directory of the bundle. For example:<br/>
	/// `/Applications/SDLApp/`<br/>
	/// **Nintendo 3DS Specific Functionality**: This function returns "romfs"<br/>
	/// directory of the application as it is uncommon to store resources outside<br/>
	/// the executable. As such it is not a writable directory.<br/>
	/// The returned path is guaranteed to end with a path separator ('<br/>
	/// \<br/>
	/// ' on<br/>
	/// Windows, '/' on most other platforms).<br/>
	/// <br/>
	/// @returns an absolute path in UTF-8 encoding to the application data<br/>
	/// directory. NULL will be returned on error or when the platform<br/>
	/// doesn't implement this functionality, call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPrefPath
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetBasePath")]
	public static partial byte* SDL_GetBasePathPtr();

	public static string? SDL_GetBasePath()
	{
		return ConvertToManaged(SDL_GetBasePathPtr());
	}

	/// <summary>
	/// Get the user-and-app-specific path where files can be written.<br/>
	/// Get the "pref dir". This is meant to be where users can write personal<br/>
	/// files (preferences and save games, etc) that are specific to your<br/>
	/// application. This directory is unique per user, per application.<br/>
	/// This function will decide the appropriate location in the native<br/>
	/// filesystem, create the directory if necessary, and return a string of the<br/>
	/// absolute path to the directory in UTF-8 encoding.<br/>
	/// On Windows, the string might look like:<br/>
	/// `C:<br/>
	/// \<br/>
	/// Users<br/>
	/// \<br/>
	/// bob<br/>
	/// \<br/>
	/// AppData<br/>
	/// \<br/>
	/// Roaming<br/>
	/// \<br/>
	/// My Company<br/>
	/// \<br/>
	/// My Program Name<br/>
	/// \<br/>
	/// `<br/>
	/// On Linux, the string might look like:<br/>
	/// `/home/bob/.local/share/My Program Name/`<br/>
	/// On macOS, the string might look like:<br/>
	/// `/Users/bob/Library/Application Support/My Program Name/`<br/>
	/// You should assume the path returned by this function is the only safe place<br/>
	/// to write files (and that SDL_GetBasePath(), while it might be writable, or<br/>
	/// even the parent of the returned path, isn't where you should be writing<br/>
	/// things).<br/>
	/// Both the org and app strings may become part of a directory name, so please<br/>
	/// follow these rules:<br/>
	/// - Try to use the same org string (_including case-sensitivity_) for all<br/>
	/// your applications that use this function.<br/>
	/// - Always use a unique app string for each one, and make sure it never<br/>
	/// changes for an app once you've decided on it.<br/>
	/// - Unicode characters are legal, as long as they are UTF-8 encoded, but...<br/>
	/// - ...only use letters, numbers, and spaces. Avoid punctuation like "Game<br/>
	/// Name 2: Bad Guy's Revenge!" ... "Game Name 2" is sufficient.<br/>
	/// The returned path is guaranteed to end with a path separator ('<br/>
	/// \<br/>
	/// ' on<br/>
	/// Windows, '/' on most other platforms).<br/>
	/// <br/>
	/// @param org the name of your organization.<br/>
	/// @param app the name of your application.<br/>
	/// @returns a UTF-8 string of the user directory in platform-dependent<br/>
	/// notation. NULL if there's a problem (creating directory failed,<br/>
	/// etc.). This should be freed with SDL_free() when it is no longer<br/>
	/// needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetBasePath
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPrefPath")]
	public static partial byte* SDL_GetPrefPathPtr(byte* org, byte* app);

	public static string? SDL_GetPrefPath(byte* org, byte* app)
	{
		byte* resultPtr = SDL_GetPrefPathPtr(org, app);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_GetPrefPath")]
	public static partial byte* SDL_GetPrefPathPtr(ReadOnlySpan<byte> org, ReadOnlySpan<byte> app);

	[LibraryImport(LibName, EntryPoint = "SDL_GetPrefPath")]
	public static partial byte* SDL_GetPrefPathPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> org, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> app);

	/// <summary>
	/// Finds the most suitable user folder for a specific purpose.<br/>
	/// Many OSes provide certain standard folders for certain purposes, such as<br/>
	/// storing pictures, music or videos for a certain user. This function gives<br/>
	/// the path for many of those special locations.<br/>
	/// This function is specifically for _user_ folders, which are meant for the<br/>
	/// user to access and manage. For application-specific folders, meant to hold<br/>
	/// data for the application to manage, see SDL_GetBasePath() and<br/>
	/// SDL_GetPrefPath().<br/>
	/// The returned path is guaranteed to end with a path separator ('<br/>
	/// \<br/>
	/// ' on<br/>
	/// Windows, '/' on most other platforms).<br/>
	/// If NULL is returned, the error may be obtained with SDL_GetError().<br/>
	/// <br/>
	/// @param folder the type of folder to find.<br/>
	/// @returns either a null-terminated C string containing the full path to the<br/>
	/// folder, or NULL if an error happened.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetUserFolder")]
	public static partial byte* SDL_GetUserFolderPtr(SDL_Folder folder);

	public static string? SDL_GetUserFolder(SDL_Folder folder)
	{
		return ConvertToManaged(SDL_GetUserFolderPtr(folder));
	}

	/// <summary>
	/// Create a directory, and any missing parent directories.<br/>
	/// This reports success if `path` already exists as a directory.<br/>
	/// If parent directories are missing, it will also create them. Note that if<br/>
	/// this fails, it will not remove any parent directories it already made.<br/>
	/// <br/>
	/// @param path the path of the directory to create.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateDirectory")]
	public static partial SDLBool SDL_CreateDirectory(byte* path);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateDirectory")]
	public static partial SDLBool SDL_CreateDirectory(ReadOnlySpan<byte> path);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateDirectory")]
	public static partial SDLBool SDL_CreateDirectory([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);

	/// <summary>
	/// Enumerate a directory through a callback function.<br/>
	/// This function provides every directory entry through an app-provided<br/>
	/// callback, called once for each directory entry, until all results have been<br/>
	/// provided or the callback returns<br/>
	/// <<br/>
	/// = 0.<br/>
	/// This will return false if there was a system problem in general, or if a<br/>
	/// callback returns -1. A successful return means a callback returned 1 to<br/>
	/// halt enumeration, or all directory entries were enumerated.<br/>
	/// <br/>
	/// @param path the path of the directory to enumerate.<br/>
	/// @param callback a function that is called for each entry in the directory.<br/>
	/// @param userdata a pointer that is passed to `callback`.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EnumerateDirectory")]
	public static partial SDLBool SDL_EnumerateDirectory(byte* path, delegate* unmanaged[Cdecl]<nint, byte*, byte*, SDL_EnumerationResult> callback, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_EnumerateDirectory")]
	public static partial SDLBool SDL_EnumerateDirectory(ReadOnlySpan<byte> path, delegate* unmanaged[Cdecl]<nint, byte*, byte*, SDL_EnumerationResult> callback, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_EnumerateDirectory")]
	public static partial SDLBool SDL_EnumerateDirectory([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, delegate* unmanaged[Cdecl]<nint, byte*, byte*, SDL_EnumerationResult> callback, nint userdata);

	/// <summary>
	/// Remove a file or an empty directory.<br/>
	/// Directories that are not empty will fail; this function will not recursely<br/>
	/// delete directory trees.<br/>
	/// <br/>
	/// @param path the path to remove from the filesystem.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RemovePath")]
	public static partial SDLBool SDL_RemovePath(byte* path);

	[LibraryImport(LibName, EntryPoint = "SDL_RemovePath")]
	public static partial SDLBool SDL_RemovePath(ReadOnlySpan<byte> path);

	[LibraryImport(LibName, EntryPoint = "SDL_RemovePath")]
	public static partial SDLBool SDL_RemovePath([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);

	/// <summary>
	/// Rename a file or directory.<br/>
	/// If the file at `newpath` already exists, it will replaced.<br/>
	/// Note that this will not copy files across filesystems/drives/volumes, as<br/>
	/// that is a much more complicated (and possibly time-consuming) operation.<br/>
	/// Which is to say, if this function fails, SDL_CopyFile() to a temporary file<br/>
	/// in the same directory as `newpath`, then SDL_RenamePath() from the<br/>
	/// temporary file to `newpath` and SDL_RemovePath() on `oldpath` might work<br/>
	/// for files. Renaming a non-empty directory across filesystems is<br/>
	/// dramatically more complex, however.<br/>
	/// <br/>
	/// @param oldpath the old path.<br/>
	/// @param newpath the new path.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenamePath")]
	public static partial SDLBool SDL_RenamePath(byte* oldpath, byte* newpath);

	[LibraryImport(LibName, EntryPoint = "SDL_RenamePath")]
	public static partial SDLBool SDL_RenamePath(ReadOnlySpan<byte> oldpath, ReadOnlySpan<byte> newpath);

	[LibraryImport(LibName, EntryPoint = "SDL_RenamePath")]
	public static partial SDLBool SDL_RenamePath([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> oldpath, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> newpath);

	/// <summary>
	/// Copy a file.<br/>
	/// If the file at `newpath` already exists, it will be overwritten with the<br/>
	/// contents of the file at `oldpath`.<br/>
	/// This function will block until the copy is complete, which might be a<br/>
	/// significant time for large files on slow disks. On some platforms, the copy<br/>
	/// can be handed off to the OS itself, but on others SDL might just open both<br/>
	/// paths, and read from one and write to the other.<br/>
	/// Note that this is not an atomic operation! If something tries to read from<br/>
	/// `newpath` while the copy is in progress, it will see an incomplete copy of<br/>
	/// the data, and if the calling thread terminates (or the power goes out)<br/>
	/// during the copy, `oldpath`'s previous contents will be gone, replaced with<br/>
	/// an incomplete copy of the data. To avoid this risk, it is recommended that<br/>
	/// the app copy to a temporary file in the same directory as `newpath`, and if<br/>
	/// the copy is successful, use SDL_RenamePath() to replace `newpath` with the<br/>
	/// temporary file. This will ensure that reads of `newpath` will either see a<br/>
	/// complete copy of the data, or it will see the pre-copy state of `newpath`.<br/>
	/// This function attempts to synchronize the newly-copied data to disk before<br/>
	/// returning, if the platform allows it, so that the renaming trick will not<br/>
	/// have a problem in a system crash or power failure, where the file could be<br/>
	/// renamed but the contents never made it from the system file cache to the<br/>
	/// physical disk.<br/>
	/// If the copy fails for any reason, the state of `newpath` is undefined. It<br/>
	/// might be half a copy, it might be the untouched data of what was already<br/>
	/// there, or it might be a zero-byte file, etc.<br/>
	/// <br/>
	/// @param oldpath the old path.<br/>
	/// @param newpath the new path.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CopyFile")]
	public static partial SDLBool SDL_CopyFile(byte* oldpath, byte* newpath);

	[LibraryImport(LibName, EntryPoint = "SDL_CopyFile")]
	public static partial SDLBool SDL_CopyFile(ReadOnlySpan<byte> oldpath, ReadOnlySpan<byte> newpath);

	[LibraryImport(LibName, EntryPoint = "SDL_CopyFile")]
	public static partial SDLBool SDL_CopyFile([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> oldpath, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> newpath);

	/// <summary>
	/// Get information about a filesystem path.<br/>
	/// <br/>
	/// @param path the path to query.<br/>
	/// @param info a pointer filled in with information about the path, or NULL to<br/>
	/// check for the existence of a file.<br/>
	/// @returns true on success or false if the file doesn't exist, or another<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPathInfo")]
	public static partial SDLBool SDL_GetPathInfo(byte* path, SDL_PathInfo* info);

	[LibraryImport(LibName, EntryPoint = "SDL_GetPathInfo")]
	public static partial SDLBool SDL_GetPathInfo(ReadOnlySpan<byte> path, SDL_PathInfo* info);

	[LibraryImport(LibName, EntryPoint = "SDL_GetPathInfo")]
	public static partial SDLBool SDL_GetPathInfo([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, SDL_PathInfo* info);

	/// <summary>
	/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
	/// Files are filtered out if they don't match the string in `pattern`, which<br/>
	/// may contain wildcard characters '*' (match everything) and '?' (match one<br/>
	/// character). If pattern is NULL, no filtering is done and all results are<br/>
	/// returned. Subdirectories are permitted, and are specified with a path<br/>
	/// separator of '/'. Wildcard characters '*' and '?' never match a path<br/>
	/// separator.<br/>
	/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
	/// case-insensitive.<br/>
	/// The returned array is always NULL-terminated, for your iterating<br/>
	/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
	/// number of items in the array, not counting the NULL terminator.<br/>
	/// <br/>
	/// @param path the path of the directory to enumerate.<br/>
	/// @param pattern the pattern that files in the directory must match. Can be<br/>
	/// NULL.<br/>
	/// @param flags `SDL_GLOB_*` bitflags that affect this search.<br/>
	/// @param count on return, will be set to the number of items in the returned<br/>
	/// array. Can be NULL.<br/>
	/// @returns an array of strings on success or NULL on failure; call<br/>
	/// SDL_GetError() for more information. This is a single allocation<br/>
	/// that should be freed with SDL_free() when it is no longer needed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GlobDirectory")]
	public static partial byte** SDL_GlobDirectory(byte* path, byte* pattern, SDL_GlobFlags flags, int* count);

	[LibraryImport(LibName, EntryPoint = "SDL_GlobDirectory")]
	public static partial byte** SDL_GlobDirectory(ReadOnlySpan<byte> path, ReadOnlySpan<byte> pattern, SDL_GlobFlags flags, int* count);

	[LibraryImport(LibName, EntryPoint = "SDL_GlobDirectory")]
	public static partial byte** SDL_GlobDirectory([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> pattern, SDL_GlobFlags flags, int* count);

	/// <summary>
	/// Add support for gamepads that SDL is unaware of or change the binding of an<br/>
	/// existing gamepad.<br/>
	/// The mapping string has the format "GUID,name,mapping", where GUID is the<br/>
	/// string value from SDL_GUIDToString(), name is the human readable string for<br/>
	/// the device and mappings are gamepad mappings to joystick ones. Under<br/>
	/// Windows there is a reserved GUID of "xinput" that covers all XInput<br/>
	/// devices. The mapping format for joystick is:<br/>
	/// - `bX`: a joystick button, index X<br/>
	/// - `hX.Y`: hat X with value Y<br/>
	/// - `aX`: axis X of the joystick<br/>
	/// Buttons can be used as a gamepad axes and vice versa.<br/>
	/// This string shows an example of a valid mapping for a gamepad:<br/>
	/// ```c<br/>
	/// "341a3608000000000000504944564944,Afterglow PS3 Controller,a:b1,b:b2,y:b3,x:b0,start:b9,guide:b12,back:b8,dpup:h0.1,dpleft:h0.8,dpdown:h0.4,dpright:h0.2,leftshoulder:b4,rightshoulder:b5,leftstick:b10,rightstick:b11,leftx:a0,lefty:a1,rightx:a2,righty:a3,lefttrigger:b6,righttrigger:b7"<br/>
	/// ```<br/>
	/// <br/>
	/// @param mapping the mapping string.<br/>
	/// @returns 1 if a new mapping is added, 0 if an existing mapping is updated,<br/>
	/// -1 on failure; call SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadMapping<br/>
	/// @sa SDL_GetGamepadMappingForGUID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AddGamepadMapping")]
	public static partial int SDL_AddGamepadMapping(byte* mapping);

	[LibraryImport(LibName, EntryPoint = "SDL_AddGamepadMapping")]
	public static partial int SDL_AddGamepadMapping(ReadOnlySpan<byte> mapping);

	[LibraryImport(LibName, EntryPoint = "SDL_AddGamepadMapping")]
	public static partial int SDL_AddGamepadMapping([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> mapping);

	/// <summary>
	/// Load a set of gamepad mappings from an SDL_IOStream.<br/>
	/// You can call this function several times, if needed, to load different<br/>
	/// database files.<br/>
	/// If a new mapping is loaded for an already known gamepad GUID, the later<br/>
	/// version will overwrite the one currently loaded.<br/>
	/// Mappings not belonging to the current platform or with no platform field<br/>
	/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
	/// Windows, etc).<br/>
	/// This function will load the text database entirely in memory before<br/>
	/// processing it, so take this into consideration if you are in a memory<br/>
	/// constrained environment.<br/>
	/// <br/>
	/// @param src the data stream for the mappings to be added.<br/>
	/// @param closeio if true, calls SDL_CloseIO() on `src` before returning, even<br/>
	/// in the case of an error.<br/>
	/// @returns the number of mappings added or -1 on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddGamepadMapping<br/>
	/// @sa SDL_AddGamepadMappingsFromFile<br/>
	/// @sa SDL_GetGamepadMapping<br/>
	/// @sa SDL_GetGamepadMappingForGUID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AddGamepadMappingsFromIO")]
	public static partial int SDL_AddGamepadMappingsFromIO(SDL_IOStream src, SDLBool closeio);

	/// <summary>
	/// Load a set of gamepad mappings from a file.<br/>
	/// You can call this function several times, if needed, to load different<br/>
	/// database files.<br/>
	/// If a new mapping is loaded for an already known gamepad GUID, the later<br/>
	/// version will overwrite the one currently loaded.<br/>
	/// Mappings not belonging to the current platform or with no platform field<br/>
	/// specified will be ignored (i.e. mappings for Linux will be ignored in<br/>
	/// Windows, etc).<br/>
	/// <br/>
	/// @param file the mappings file to load.<br/>
	/// @returns the number of mappings added or -1 on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddGamepadMapping<br/>
	/// @sa SDL_AddGamepadMappingsFromIO<br/>
	/// @sa SDL_GetGamepadMapping<br/>
	/// @sa SDL_GetGamepadMappingForGUID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AddGamepadMappingsFromFile")]
	public static partial int SDL_AddGamepadMappingsFromFile(byte* file);

	[LibraryImport(LibName, EntryPoint = "SDL_AddGamepadMappingsFromFile")]
	public static partial int SDL_AddGamepadMappingsFromFile(ReadOnlySpan<byte> file);

	[LibraryImport(LibName, EntryPoint = "SDL_AddGamepadMappingsFromFile")]
	public static partial int SDL_AddGamepadMappingsFromFile([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> file);

	/// <summary>
	/// Reinitialize the SDL mapping database to its initial state.<br/>
	/// This will generate gamepad events as needed if device mappings change.<br/>
	/// <br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReloadGamepadMappings")]
	public static partial SDLBool SDL_ReloadGamepadMappings();

	/// <summary>
	/// Get the current gamepad mappings.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of mappings returned, can<br/>
	/// be NULL.<br/>
	/// @returns an array of the mapping strings, NULL-terminated, or NULL on<br/>
	/// failure; call SDL_GetError() for more information. This is a<br/>
	/// single allocation that should be freed with SDL_free() when it is<br/>
	/// no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadMappings")]
	public static partial byte** SDL_GetGamepadMappings(out int count);

	/// <summary>
	/// Get the gamepad mapping string for a given GUID.<br/>
	/// <br/>
	/// @param guid a structure containing the GUID for which a mapping is desired.<br/>
	/// @returns a mapping string or NULL on failure; call SDL_GetError() for more<br/>
	/// information. This should be freed with SDL_free() when it is no<br/>
	/// longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickGUIDForID<br/>
	/// @sa SDL_GetJoystickGUID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadMappingForGUID")]
	public static partial byte* SDL_GetGamepadMappingForGUIDPtr(Guid guid);

	public static string? SDL_GetGamepadMappingForGUID(Guid guid)
	{
		byte* resultPtr = SDL_GetGamepadMappingForGUIDPtr(guid);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	/// <summary>
	/// Get the current mapping of a gamepad.<br/>
	/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
	/// <br/>
	/// @param gamepad the gamepad you want to get the current mapping for.<br/>
	/// @returns a string that has the gamepad's mapping or NULL if no mapping is<br/>
	/// available; call SDL_GetError() for more information. This should<br/>
	/// be freed with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddGamepadMapping<br/>
	/// @sa SDL_GetGamepadMappingForID<br/>
	/// @sa SDL_GetGamepadMappingForGUID<br/>
	/// @sa SDL_SetGamepadMapping
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadMapping")]
	public static partial byte* SDL_GetGamepadMappingPtr(SDL_Gamepad gamepad);

	public static string? SDL_GetGamepadMapping(SDL_Gamepad gamepad)
	{
		byte* resultPtr = SDL_GetGamepadMappingPtr(gamepad);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	/// <summary>
	/// Set the current mapping of a joystick or gamepad.<br/>
	/// Details about mappings are discussed with SDL_AddGamepadMapping().<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @param mapping the mapping to use for this device, or NULL to clear the<br/>
	/// mapping.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddGamepadMapping<br/>
	/// @sa SDL_GetGamepadMapping
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGamepadMapping")]
	public static partial SDLBool SDL_SetGamepadMapping(SDL_JoystickID instance_id, byte* mapping);

	[LibraryImport(LibName, EntryPoint = "SDL_SetGamepadMapping")]
	public static partial SDLBool SDL_SetGamepadMapping(SDL_JoystickID instance_id, ReadOnlySpan<byte> mapping);

	[LibraryImport(LibName, EntryPoint = "SDL_SetGamepadMapping")]
	public static partial SDLBool SDL_SetGamepadMapping(SDL_JoystickID instance_id, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> mapping);

	/// <summary>
	/// Return whether a gamepad is currently connected.<br/>
	/// <br/>
	/// @returns true if a gamepad is connected, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepads
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasGamepad")]
	public static partial SDLBool SDL_HasGamepad();

	/// <summary>
	/// Get a list of currently connected gamepads.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of gamepads returned, may<br/>
	/// be NULL.<br/>
	/// @returns a 0 terminated array of joystick instance IDs or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This should be freed<br/>
	/// with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasGamepad<br/>
	/// @sa SDL_OpenGamepad
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepads")]
	public static partial SDL_JoystickID* SDL_GetGamepads(out int count);

	/// <summary>
	/// Check if the given joystick is supported by the gamepad interface.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns true if the given joystick is supported by the gamepad interface,<br/>
	/// false if it isn't or it's an invalid index.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoysticks<br/>
	/// @sa SDL_OpenGamepad
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IsGamepad")]
	public static partial SDLBool SDL_IsGamepad(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the implementation dependent name of a gamepad.<br/>
	/// This can be called before any gamepads are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the name of the selected gamepad. If no name can be found, this<br/>
	/// function returns NULL; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadName<br/>
	/// @sa SDL_GetGamepads
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadNameForID")]
	public static partial byte* SDL_GetGamepadNameForIDPtr(SDL_JoystickID instance_id);

	public static string? SDL_GetGamepadNameForID(SDL_JoystickID instance_id)
	{
		return ConvertToManaged(SDL_GetGamepadNameForIDPtr(instance_id));
	}

	/// <summary>
	/// Get the implementation dependent path of a gamepad.<br/>
	/// This can be called before any gamepads are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the path of the selected gamepad. If no path can be found, this<br/>
	/// function returns NULL; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadPath<br/>
	/// @sa SDL_GetGamepads
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadPathForID")]
	public static partial byte* SDL_GetGamepadPathForIDPtr(SDL_JoystickID instance_id);

	public static string? SDL_GetGamepadPathForID(SDL_JoystickID instance_id)
	{
		return ConvertToManaged(SDL_GetGamepadPathForIDPtr(instance_id));
	}

	/// <summary>
	/// Get the player index of a gamepad.<br/>
	/// This can be called before any gamepads are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the player index of a gamepad, or -1 if it's not available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadPlayerIndex<br/>
	/// @sa SDL_GetGamepads
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadPlayerIndexForID")]
	public static partial int SDL_GetGamepadPlayerIndexForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the implementation-dependent GUID of a gamepad.<br/>
	/// This can be called before any gamepads are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the GUID of the selected gamepad. If called on an invalid index,<br/>
	/// this function returns a zero GUID.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GUIDToString<br/>
	/// @sa SDL_GetGamepads
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadGUIDForID")]
	public static partial Guid SDL_GetGamepadGUIDForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the USB vendor ID of a gamepad, if available.<br/>
	/// This can be called before any gamepads are opened. If the vendor ID isn't<br/>
	/// available this function returns 0.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the USB vendor ID of the selected gamepad. If called on an invalid<br/>
	/// index, this function returns zero.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadVendor<br/>
	/// @sa SDL_GetGamepads
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadVendorForID")]
	public static partial ushort SDL_GetGamepadVendorForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the USB product ID of a gamepad, if available.<br/>
	/// This can be called before any gamepads are opened. If the product ID isn't<br/>
	/// available this function returns 0.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the USB product ID of the selected gamepad. If called on an<br/>
	/// invalid index, this function returns zero.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadProduct<br/>
	/// @sa SDL_GetGamepads
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadProductForID")]
	public static partial ushort SDL_GetGamepadProductForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the product version of a gamepad, if available.<br/>
	/// This can be called before any gamepads are opened. If the product version<br/>
	/// isn't available this function returns 0.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the product version of the selected gamepad. If called on an<br/>
	/// invalid index, this function returns zero.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadProductVersion<br/>
	/// @sa SDL_GetGamepads
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadProductVersionForID")]
	public static partial ushort SDL_GetGamepadProductVersionForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the type of a gamepad.<br/>
	/// This can be called before any gamepads are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the gamepad type.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadType<br/>
	/// @sa SDL_GetGamepads<br/>
	/// @sa SDL_GetRealGamepadTypeForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadTypeForID")]
	public static partial SDL_GamepadType SDL_GetGamepadTypeForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the type of a gamepad, ignoring any mapping override.<br/>
	/// This can be called before any gamepads are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the gamepad type.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadTypeForID<br/>
	/// @sa SDL_GetGamepads<br/>
	/// @sa SDL_GetRealGamepadType
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRealGamepadTypeForID")]
	public static partial SDL_GamepadType SDL_GetRealGamepadTypeForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the mapping of a gamepad.<br/>
	/// This can be called before any gamepads are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the mapping string. Returns NULL if no mapping is available. This<br/>
	/// should be freed with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepads<br/>
	/// @sa SDL_GetGamepadMapping
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadMappingForID")]
	public static partial byte* SDL_GetGamepadMappingForIDPtr(SDL_JoystickID instance_id);

	public static string? SDL_GetGamepadMappingForID(SDL_JoystickID instance_id)
	{
		byte* resultPtr = SDL_GetGamepadMappingForIDPtr(instance_id);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	/// <summary>
	/// Open a gamepad for use.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns a gamepad identifier or NULL if an error occurred; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseGamepad<br/>
	/// @sa SDL_IsGamepad
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenGamepad")]
	public static partial SDL_Gamepad SDL_OpenGamepad(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the SDL_Gamepad associated with a joystick instance ID, if it has been<br/>
	/// opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID of the gamepad.<br/>
	/// @returns an SDL_Gamepad on success or NULL on failure or if it hasn't been<br/>
	/// opened yet; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadFromID")]
	public static partial SDL_Gamepad SDL_GetGamepadFromID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the SDL_Gamepad associated with a player index.<br/>
	/// <br/>
	/// @param player_index the player index, which different from the instance ID.<br/>
	/// @returns the SDL_Gamepad associated with a player index.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadPlayerIndex<br/>
	/// @sa SDL_SetGamepadPlayerIndex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadFromPlayerIndex")]
	public static partial SDL_Gamepad SDL_GetGamepadFromPlayerIndex(int player_index);

	/// <summary>
	/// Get the properties associated with an opened gamepad.<br/>
	/// These properties are shared with the underlying joystick object.<br/>
	/// The following read-only properties are provided by SDL:<br/>
	/// - `SDL_PROP_GAMEPAD_CAP_MONO_LED_BOOLEAN`: true if this gamepad has an LED<br/>
	/// that has adjustable brightness<br/>
	/// - `SDL_PROP_GAMEPAD_CAP_RGB_LED_BOOLEAN`: true if this gamepad has an LED<br/>
	/// that has adjustable color<br/>
	/// - `SDL_PROP_GAMEPAD_CAP_PLAYER_LED_BOOLEAN`: true if this gamepad has a<br/>
	/// player LED<br/>
	/// - `SDL_PROP_GAMEPAD_CAP_RUMBLE_BOOLEAN`: true if this gamepad has<br/>
	/// left/right rumble<br/>
	/// - `SDL_PROP_GAMEPAD_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this gamepad has<br/>
	/// simple trigger rumble<br/>
	/// <br/>
	/// @param gamepad a gamepad identifier previously returned by<br/>
	/// SDL_OpenGamepad().<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadProperties")]
	public static partial SDL_PropertiesID SDL_GetGamepadProperties(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the instance ID of an opened gamepad.<br/>
	/// <br/>
	/// @param gamepad a gamepad identifier previously returned by<br/>
	/// SDL_OpenGamepad().<br/>
	/// @returns the instance ID of the specified gamepad on success or 0 on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadID")]
	public static partial SDL_JoystickID SDL_GetGamepadID(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the implementation-dependent name for an opened gamepad.<br/>
	/// <br/>
	/// @param gamepad a gamepad identifier previously returned by<br/>
	/// SDL_OpenGamepad().<br/>
	/// @returns the implementation dependent name for the gamepad, or NULL if<br/>
	/// there is no name or the identifier passed is invalid.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadNameForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadName")]
	public static partial byte* SDL_GetGamepadNamePtr(SDL_Gamepad gamepad);

	public static string? SDL_GetGamepadName(SDL_Gamepad gamepad)
	{
		return ConvertToManaged(SDL_GetGamepadNamePtr(gamepad));
	}

	/// <summary>
	/// Get the implementation-dependent path for an opened gamepad.<br/>
	/// <br/>
	/// @param gamepad a gamepad identifier previously returned by<br/>
	/// SDL_OpenGamepad().<br/>
	/// @returns the implementation dependent path for the gamepad, or NULL if<br/>
	/// there is no path or the identifier passed is invalid.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadPathForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadPath")]
	public static partial byte* SDL_GetGamepadPathPtr(SDL_Gamepad gamepad);

	public static string? SDL_GetGamepadPath(SDL_Gamepad gamepad)
	{
		return ConvertToManaged(SDL_GetGamepadPathPtr(gamepad));
	}

	/// <summary>
	/// Get the type of an opened gamepad.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @returns the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not<br/>
	/// available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadTypeForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadType")]
	public static partial SDL_GamepadType SDL_GetGamepadType(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the type of an opened gamepad, ignoring any mapping override.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @returns the gamepad type, or SDL_GAMEPAD_TYPE_UNKNOWN if it's not<br/>
	/// available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRealGamepadTypeForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRealGamepadType")]
	public static partial SDL_GamepadType SDL_GetRealGamepadType(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the player index of an opened gamepad.<br/>
	/// For XInput gamepads this returns the XInput user index.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @returns the player index for gamepad, or -1 if it's not available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetGamepadPlayerIndex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadPlayerIndex")]
	public static partial int SDL_GetGamepadPlayerIndex(SDL_Gamepad gamepad);

	/// <summary>
	/// Set the player index of an opened gamepad.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to adjust.<br/>
	/// @param player_index player index to assign to this gamepad, or -1 to clear<br/>
	/// the player index and turn off player LEDs.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadPlayerIndex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGamepadPlayerIndex")]
	public static partial SDLBool SDL_SetGamepadPlayerIndex(SDL_Gamepad gamepad, int player_index);

	/// <summary>
	/// Get the USB vendor ID of an opened gamepad, if available.<br/>
	/// If the vendor ID isn't available this function returns 0.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @returns the USB vendor ID, or zero if unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadVendorForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadVendor")]
	public static partial ushort SDL_GetGamepadVendor(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the USB product ID of an opened gamepad, if available.<br/>
	/// If the product ID isn't available this function returns 0.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @returns the USB product ID, or zero if unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadProductForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadProduct")]
	public static partial ushort SDL_GetGamepadProduct(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the product version of an opened gamepad, if available.<br/>
	/// If the product version isn't available this function returns 0.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @returns the USB product version, or zero if unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadProductVersionForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadProductVersion")]
	public static partial ushort SDL_GetGamepadProductVersion(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the firmware version of an opened gamepad, if available.<br/>
	/// If the firmware version isn't available this function returns 0.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @returns the gamepad firmware version, or zero if unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadFirmwareVersion")]
	public static partial ushort SDL_GetGamepadFirmwareVersion(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the serial number of an opened gamepad, if available.<br/>
	/// Returns the serial number of the gamepad, or NULL if it is not available.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @returns the serial number, or NULL if unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadSerial")]
	public static partial byte* SDL_GetGamepadSerialPtr(SDL_Gamepad gamepad);

	public static string? SDL_GetGamepadSerial(SDL_Gamepad gamepad)
	{
		return ConvertToManaged(SDL_GetGamepadSerialPtr(gamepad));
	}

	/// <summary>
	/// Get the Steam Input handle of an opened gamepad, if available.<br/>
	/// Returns an InputHandle_t for the gamepad that can be used with Steam Input<br/>
	/// API: https://partner.steamgames.com/doc/api/ISteamInput<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @returns the gamepad handle, or 0 if unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadSteamHandle")]
	public static partial ulong SDL_GetGamepadSteamHandle(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the connection state of a gamepad.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @returns the connection state on success or<br/>
	/// `SDL_JOYSTICK_CONNECTION_INVALID` on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadConnectionState")]
	public static partial SDL_JoystickConnectionState SDL_GetGamepadConnectionState(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the battery state of a gamepad.<br/>
	/// You should never take a battery status as absolute truth. Batteries<br/>
	/// (especially failing batteries) are delicate hardware, and the values<br/>
	/// reported here are best estimates based on what that hardware reports. It's<br/>
	/// not uncommon for older batteries to lose stored power much faster than it<br/>
	/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
	/// <br/>
	/// @param gamepad the gamepad object to query.<br/>
	/// @param percent a pointer filled in with the percentage of battery life<br/>
	/// left, between 0 and 100, or NULL to ignore. This will be<br/>
	/// filled in with -1 we can't determine a value or there is no<br/>
	/// battery.<br/>
	/// @returns the current battery state.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadPowerInfo")]
	public static partial SDL_PowerState SDL_GetGamepadPowerInfo(SDL_Gamepad gamepad, int* percent);

	/// <summary>
	/// Check if a gamepad has been opened and is currently connected.<br/>
	/// <br/>
	/// @param gamepad a gamepad identifier previously returned by<br/>
	/// SDL_OpenGamepad().<br/>
	/// @returns true if the gamepad has been opened and is currently connected, or<br/>
	/// false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GamepadConnected")]
	public static partial SDLBool SDL_GamepadConnected(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the underlying joystick from a gamepad.<br/>
	/// This function will give you a SDL_Joystick object, which allows you to use<br/>
	/// the SDL_Joystick functions with a SDL_Gamepad object. This would be useful<br/>
	/// for getting a joystick's position at any given time, even if it hasn't<br/>
	/// moved (moving it would produce an event, which would have the axis' value).<br/>
	/// The pointer returned is owned by the SDL_Gamepad. You should not call<br/>
	/// SDL_CloseJoystick() on it, for example, since doing so will likely cause<br/>
	/// SDL to crash.<br/>
	/// <br/>
	/// @param gamepad the gamepad object that you want to get a joystick from.<br/>
	/// @returns an SDL_Joystick object, or NULL on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadJoystick")]
	public static partial SDL_Joystick SDL_GetGamepadJoystick(SDL_Gamepad gamepad);

	/// <summary>
	/// Set the state of gamepad event processing.<br/>
	/// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself<br/>
	/// and check the state of the gamepad when you want gamepad information.<br/>
	/// <br/>
	/// @param enabled whether to process gamepad events or not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GamepadEventsEnabled<br/>
	/// @sa SDL_UpdateGamepads
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGamepadEventsEnabled")]
	public static partial void SDL_SetGamepadEventsEnabled(SDLBool enabled);

	/// <summary>
	/// Query the state of gamepad event processing.<br/>
	/// If gamepad events are disabled, you must call SDL_UpdateGamepads() yourself<br/>
	/// and check the state of the gamepad when you want gamepad information.<br/>
	/// <br/>
	/// @returns true if gamepad events are being processed, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetGamepadEventsEnabled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GamepadEventsEnabled")]
	public static partial SDLBool SDL_GamepadEventsEnabled();

	/// <summary>
	/// Get the SDL joystick layer bindings for a gamepad.<br/>
	/// <br/>
	/// @param gamepad a gamepad.<br/>
	/// @param count a pointer filled in with the number of bindings returned.<br/>
	/// @returns a NULL terminated array of pointers to bindings or NULL on<br/>
	/// failure; call SDL_GetError() for more information. This is a<br/>
	/// single allocation that should be freed with SDL_free() when it is<br/>
	/// no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadBindings")]
	public static partial SDL_GamepadBinding** SDL_GetGamepadBindings(SDL_Gamepad gamepad, out int count);

	/// <summary>
	/// Manually pump gamepad updates if not using the loop.<br/>
	/// This function is called automatically by the event loop if events are<br/>
	/// enabled. Under such circumstances, it will not be necessary to call this<br/>
	/// function.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UpdateGamepads")]
	public static partial void SDL_UpdateGamepads();

	/// <summary>
	/// Convert a string into SDL_GamepadType enum.<br/>
	/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
	/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
	/// You do not normally need to call this function unless you are parsing<br/>
	/// SDL_Gamepad mappings in your own code.<br/>
	/// <br/>
	/// @param str string representing a SDL_GamepadType type.<br/>
	/// @returns the SDL_GamepadType enum corresponding to the input string, or<br/>
	/// `SDL_GAMEPAD_TYPE_UNKNOWN` if no match was found.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadStringForType
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadTypeFromString")]
	public static partial SDL_GamepadType SDL_GetGamepadTypeFromString(byte* str);

	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadTypeFromString")]
	public static partial SDL_GamepadType SDL_GetGamepadTypeFromString(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadTypeFromString")]
	public static partial SDL_GamepadType SDL_GetGamepadTypeFromString([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	/// <summary>
	/// Convert from an SDL_GamepadType enum to a string.<br/>
	/// <br/>
	/// @param type an enum value for a given SDL_GamepadType.<br/>
	/// @returns a string for the given type, or NULL if an invalid type is<br/>
	/// specified. The string returned is of the format used by<br/>
	/// SDL_Gamepad mapping strings.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadTypeFromString
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadStringForType")]
	public static partial byte* SDL_GetGamepadStringForTypePtr(SDL_GamepadType type);

	public static string? SDL_GetGamepadStringForType(SDL_GamepadType type)
	{
		return ConvertToManaged(SDL_GetGamepadStringForTypePtr(type));
	}

	/// <summary>
	/// Convert a string into SDL_GamepadAxis enum.<br/>
	/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
	/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
	/// You do not normally need to call this function unless you are parsing<br/>
	/// SDL_Gamepad mappings in your own code.<br/>
	/// Note specially that "righttrigger" and "lefttrigger" map to<br/>
	/// `SDL_GAMEPAD_AXIS_RIGHT_TRIGGER` and `SDL_GAMEPAD_AXIS_LEFT_TRIGGER`,<br/>
	/// respectively.<br/>
	/// <br/>
	/// @param str string representing a SDL_Gamepad axis.<br/>
	/// @returns the SDL_GamepadAxis enum corresponding to the input string, or<br/>
	/// `SDL_GAMEPAD_AXIS_INVALID` if no match was found.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadStringForAxis
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadAxisFromString")]
	public static partial SDL_GamepadAxis SDL_GetGamepadAxisFromString(byte* str);

	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadAxisFromString")]
	public static partial SDL_GamepadAxis SDL_GetGamepadAxisFromString(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadAxisFromString")]
	public static partial SDL_GamepadAxis SDL_GetGamepadAxisFromString([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	/// <summary>
	/// Convert from an SDL_GamepadAxis enum to a string.<br/>
	/// <br/>
	/// @param axis an enum value for a given SDL_GamepadAxis.<br/>
	/// @returns a string for the given axis, or NULL if an invalid axis is<br/>
	/// specified. The string returned is of the format used by<br/>
	/// SDL_Gamepad mapping strings.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadAxisFromString
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadStringForAxis")]
	public static partial byte* SDL_GetGamepadStringForAxisPtr(SDL_GamepadAxis axis);

	public static string? SDL_GetGamepadStringForAxis(SDL_GamepadAxis axis)
	{
		return ConvertToManaged(SDL_GetGamepadStringForAxisPtr(axis));
	}

	/// <summary>
	/// Query whether a gamepad has a given axis.<br/>
	/// This merely reports whether the gamepad's mapping defined this axis, as<br/>
	/// that is all the information SDL has about the physical device.<br/>
	/// <br/>
	/// @param gamepad a gamepad.<br/>
	/// @param axis an axis enum value (an SDL_GamepadAxis value).<br/>
	/// @returns true if the gamepad has this axis, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GamepadHasButton<br/>
	/// @sa SDL_GetGamepadAxis
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GamepadHasAxis")]
	public static partial SDLBool SDL_GamepadHasAxis(SDL_Gamepad gamepad, SDL_GamepadAxis axis);

	/// <summary>
	/// Get the current state of an axis control on a gamepad.<br/>
	/// The axis indices start at index 0.<br/>
	/// For thumbsticks, the state is a value ranging from -32768 (up/left) to<br/>
	/// 32767 (down/right).<br/>
	/// Triggers range from 0 when released to 32767 when fully pressed, and never<br/>
	/// return a negative value. Note that this differs from the value reported by<br/>
	/// the lower-level SDL_GetJoystickAxis(), which normally uses the full range.<br/>
	/// <br/>
	/// @param gamepad a gamepad.<br/>
	/// @param axis an axis index (one of the SDL_GamepadAxis values).<br/>
	/// @returns axis state (including 0) on success or 0 (also) on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GamepadHasAxis<br/>
	/// @sa SDL_GetGamepadButton
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadAxis")]
	public static partial short SDL_GetGamepadAxis(SDL_Gamepad gamepad, SDL_GamepadAxis axis);

	/// <summary>
	/// Convert a string into an SDL_GamepadButton enum.<br/>
	/// This function is called internally to translate SDL_Gamepad mapping strings<br/>
	/// for the underlying joystick device into the consistent SDL_Gamepad mapping.<br/>
	/// You do not normally need to call this function unless you are parsing<br/>
	/// SDL_Gamepad mappings in your own code.<br/>
	/// <br/>
	/// @param str string representing a SDL_Gamepad axis.<br/>
	/// @returns the SDL_GamepadButton enum corresponding to the input string, or<br/>
	/// `SDL_GAMEPAD_BUTTON_INVALID` if no match was found.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadStringForButton
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadButtonFromString")]
	public static partial SDL_GamepadButton SDL_GetGamepadButtonFromString(byte* str);

	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadButtonFromString")]
	public static partial SDL_GamepadButton SDL_GetGamepadButtonFromString(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadButtonFromString")]
	public static partial SDL_GamepadButton SDL_GetGamepadButtonFromString([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	/// <summary>
	/// Convert from an SDL_GamepadButton enum to a string.<br/>
	/// <br/>
	/// @param button an enum value for a given SDL_GamepadButton.<br/>
	/// @returns a string for the given button, or NULL if an invalid button is<br/>
	/// specified. The string returned is of the format used by<br/>
	/// SDL_Gamepad mapping strings.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadButtonFromString
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadStringForButton")]
	public static partial byte* SDL_GetGamepadStringForButtonPtr(SDL_GamepadButton button);

	public static string? SDL_GetGamepadStringForButton(SDL_GamepadButton button)
	{
		return ConvertToManaged(SDL_GetGamepadStringForButtonPtr(button));
	}

	/// <summary>
	/// Query whether a gamepad has a given button.<br/>
	/// This merely reports whether the gamepad's mapping defined this button, as<br/>
	/// that is all the information SDL has about the physical device.<br/>
	/// <br/>
	/// @param gamepad a gamepad.<br/>
	/// @param button a button enum value (an SDL_GamepadButton value).<br/>
	/// @returns true if the gamepad has this button, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GamepadHasAxis
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GamepadHasButton")]
	public static partial SDLBool SDL_GamepadHasButton(SDL_Gamepad gamepad, SDL_GamepadButton button);

	/// <summary>
	/// Get the current state of a button on a gamepad.<br/>
	/// <br/>
	/// @param gamepad a gamepad.<br/>
	/// @param button a button index (one of the SDL_GamepadButton values).<br/>
	/// @returns true if the button is pressed, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GamepadHasButton<br/>
	/// @sa SDL_GetGamepadAxis
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadButton")]
	public static partial SDLBool SDL_GetGamepadButton(SDL_Gamepad gamepad, SDL_GamepadButton button);

	/// <summary>
	/// Get the label of a button on a gamepad.<br/>
	/// <br/>
	/// @param type the type of gamepad to check.<br/>
	/// @param button a button index (one of the SDL_GamepadButton values).<br/>
	/// @returns the SDL_GamepadButtonLabel enum corresponding to the button label.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadButtonLabel
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadButtonLabelForType")]
	public static partial SDL_GamepadButtonLabel SDL_GetGamepadButtonLabelForType(SDL_GamepadType type, SDL_GamepadButton button);

	/// <summary>
	/// Get the label of a button on a gamepad.<br/>
	/// <br/>
	/// @param gamepad a gamepad.<br/>
	/// @param button a button index (one of the SDL_GamepadButton values).<br/>
	/// @returns the SDL_GamepadButtonLabel enum corresponding to the button label.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadButtonLabelForType
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadButtonLabel")]
	public static partial SDL_GamepadButtonLabel SDL_GetGamepadButtonLabel(SDL_Gamepad gamepad, SDL_GamepadButton button);

	/// <summary>
	/// Get the number of touchpads on a gamepad.<br/>
	/// <br/>
	/// @param gamepad a gamepad.<br/>
	/// @returns number of touchpads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumGamepadTouchpadFingers
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumGamepadTouchpads")]
	public static partial int SDL_GetNumGamepadTouchpads(SDL_Gamepad gamepad);

	/// <summary>
	/// Get the number of supported simultaneous fingers on a touchpad on a game<br/>
	/// gamepad.<br/>
	/// <br/>
	/// @param gamepad a gamepad.<br/>
	/// @param touchpad a touchpad.<br/>
	/// @returns number of supported simultaneous fingers.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadTouchpadFinger<br/>
	/// @sa SDL_GetNumGamepadTouchpads
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumGamepadTouchpadFingers")]
	public static partial int SDL_GetNumGamepadTouchpadFingers(SDL_Gamepad gamepad, int touchpad);

	/// <summary>
	/// Get the current state of a finger on a touchpad on a gamepad.<br/>
	/// <br/>
	/// @param gamepad a gamepad.<br/>
	/// @param touchpad a touchpad.<br/>
	/// @param finger a finger.<br/>
	/// @param down a pointer filled with true if the finger is down, false<br/>
	/// otherwise, may be NULL.<br/>
	/// @param x a pointer filled with the x position, normalized 0 to 1, with the<br/>
	/// origin in the upper left, may be NULL.<br/>
	/// @param y a pointer filled with the y position, normalized 0 to 1, with the<br/>
	/// origin in the upper left, may be NULL.<br/>
	/// @param pressure a pointer filled with pressure value, may be NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumGamepadTouchpadFingers
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadTouchpadFinger")]
	public static partial SDLBool SDL_GetGamepadTouchpadFinger(SDL_Gamepad gamepad, int touchpad, int finger, SDLBool* down, float* x, float* y, float* pressure);

	/// <summary>
	/// Return whether a gamepad has a particular sensor.<br/>
	/// <br/>
	/// @param gamepad the gamepad to query.<br/>
	/// @param type the type of sensor to query.<br/>
	/// @returns true if the sensor exists, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadSensorData<br/>
	/// @sa SDL_GetGamepadSensorDataRate<br/>
	/// @sa SDL_SetGamepadSensorEnabled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GamepadHasSensor")]
	public static partial SDLBool SDL_GamepadHasSensor(SDL_Gamepad gamepad, SDL_SensorType type);

	/// <summary>
	/// Set whether data reporting for a gamepad sensor is enabled.<br/>
	/// <br/>
	/// @param gamepad the gamepad to update.<br/>
	/// @param type the type of sensor to enable/disable.<br/>
	/// @param enabled whether data reporting should be enabled.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GamepadHasSensor<br/>
	/// @sa SDL_GamepadSensorEnabled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGamepadSensorEnabled")]
	public static partial SDLBool SDL_SetGamepadSensorEnabled(SDL_Gamepad gamepad, SDL_SensorType type, SDLBool enabled);

	/// <summary>
	/// Query whether sensor data reporting is enabled for a gamepad.<br/>
	/// <br/>
	/// @param gamepad the gamepad to query.<br/>
	/// @param type the type of sensor to query.<br/>
	/// @returns true if the sensor is enabled, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetGamepadSensorEnabled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GamepadSensorEnabled")]
	public static partial SDLBool SDL_GamepadSensorEnabled(SDL_Gamepad gamepad, SDL_SensorType type);

	/// <summary>
	/// Get the data rate (number of events per second) of a gamepad sensor.<br/>
	/// <br/>
	/// @param gamepad the gamepad to query.<br/>
	/// @param type the type of sensor to query.<br/>
	/// @returns the data rate, or 0.0f if the data rate is not available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadSensorDataRate")]
	public static partial float SDL_GetGamepadSensorDataRate(SDL_Gamepad gamepad, SDL_SensorType type);

	/// <summary>
	/// Get the current state of a gamepad sensor.<br/>
	/// The number of values and interpretation of the data is sensor dependent.<br/>
	/// See SDL_sensor.h for the details for each type of sensor.<br/>
	/// <br/>
	/// @param gamepad the gamepad to query.<br/>
	/// @param type the type of sensor to query.<br/>
	/// @param data a pointer filled with the current sensor state.<br/>
	/// @param num_values the number of values to write to data.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadSensorData")]
	public static partial SDLBool SDL_GetGamepadSensorData(SDL_Gamepad gamepad, SDL_SensorType type, float* data, int num_values);

	/// <summary>
	/// Start a rumble effect on a gamepad.<br/>
	/// Each call to this function cancels any previous rumble effect, and calling<br/>
	/// it with 0 intensity stops any rumbling.<br/>
	/// This function requires you to process SDL events or call<br/>
	/// SDL_UpdateJoysticks() to update rumble state.<br/>
	/// <br/>
	/// @param gamepad the gamepad to vibrate.<br/>
	/// @param low_frequency_rumble the intensity of the low frequency (left)<br/>
	/// rumble motor, from 0 to 0xFFFF.<br/>
	/// @param high_frequency_rumble the intensity of the high frequency (right)<br/>
	/// rumble motor, from 0 to 0xFFFF.<br/>
	/// @param duration_ms the duration of the rumble effect, in milliseconds.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RumbleGamepad")]
	public static partial SDLBool SDL_RumbleGamepad(SDL_Gamepad gamepad, ushort low_frequency_rumble, ushort high_frequency_rumble, uint duration_ms);

	/// <summary>
	/// Start a rumble effect in the gamepad's triggers.<br/>
	/// Each call to this function cancels any previous trigger rumble effect, and<br/>
	/// calling it with 0 intensity stops any rumbling.<br/>
	/// Note that this is rumbling of the _triggers_ and not the gamepad as a<br/>
	/// whole. This is currently only supported on Xbox One gamepads. If you want<br/>
	/// the (more common) whole-gamepad rumble, use SDL_RumbleGamepad() instead.<br/>
	/// This function requires you to process SDL events or call<br/>
	/// SDL_UpdateJoysticks() to update rumble state.<br/>
	/// <br/>
	/// @param gamepad the gamepad to vibrate.<br/>
	/// @param left_rumble the intensity of the left trigger rumble motor, from 0<br/>
	/// to 0xFFFF.<br/>
	/// @param right_rumble the intensity of the right trigger rumble motor, from 0<br/>
	/// to 0xFFFF.<br/>
	/// @param duration_ms the duration of the rumble effect, in milliseconds.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RumbleGamepad
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RumbleGamepadTriggers")]
	public static partial SDLBool SDL_RumbleGamepadTriggers(SDL_Gamepad gamepad, ushort left_rumble, ushort right_rumble, uint duration_ms);

	/// <summary>
	/// Update a gamepad's LED color.<br/>
	/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
	/// DualShock 4 controller.<br/>
	/// For gamepads with a single color LED, the maximum of the RGB values will be<br/>
	/// used as the LED brightness.<br/>
	/// <br/>
	/// @param gamepad the gamepad to update.<br/>
	/// @param red the intensity of the red LED.<br/>
	/// @param green the intensity of the green LED.<br/>
	/// @param blue the intensity of the blue LED.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGamepadLED")]
	public static partial SDLBool SDL_SetGamepadLED(SDL_Gamepad gamepad, byte red, byte green, byte blue);

	/// <summary>
	/// Send a gamepad specific effect packet.<br/>
	/// <br/>
	/// @param gamepad the gamepad to affect.<br/>
	/// @param data the data to send to the gamepad.<br/>
	/// @param size the size of the data to send to the gamepad.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SendGamepadEffect")]
	public static partial SDLBool SDL_SendGamepadEffect(SDL_Gamepad gamepad, nint data, int size);

	/// <summary>
	/// Close a gamepad previously opened with SDL_OpenGamepad().<br/>
	/// <br/>
	/// @param gamepad a gamepad identifier previously returned by<br/>
	/// SDL_OpenGamepad().<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenGamepad
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CloseGamepad")]
	public static partial void SDL_CloseGamepad(SDL_Gamepad gamepad);

	/// <summary>
	/// Return the sfSymbolsName for a given button on a gamepad on Apple<br/>
	/// platforms.<br/>
	/// <br/>
	/// @param gamepad the gamepad to query.<br/>
	/// @param button a button on the gamepad.<br/>
	/// @returns the sfSymbolsName or NULL if the name can't be found.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadAppleSFSymbolsNameForAxis
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadAppleSFSymbolsNameForButton")]
	public static partial byte* SDL_GetGamepadAppleSFSymbolsNameForButtonPtr(SDL_Gamepad gamepad, SDL_GamepadButton button);

	public static string? SDL_GetGamepadAppleSFSymbolsNameForButton(SDL_Gamepad gamepad, SDL_GamepadButton button)
	{
		return ConvertToManaged(SDL_GetGamepadAppleSFSymbolsNameForButtonPtr(gamepad, button));
	}

	/// <summary>
	/// Return the sfSymbolsName for a given axis on a gamepad on Apple platforms.<br/>
	/// <br/>
	/// @param gamepad the gamepad to query.<br/>
	/// @param axis an axis on the gamepad.<br/>
	/// @returns the sfSymbolsName or NULL if the name can't be found.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGamepadAppleSFSymbolsNameForButton
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGamepadAppleSFSymbolsNameForAxis")]
	public static partial byte* SDL_GetGamepadAppleSFSymbolsNameForAxisPtr(SDL_Gamepad gamepad, SDL_GamepadAxis axis);

	public static string? SDL_GetGamepadAppleSFSymbolsNameForAxis(SDL_Gamepad gamepad, SDL_GamepadAxis axis)
	{
		return ConvertToManaged(SDL_GetGamepadAppleSFSymbolsNameForAxisPtr(gamepad, axis));
	}

	/// <summary>
	/// Convert a GUID string into a SDL_GUID structure.<br/>
	/// Performs no error checking. If this function is given a string containing<br/>
	/// an invalid GUID, the function will silently succeed, but the GUID generated<br/>
	/// will not be useful.<br/>
	/// <br/>
	/// @param pchGUID string containing an ASCII representation of a GUID.<br/>
	/// @returns a SDL_GUID structure.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GUIDToString
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_StringToGUID")]
	public static partial Guid SDL_StringToGUID(byte* pchGUID);

	[LibraryImport(LibName, EntryPoint = "SDL_StringToGUID")]
	public static partial Guid SDL_StringToGUID(ReadOnlySpan<byte> pchGUID);

	[LibraryImport(LibName, EntryPoint = "SDL_StringToGUID")]
	public static partial Guid SDL_StringToGUID([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> pchGUID);

	/// <summary>
	/// Get a list of currently connected haptic devices.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of haptic devices<br/>
	/// returned, may be NULL.<br/>
	/// @returns a 0 terminated array of haptic device instance IDs or NULL on<br/>
	/// failure; call SDL_GetError() for more information. This should be<br/>
	/// freed with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenHaptic
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetHaptics")]
	public static partial SDL_HapticID* SDL_GetHaptics(out int count);

	/// <summary>
	/// Get the implementation dependent name of a haptic device.<br/>
	/// This can be called before any haptic devices are opened.<br/>
	/// <br/>
	/// @param instance_id the haptic device instance ID.<br/>
	/// @returns the name of the selected haptic device. If no name can be found,<br/>
	/// this function returns NULL; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetHapticName<br/>
	/// @sa SDL_OpenHaptic
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetHapticNameForID")]
	public static partial byte* SDL_GetHapticNameForIDPtr(SDL_HapticID instance_id);

	public static string? SDL_GetHapticNameForID(SDL_HapticID instance_id)
	{
		return ConvertToManaged(SDL_GetHapticNameForIDPtr(instance_id));
	}

	/// <summary>
	/// Open a haptic device for use.<br/>
	/// The index passed as an argument refers to the N'th haptic device on this<br/>
	/// system.<br/>
	/// When opening a haptic device, its gain will be set to maximum and<br/>
	/// autocenter will be disabled. To modify these values use SDL_SetHapticGain()<br/>
	/// and SDL_SetHapticAutocenter().<br/>
	/// <br/>
	/// @param instance_id the haptic device instance ID.<br/>
	/// @returns the device identifier or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseHaptic<br/>
	/// @sa SDL_GetHaptics<br/>
	/// @sa SDL_OpenHapticFromJoystick<br/>
	/// @sa SDL_OpenHapticFromMouse<br/>
	/// @sa SDL_SetHapticAutocenter<br/>
	/// @sa SDL_SetHapticGain
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenHaptic")]
	public static partial SDL_Haptic SDL_OpenHaptic(SDL_HapticID instance_id);

	/// <summary>
	/// Get the SDL_Haptic associated with an instance ID, if it has been opened.<br/>
	/// <br/>
	/// @param instance_id the instance ID to get the SDL_Haptic for.<br/>
	/// @returns an SDL_Haptic on success or NULL on failure or if it hasn't been<br/>
	/// opened yet; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetHapticFromID")]
	public static partial SDL_Haptic SDL_GetHapticFromID(SDL_HapticID instance_id);

	/// <summary>
	/// Get the instance ID of an opened haptic device.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to query.<br/>
	/// @returns the instance ID of the specified haptic device on success or 0 on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetHapticID")]
	public static partial SDL_HapticID SDL_GetHapticID(SDL_Haptic haptic);

	/// <summary>
	/// Get the implementation dependent name of a haptic device.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic obtained from SDL_OpenJoystick().<br/>
	/// @returns the name of the selected haptic device. If no name can be found,<br/>
	/// this function returns NULL; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetHapticNameForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetHapticName")]
	public static partial byte* SDL_GetHapticNamePtr(SDL_Haptic haptic);

	public static string? SDL_GetHapticName(SDL_Haptic haptic)
	{
		return ConvertToManaged(SDL_GetHapticNamePtr(haptic));
	}

	/// <summary>
	/// Query whether or not the current mouse has haptic capabilities.<br/>
	/// <br/>
	/// @returns true if the mouse is haptic or false if it isn't.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenHapticFromMouse
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IsMouseHaptic")]
	public static partial SDLBool SDL_IsMouseHaptic();

	/// <summary>
	/// Try to open a haptic device from the current mouse.<br/>
	/// <br/>
	/// @returns the haptic device identifier or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseHaptic<br/>
	/// @sa SDL_IsMouseHaptic
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenHapticFromMouse")]
	public static partial SDL_Haptic SDL_OpenHapticFromMouse();

	/// <summary>
	/// Query if a joystick has haptic features.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick to test for haptic capabilities.<br/>
	/// @returns true if the joystick is haptic or false if it isn't.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenHapticFromJoystick
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IsJoystickHaptic")]
	public static partial SDLBool SDL_IsJoystickHaptic(SDL_Joystick joystick);

	/// <summary>
	/// Open a haptic device for use from a joystick device.<br/>
	/// You must still close the haptic device separately. It will not be closed<br/>
	/// with the joystick.<br/>
	/// When opened from a joystick you should first close the haptic device before<br/>
	/// closing the joystick device. If not, on some implementations the haptic<br/>
	/// device will also get unallocated and you'll be unable to use force feedback<br/>
	/// on that device.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick to create a haptic device from.<br/>
	/// @returns a valid haptic device identifier on success or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseHaptic<br/>
	/// @sa SDL_IsJoystickHaptic
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenHapticFromJoystick")]
	public static partial SDL_Haptic SDL_OpenHapticFromJoystick(SDL_Joystick joystick);

	/// <summary>
	/// Close a haptic device previously opened with SDL_OpenHaptic().<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to close.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenHaptic
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CloseHaptic")]
	public static partial void SDL_CloseHaptic(SDL_Haptic haptic);

	/// <summary>
	/// Get the number of effects a haptic device can store.<br/>
	/// On some platforms this isn't fully supported, and therefore is an<br/>
	/// approximation. Always check to see if your created effect was actually<br/>
	/// created and do not rely solely on SDL_GetMaxHapticEffects().<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to query.<br/>
	/// @returns the number of effects the haptic device can store or a negative<br/>
	/// error code on failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetMaxHapticEffectsPlaying<br/>
	/// @sa SDL_GetHapticFeatures
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetMaxHapticEffects")]
	public static partial int SDL_GetMaxHapticEffects(SDL_Haptic haptic);

	/// <summary>
	/// Get the number of effects a haptic device can play at the same time.<br/>
	/// This is not supported on all platforms, but will always return a value.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to query maximum playing effects.<br/>
	/// @returns the number of effects the haptic device can play at the same time<br/>
	/// or -1 on failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetMaxHapticEffects<br/>
	/// @sa SDL_GetHapticFeatures
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetMaxHapticEffectsPlaying")]
	public static partial int SDL_GetMaxHapticEffectsPlaying(SDL_Haptic haptic);

	/// <summary>
	/// Get the haptic device's supported features in bitwise manner.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to query.<br/>
	/// @returns a list of supported haptic features in bitwise manner (OR'd), or 0<br/>
	/// on failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HapticEffectSupported<br/>
	/// @sa SDL_GetMaxHapticEffects
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetHapticFeatures")]
	public static partial uint SDL_GetHapticFeatures(SDL_Haptic haptic);

	/// <summary>
	/// Get the number of haptic axes the device has.<br/>
	/// The number of haptic axes might be useful if working with the<br/>
	/// SDL_HapticDirection effect.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to query.<br/>
	/// @returns the number of axes on success or -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumHapticAxes")]
	public static partial int SDL_GetNumHapticAxes(SDL_Haptic haptic);

	/// <summary>
	/// Check to see if an effect is supported by a haptic device.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to query.<br/>
	/// @param effect the desired effect to query.<br/>
	/// @returns true if the effect is supported or false if it isn't.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateHapticEffect<br/>
	/// @sa SDL_GetHapticFeatures
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HapticEffectSupported")]
	public static partial SDLBool SDL_HapticEffectSupported(SDL_Haptic haptic, SDL_HapticEffect* effect);

	/// <summary>
	/// Create a new haptic effect on a specified device.<br/>
	/// <br/>
	/// @param haptic an SDL_Haptic device to create the effect on.<br/>
	/// @param effect an SDL_HapticEffect structure containing the properties of<br/>
	/// the effect to create.<br/>
	/// @returns the ID of the effect on success or -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroyHapticEffect<br/>
	/// @sa SDL_RunHapticEffect<br/>
	/// @sa SDL_UpdateHapticEffect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateHapticEffect")]
	public static partial int SDL_CreateHapticEffect(SDL_Haptic haptic, SDL_HapticEffect* effect);

	/// <summary>
	/// Update the properties of an effect.<br/>
	/// Can be used dynamically, although behavior when dynamically changing<br/>
	/// direction may be strange. Specifically the effect may re-upload itself and<br/>
	/// start playing from the start. You also cannot change the type either when<br/>
	/// running SDL_UpdateHapticEffect().<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device that has the effect.<br/>
	/// @param effect the identifier of the effect to update.<br/>
	/// @param data an SDL_HapticEffect structure containing the new effect<br/>
	/// properties to use.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateHapticEffect<br/>
	/// @sa SDL_RunHapticEffect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UpdateHapticEffect")]
	public static partial SDLBool SDL_UpdateHapticEffect(SDL_Haptic haptic, int effect, SDL_HapticEffect* data);

	/// <summary>
	/// Run the haptic effect on its associated haptic device.<br/>
	/// To repeat the effect over and over indefinitely, set `iterations` to<br/>
	/// `SDL_HAPTIC_INFINITY`. (Repeats the envelope - attack and fade.) To make<br/>
	/// one instance of the effect last indefinitely (so the effect does not fade),<br/>
	/// set the effect's `length` in its structure/union to `SDL_HAPTIC_INFINITY`<br/>
	/// instead.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to run the effect on.<br/>
	/// @param effect the ID of the haptic effect to run.<br/>
	/// @param iterations the number of iterations to run the effect; use<br/>
	/// `SDL_HAPTIC_INFINITY` to repeat forever.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetHapticEffectStatus<br/>
	/// @sa SDL_StopHapticEffect<br/>
	/// @sa SDL_StopHapticEffects
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RunHapticEffect")]
	public static partial SDLBool SDL_RunHapticEffect(SDL_Haptic haptic, int effect, uint iterations);

	/// <summary>
	/// Stop the haptic effect on its associated haptic device.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to stop the effect on.<br/>
	/// @param effect the ID of the haptic effect to stop.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RunHapticEffect<br/>
	/// @sa SDL_StopHapticEffects
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_StopHapticEffect")]
	public static partial SDLBool SDL_StopHapticEffect(SDL_Haptic haptic, int effect);

	/// <summary>
	/// Destroy a haptic effect on the device.<br/>
	/// This will stop the effect if it's running. Effects are automatically<br/>
	/// destroyed when the device is closed.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to destroy the effect on.<br/>
	/// @param effect the ID of the haptic effect to destroy.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateHapticEffect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyHapticEffect")]
	public static partial void SDL_DestroyHapticEffect(SDL_Haptic haptic, int effect);

	/// <summary>
	/// Get the status of the current effect on the specified haptic device.<br/>
	/// Device must support the SDL_HAPTIC_STATUS feature.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to query for the effect status on.<br/>
	/// @param effect the ID of the haptic effect to query its status.<br/>
	/// @returns true if it is playing, false if it isn't playing or haptic status<br/>
	/// isn't supported.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetHapticFeatures
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetHapticEffectStatus")]
	public static partial SDLBool SDL_GetHapticEffectStatus(SDL_Haptic haptic, int effect);

	/// <summary>
	/// Set the global gain of the specified haptic device.<br/>
	/// Device must support the SDL_HAPTIC_GAIN feature.<br/>
	/// The user may specify the maximum gain by setting the environment variable<br/>
	/// `SDL_HAPTIC_GAIN_MAX` which should be between 0 and 100. All calls to<br/>
	/// SDL_SetHapticGain() will scale linearly using `SDL_HAPTIC_GAIN_MAX` as the<br/>
	/// maximum.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to set the gain on.<br/>
	/// @param gain value to set the gain to, should be between 0 and 100 (0 -<br/>
	/// 100).<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetHapticFeatures
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetHapticGain")]
	public static partial SDLBool SDL_SetHapticGain(SDL_Haptic haptic, int gain);

	/// <summary>
	/// Set the global autocenter of the device.<br/>
	/// Autocenter should be between 0 and 100. Setting it to 0 will disable<br/>
	/// autocentering.<br/>
	/// Device must support the SDL_HAPTIC_AUTOCENTER feature.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to set autocentering on.<br/>
	/// @param autocenter value to set autocenter to (0-100).<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetHapticFeatures
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetHapticAutocenter")]
	public static partial SDLBool SDL_SetHapticAutocenter(SDL_Haptic haptic, int autocenter);

	/// <summary>
	/// Pause a haptic device.<br/>
	/// Device must support the `SDL_HAPTIC_PAUSE` feature. Call SDL_ResumeHaptic()<br/>
	/// to resume playback.<br/>
	/// Do not modify the effects nor add new ones while the device is paused. That<br/>
	/// can cause all sorts of weird errors.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to pause.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ResumeHaptic
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PauseHaptic")]
	public static partial SDLBool SDL_PauseHaptic(SDL_Haptic haptic);

	/// <summary>
	/// Resume a haptic device.<br/>
	/// Call to unpause after SDL_PauseHaptic().<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to unpause.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PauseHaptic
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ResumeHaptic")]
	public static partial SDLBool SDL_ResumeHaptic(SDL_Haptic haptic);

	/// <summary>
	/// Stop all the currently playing effects on a haptic device.<br/>
	/// <br/>
	/// @param haptic the SDL_Haptic device to stop.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RunHapticEffect<br/>
	/// @sa SDL_StopHapticEffects
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_StopHapticEffects")]
	public static partial SDLBool SDL_StopHapticEffects(SDL_Haptic haptic);

	/// <summary>
	/// Check whether rumble is supported on a haptic device.<br/>
	/// <br/>
	/// @param haptic haptic device to check for rumble support.<br/>
	/// @returns true if the effect is supported or false if it isn't.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_InitHapticRumble
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HapticRumbleSupported")]
	public static partial SDLBool SDL_HapticRumbleSupported(SDL_Haptic haptic);

	/// <summary>
	/// Initialize a haptic device for simple rumble playback.<br/>
	/// <br/>
	/// @param haptic the haptic device to initialize for simple rumble playback.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PlayHapticRumble<br/>
	/// @sa SDL_StopHapticRumble<br/>
	/// @sa SDL_HapticRumbleSupported
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_InitHapticRumble")]
	public static partial SDLBool SDL_InitHapticRumble(SDL_Haptic haptic);

	/// <summary>
	/// Run a simple rumble effect on a haptic device.<br/>
	/// <br/>
	/// @param haptic the haptic device to play the rumble effect on.<br/>
	/// @param strength strength of the rumble to play as a 0-1 float value.<br/>
	/// @param length length of the rumble to play in milliseconds.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_InitHapticRumble<br/>
	/// @sa SDL_StopHapticRumble
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PlayHapticRumble")]
	public static partial SDLBool SDL_PlayHapticRumble(SDL_Haptic haptic, float strength, uint length);

	/// <summary>
	/// Stop the simple rumble on a haptic device.<br/>
	/// <br/>
	/// @param haptic the haptic device to stop the rumble effect on.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PlayHapticRumble
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_StopHapticRumble")]
	public static partial SDLBool SDL_StopHapticRumble(SDL_Haptic haptic);

	/// <summary>
	/// Initialize the HIDAPI library.<br/>
	/// This function initializes the HIDAPI library. Calling it is not strictly<br/>
	/// necessary, as it will be called automatically by SDL_hid_enumerate() and<br/>
	/// any of the SDL_hid_open_*() functions if it is needed. This function should<br/>
	/// be called at the beginning of execution however, if there is a chance of<br/>
	/// HIDAPI handles being opened by different threads simultaneously.<br/>
	/// Each call to this function should have a matching call to SDL_hid_exit()<br/>
	/// <br/>
	/// @returns 0 on success or a negative error code on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_hid_exit
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_init")]
	public static partial int SDL_hid_init();

	/// <summary>
	/// Finalize the HIDAPI library.<br/>
	/// This function frees all of the static data associated with HIDAPI. It<br/>
	/// should be called at the end of execution to avoid memory leaks.<br/>
	/// <br/>
	/// @returns 0 on success or a negative error code on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_hid_init
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_exit")]
	public static partial int SDL_hid_exit();

	/// <summary>
	/// Check to see if devices may have been added or removed.<br/>
	/// Enumerating the HID devices is an expensive operation, so you can call this<br/>
	/// to see if there have been any system device changes since the last call to<br/>
	/// this function. A change in the counter returned doesn't necessarily mean<br/>
	/// that anything has changed, but you can call SDL_hid_enumerate() to get an<br/>
	/// updated device list.<br/>
	/// Calling this function for the first time may cause a thread or other system<br/>
	/// resource to be allocated to track device change notifications.<br/>
	/// <br/>
	/// @returns a change counter that is incremented with each potential device<br/>
	/// change, or 0 if device change detection isn't available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_hid_enumerate
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_device_change_count")]
	public static partial uint SDL_hid_device_change_count();

	/// <summary>
	/// Enumerate the HID Devices.<br/>
	/// This function returns a linked list of all the HID devices attached to the<br/>
	/// system which match vendor_id and product_id. If `vendor_id` is set to 0<br/>
	/// then any vendor matches. If `product_id` is set to 0 then any product<br/>
	/// matches. If `vendor_id` and `product_id` are both set to 0, then all HID<br/>
	/// devices will be returned.<br/>
	/// By default SDL will only enumerate controllers, to reduce risk of hanging<br/>
	/// or crashing on bad drivers, but SDL_HINT_HIDAPI_ENUMERATE_ONLY_CONTROLLERS<br/>
	/// can be set to "0" to enumerate all HID devices.<br/>
	/// <br/>
	/// @param vendor_id the Vendor ID (VID) of the types of device to open, or 0<br/>
	/// to match any vendor.<br/>
	/// @param product_id the Product ID (PID) of the types of device to open, or 0<br/>
	/// to match any product.<br/>
	/// @returns a pointer to a linked list of type SDL_hid_device_info, containing<br/>
	/// information about the HID devices attached to the system, or NULL<br/>
	/// in the case of failure. Free this linked list by calling<br/>
	/// SDL_hid_free_enumeration().<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_hid_device_change_count
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_enumerate")]
	public static partial SDL_hid_device_info* SDL_hid_enumerate(ushort vendor_id, ushort product_id);

	/// <summary>
	/// Free an enumeration linked list.<br/>
	/// This function frees a linked list created by SDL_hid_enumerate().<br/>
	/// <br/>
	/// @param devs pointer to a list of struct_device returned from<br/>
	/// SDL_hid_enumerate().<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_free_enumeration")]
	public static partial void SDL_hid_free_enumeration(SDL_hid_device_info* devs);

	/// <summary>
	/// Open a HID device using a Vendor ID (VID), Product ID (PID) and optionally<br/>
	/// a serial number.<br/>
	/// If `serial_number` is NULL, the first device with the specified VID and PID<br/>
	/// is opened.<br/>
	/// <br/>
	/// @param vendor_id the Vendor ID (VID) of the device to open.<br/>
	/// @param product_id the Product ID (PID) of the device to open.<br/>
	/// @param serial_number the Serial Number of the device to open (Optionally<br/>
	/// NULL).<br/>
	/// @returns a pointer to a SDL_hid_device object on success or NULL on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_open")]
	public static partial SDL_hid_device SDL_hid_open(ushort vendor_id, ushort product_id, char* serial_number);

	/// <summary>
	/// Open a HID device by its path name.<br/>
	/// The path name be determined by calling SDL_hid_enumerate(), or a<br/>
	/// platform-specific path name can be used (eg: /dev/hidraw0 on Linux).<br/>
	/// <br/>
	/// @param path the path name of the device to open.<br/>
	/// @returns a pointer to a SDL_hid_device object on success or NULL on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_open_path")]
	public static partial SDL_hid_device SDL_hid_open_path(byte* path);

	[LibraryImport(LibName, EntryPoint = "SDL_hid_open_path")]
	public static partial SDL_hid_device SDL_hid_open_path(ReadOnlySpan<byte> path);

	[LibraryImport(LibName, EntryPoint = "SDL_hid_open_path")]
	public static partial SDL_hid_device SDL_hid_open_path([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);

	/// <summary>
	/// Write an Output report to a HID device.<br/>
	/// The first byte of `data` must contain the Report ID. For devices which only<br/>
	/// support a single report, this must be set to 0x0. The remaining bytes<br/>
	/// contain the report data. Since the Report ID is mandatory, calls to<br/>
	/// SDL_hid_write() will always contain one more byte than the report contains.<br/>
	/// For example, if a hid report is 16 bytes long, 17 bytes must be passed to<br/>
	/// SDL_hid_write(), the Report ID (or 0x0, for devices with a single report),<br/>
	/// followed by the report data (16 bytes). In this example, the length passed<br/>
	/// in would be 17.<br/>
	/// SDL_hid_write() will send the data on the first OUT endpoint, if one<br/>
	/// exists. If it does not, it will send the data through the Control Endpoint<br/>
	/// (Endpoint 0).<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param data the data to send, including the report number as the first<br/>
	/// byte.<br/>
	/// @param length the length in bytes of the data to send.<br/>
	/// @returns the actual number of bytes written and -1 on on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_write")]
	public static partial int SDL_hid_write(SDL_hid_device dev, byte* data, nuint length);

	/// <summary>
	/// Read an Input report from a HID device with timeout.<br/>
	/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
	/// The first byte will contain the Report number if the device uses numbered<br/>
	/// reports.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param data a buffer to put the read data into.<br/>
	/// @param length the number of bytes to read. For devices with multiple<br/>
	/// reports, make sure to read an extra byte for the report<br/>
	/// number.<br/>
	/// @param milliseconds timeout in milliseconds or -1 for blocking wait.<br/>
	/// @returns the actual number of bytes read and -1 on on failure; call<br/>
	/// SDL_GetError() for more information. If no packet was available to<br/>
	/// be read within the timeout period, this function returns 0.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_read_timeout")]
	public static partial int SDL_hid_read_timeout(SDL_hid_device dev, byte* data, nuint length, int milliseconds);

	/// <summary>
	/// Read an Input report from a HID device.<br/>
	/// Input reports are returned to the host through the INTERRUPT IN endpoint.<br/>
	/// The first byte will contain the Report number if the device uses numbered<br/>
	/// reports.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param data a buffer to put the read data into.<br/>
	/// @param length the number of bytes to read. For devices with multiple<br/>
	/// reports, make sure to read an extra byte for the report<br/>
	/// number.<br/>
	/// @returns the actual number of bytes read and -1 on failure; call<br/>
	/// SDL_GetError() for more information. If no packet was available to<br/>
	/// be read and the handle is in non-blocking mode, this function<br/>
	/// returns 0.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_read")]
	public static partial int SDL_hid_read(SDL_hid_device dev, byte* data, nuint length);

	/// <summary>
	/// Set the device handle to be non-blocking.<br/>
	/// In non-blocking mode calls to SDL_hid_read() will return immediately with a<br/>
	/// value of 0 if there is no data to be read. In blocking mode, SDL_hid_read()<br/>
	/// will wait (block) until there is data to read before returning.<br/>
	/// Nonblocking can be turned on and off at any time.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param nonblock enable or not the nonblocking reads - 1 to enable<br/>
	/// nonblocking - 0 to disable nonblocking.<br/>
	/// @returns 0 on success or a negative error code on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_set_nonblocking")]
	public static partial int SDL_hid_set_nonblocking(SDL_hid_device dev, int nonblock);

	/// <summary>
	/// Send a Feature report to the device.<br/>
	/// Feature reports are sent over the Control endpoint as a Set_Report<br/>
	/// transfer. The first byte of `data` must contain the Report ID. For devices<br/>
	/// which only support a single report, this must be set to 0x0. The remaining<br/>
	/// bytes contain the report data. Since the Report ID is mandatory, calls to<br/>
	/// SDL_hid_send_feature_report() will always contain one more byte than the<br/>
	/// report contains. For example, if a hid report is 16 bytes long, 17 bytes<br/>
	/// must be passed to SDL_hid_send_feature_report(): the Report ID (or 0x0, for<br/>
	/// devices which do not use numbered reports), followed by the report data (16<br/>
	/// bytes). In this example, the length passed in would be 17.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param data the data to send, including the report number as the first<br/>
	/// byte.<br/>
	/// @param length the length in bytes of the data to send, including the report<br/>
	/// number.<br/>
	/// @returns the actual number of bytes written and -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_send_feature_report")]
	public static partial int SDL_hid_send_feature_report(SDL_hid_device dev, byte* data, nuint length);

	/// <summary>
	/// Get a feature report from a HID device.<br/>
	/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
	/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
	/// first byte will still contain the Report ID, and the report data will start<br/>
	/// in data[1].<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param data a buffer to put the read data into, including the Report ID.<br/>
	/// Set the first byte of `data` to the Report ID of the report to<br/>
	/// be read, or set it to zero if your device does not use numbered<br/>
	/// reports.<br/>
	/// @param length the number of bytes to read, including an extra byte for the<br/>
	/// report ID. The buffer can be longer than the actual report.<br/>
	/// @returns the number of bytes read plus one for the report ID (which is<br/>
	/// still in the first byte), or -1 on on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_get_feature_report")]
	public static partial int SDL_hid_get_feature_report(SDL_hid_device dev, byte* data, nuint length);

	/// <summary>
	/// Get an input report from a HID device.<br/>
	/// Set the first byte of `data` to the Report ID of the report to be read.<br/>
	/// Make sure to allow space for this extra byte in `data`. Upon return, the<br/>
	/// first byte will still contain the Report ID, and the report data will start<br/>
	/// in data[1].<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param data a buffer to put the read data into, including the Report ID.<br/>
	/// Set the first byte of `data` to the Report ID of the report to<br/>
	/// be read, or set it to zero if your device does not use numbered<br/>
	/// reports.<br/>
	/// @param length the number of bytes to read, including an extra byte for the<br/>
	/// report ID. The buffer can be longer than the actual report.<br/>
	/// @returns the number of bytes read plus one for the report ID (which is<br/>
	/// still in the first byte), or -1 on on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_get_input_report")]
	public static partial int SDL_hid_get_input_report(SDL_hid_device dev, byte* data, nuint length);

	/// <summary>
	/// Close a HID device.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @returns 0 on success or a negative error code on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_close")]
	public static partial int SDL_hid_close(SDL_hid_device dev);

	/// <summary>
	/// Get The Manufacturer String from a HID device.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param string a wide string buffer to put the data into.<br/>
	/// @param maxlen the length of the buffer in multiples of wchar_t.<br/>
	/// @returns 0 on success or a negative error code on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_get_manufacturer_string")]
	public static partial int SDL_hid_get_manufacturer_string(SDL_hid_device dev, char* @string, nuint maxlen);

	/// <summary>
	/// Get The Product String from a HID device.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param string a wide string buffer to put the data into.<br/>
	/// @param maxlen the length of the buffer in multiples of wchar_t.<br/>
	/// @returns 0 on success or a negative error code on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_get_product_string")]
	public static partial int SDL_hid_get_product_string(SDL_hid_device dev, char* @string, nuint maxlen);

	/// <summary>
	/// Get The Serial Number String from a HID device.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param string a wide string buffer to put the data into.<br/>
	/// @param maxlen the length of the buffer in multiples of wchar_t.<br/>
	/// @returns 0 on success or a negative error code on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_get_serial_number_string")]
	public static partial int SDL_hid_get_serial_number_string(SDL_hid_device dev, char* @string, nuint maxlen);

	/// <summary>
	/// Get a string from a HID device, based on its string index.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param string_index the index of the string to get.<br/>
	/// @param string a wide string buffer to put the data into.<br/>
	/// @param maxlen the length of the buffer in multiples of wchar_t.<br/>
	/// @returns 0 on success or a negative error code on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_get_indexed_string")]
	public static partial int SDL_hid_get_indexed_string(SDL_hid_device dev, int string_index, char* @string, nuint maxlen);

	/// <summary>
	/// Get the device info from a HID device.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @returns a pointer to the SDL_hid_device_info for this hid_device or NULL<br/>
	/// on failure; call SDL_GetError() for more information. This struct<br/>
	/// is valid until the device is closed with SDL_hid_close().<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_get_device_info")]
	public static partial SDL_hid_device_info* SDL_hid_get_device_info(SDL_hid_device dev);

	/// <summary>
	/// Get a report descriptor from a HID device.<br/>
	/// User has to provide a preallocated buffer where descriptor will be copied<br/>
	/// to. The recommended size for a preallocated buffer is 4096 bytes.<br/>
	/// <br/>
	/// @param dev a device handle returned from SDL_hid_open().<br/>
	/// @param buf the buffer to copy descriptor into.<br/>
	/// @param buf_size the size of the buffer in bytes.<br/>
	/// @returns the number of bytes actually copied or -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_get_report_descriptor")]
	public static partial int SDL_hid_get_report_descriptor(SDL_hid_device dev, byte* buf, nuint buf_size);

	/// <summary>
	/// Start or stop a BLE scan on iOS and tvOS to pair Steam Controllers.<br/>
	/// <br/>
	/// @param active true to start the scan, false to stop the scan.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_hid_ble_scan")]
	public static partial void SDL_hid_ble_scan(SDLBool active);

	/// <summary>
	/// Set a hint with a specific priority.<br/>
	/// The priority controls the behavior when setting a hint that already has a<br/>
	/// value. Hints will replace existing hints of their priority and lower.<br/>
	/// Environment variables are considered to have override priority.<br/>
	/// <br/>
	/// @param name the hint to set.<br/>
	/// @param value the value of the hint variable.<br/>
	/// @param priority the SDL_HintPriority level for the hint.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetHint<br/>
	/// @sa SDL_ResetHint<br/>
	/// @sa SDL_SetHint
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetHintWithPriority")]
	public static partial SDLBool SDL_SetHintWithPriority(byte* name, byte* value, SDL_HintPriority priority);

	[LibraryImport(LibName, EntryPoint = "SDL_SetHintWithPriority")]
	public static partial SDLBool SDL_SetHintWithPriority(ReadOnlySpan<byte> name, ReadOnlySpan<byte> value, SDL_HintPriority priority);

	[LibraryImport(LibName, EntryPoint = "SDL_SetHintWithPriority")]
	public static partial SDLBool SDL_SetHintWithPriority([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value, SDL_HintPriority priority);

	/// <summary>
	/// Set a hint with normal priority.<br/>
	/// Hints will not be set if there is an existing override hint or environment<br/>
	/// variable that takes precedence. You can use SDL_SetHintWithPriority() to<br/>
	/// set the hint with override priority instead.<br/>
	/// <br/>
	/// @param name the hint to set.<br/>
	/// @param value the value of the hint variable.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetHint<br/>
	/// @sa SDL_ResetHint<br/>
	/// @sa SDL_SetHintWithPriority
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetHint")]
	public static partial SDLBool SDL_SetHint(byte* name, byte* value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetHint")]
	public static partial SDLBool SDL_SetHint(ReadOnlySpan<byte> name, ReadOnlySpan<byte> value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetHint")]
	public static partial SDLBool SDL_SetHint([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value);

	/// <summary>
	/// Reset a hint to the default value.<br/>
	/// This will reset a hint to the value of the environment variable, or NULL if<br/>
	/// the environment isn't set. Callbacks will be called normally with this<br/>
	/// change.<br/>
	/// <br/>
	/// @param name the hint to set.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetHint<br/>
	/// @sa SDL_ResetHints
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ResetHint")]
	public static partial SDLBool SDL_ResetHint(byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_ResetHint")]
	public static partial SDLBool SDL_ResetHint(ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_ResetHint")]
	public static partial SDLBool SDL_ResetHint([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Reset all hints to the default values.<br/>
	/// This will reset all hints to the value of the associated environment<br/>
	/// variable, or NULL if the environment isn't set. Callbacks will be called<br/>
	/// normally with this change.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ResetHint
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ResetHints")]
	public static partial void SDL_ResetHints();

	/// <summary>
	/// Get the value of a hint.<br/>
	/// <br/>
	/// @param name the hint to query.<br/>
	/// @returns the string value of a hint or NULL if the hint isn't set.<br/>
	/// @threadsafety It is safe to call this function from any thread, however the<br/>
	/// return value only remains valid until the hint is changed; if<br/>
	/// another thread might do so, the app should supply locks<br/>
	/// and/or make a copy of the string. Note that using a hint<br/>
	/// callback instead is always thread-safe, as SDL holds a lock<br/>
	/// on the thread subsystem during the callback.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetHint<br/>
	/// @sa SDL_SetHintWithPriority
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetHint")]
	public static partial byte* SDL_GetHintPtr(byte* name);

	public static string? SDL_GetHint(byte* name)
	{
		return ConvertToManaged(SDL_GetHintPtr(name));
	}

	[LibraryImport(LibName, EntryPoint = "SDL_GetHint")]
	public static partial byte* SDL_GetHintPtr(ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_GetHint")]
	public static partial byte* SDL_GetHintPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Get the boolean value of a hint variable.<br/>
	/// <br/>
	/// @param name the name of the hint to get the boolean value from.<br/>
	/// @param default_value the value to return if the hint does not exist.<br/>
	/// @returns the boolean value of a hint or the provided default value if the<br/>
	/// hint does not exist.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetHint<br/>
	/// @sa SDL_SetHint
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetHintBoolean")]
	public static partial SDLBool SDL_GetHintBoolean(byte* name, SDLBool default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetHintBoolean")]
	public static partial SDLBool SDL_GetHintBoolean(ReadOnlySpan<byte> name, SDLBool default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetHintBoolean")]
	public static partial SDLBool SDL_GetHintBoolean([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, SDLBool default_value);

	/// <summary>
	/// Add a function to watch a particular hint.<br/>
	/// The callback function is called _during_ this function, to provide it an<br/>
	/// initial value, and again each time the hint's value changes.<br/>
	/// <br/>
	/// @param name the hint to watch.<br/>
	/// @param callback An SDL_HintCallback function that will be called when the<br/>
	/// hint value changes.<br/>
	/// @param userdata a pointer to pass to the callback function.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RemoveHintCallback
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AddHintCallback")]
	public static partial SDLBool SDL_AddHintCallback(byte* name, delegate* unmanaged[Cdecl]<nint, byte*, byte*, byte*, void> callback, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_AddHintCallback")]
	public static partial SDLBool SDL_AddHintCallback(ReadOnlySpan<byte> name, delegate* unmanaged[Cdecl]<nint, byte*, byte*, byte*, void> callback, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_AddHintCallback")]
	public static partial SDLBool SDL_AddHintCallback([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, delegate* unmanaged[Cdecl]<nint, byte*, byte*, byte*, void> callback, nint userdata);

	/// <summary>
	/// Remove a function watching a particular hint.<br/>
	/// <br/>
	/// @param name the hint being watched.<br/>
	/// @param callback an SDL_HintCallback function that will be called when the<br/>
	/// hint value changes.<br/>
	/// @param userdata a pointer being passed to the callback function.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddHintCallback
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RemoveHintCallback")]
	public static partial void SDL_RemoveHintCallback(byte* name, delegate* unmanaged[Cdecl]<nint, byte*, byte*, byte*, void> callback, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_RemoveHintCallback")]
	public static partial void SDL_RemoveHintCallback(ReadOnlySpan<byte> name, delegate* unmanaged[Cdecl]<nint, byte*, byte*, byte*, void> callback, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_RemoveHintCallback")]
	public static partial void SDL_RemoveHintCallback([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, delegate* unmanaged[Cdecl]<nint, byte*, byte*, byte*, void> callback, nint userdata);

	/// <summary>
	/// Initialize the SDL library.<br/>
	/// SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the<br/>
	/// two may be used interchangeably. Though for readability of your code<br/>
	/// SDL_InitSubSystem() might be preferred.<br/>
	/// The file I/O (for example: SDL_IOFromFile) and threading (SDL_CreateThread)<br/>
	/// subsystems are initialized by default. Message boxes<br/>
	/// (SDL_ShowSimpleMessageBox) also attempt to work without initializing the<br/>
	/// video subsystem, in hopes of being useful in showing an error dialog when<br/>
	/// SDL_Init fails. You must specifically initialize other subsystems if you<br/>
	/// use them in your application.<br/>
	/// Logging (such as SDL_Log) works without initialization, too.<br/>
	/// `flags` may be any of the following OR'd together:<br/>
	/// - `SDL_INIT_AUDIO`: audio subsystem; automatically initializes the events<br/>
	/// subsystem<br/>
	/// - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events<br/>
	/// subsystem<br/>
	/// - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the<br/>
	/// events subsystem<br/>
	/// - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem<br/>
	/// - `SDL_INIT_GAMEPAD`: gamepad subsystem; automatically initializes the<br/>
	/// joystick subsystem<br/>
	/// - `SDL_INIT_EVENTS`: events subsystem<br/>
	/// - `SDL_INIT_SENSOR`: sensor subsystem; automatically initializes the events<br/>
	/// subsystem<br/>
	/// - `SDL_INIT_CAMERA`: camera subsystem; automatically initializes the events<br/>
	/// subsystem<br/>
	/// Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()<br/>
	/// for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or<br/>
	/// call SDL_Quit() to force shutdown). If a subsystem is already loaded then<br/>
	/// this call will increase the ref-count and return.<br/>
	/// Consider reporting some basic metadata about your application before<br/>
	/// calling SDL_Init, using either SDL_SetAppMetadata() or<br/>
	/// SDL_SetAppMetadataProperty().<br/>
	/// <br/>
	/// @param flags subsystem initialization flags.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAppMetadata<br/>
	/// @sa SDL_SetAppMetadataProperty<br/>
	/// @sa SDL_InitSubSystem<br/>
	/// @sa SDL_Quit<br/>
	/// @sa SDL_SetMainReady<br/>
	/// @sa SDL_WasInit
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Init")]
	public static partial SDLBool SDL_Init(SDL_InitFlags flags);

	/// <summary>
	/// Compatibility function to initialize the SDL library.<br/>
	/// This function and SDL_Init() are interchangeable.<br/>
	/// <br/>
	/// @param flags any of the flags used by SDL_Init(); see SDL_Init for details.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Init<br/>
	/// @sa SDL_Quit<br/>
	/// @sa SDL_QuitSubSystem
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_InitSubSystem")]
	public static partial SDLBool SDL_InitSubSystem(SDL_InitFlags flags);

	/// <summary>
	/// Shut down specific SDL subsystems.<br/>
	/// You still need to call SDL_Quit() even if you close all open subsystems<br/>
	/// with SDL_QuitSubSystem().<br/>
	/// <br/>
	/// @param flags any of the flags used by SDL_Init(); see SDL_Init for details.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_InitSubSystem<br/>
	/// @sa SDL_Quit
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_QuitSubSystem")]
	public static partial void SDL_QuitSubSystem(SDL_InitFlags flags);

	/// <summary>
	/// Get a mask of the specified subsystems which are currently initialized.<br/>
	/// <br/>
	/// @param flags any of the flags used by SDL_Init(); see SDL_Init for details.<br/>
	/// @returns a mask of all initialized subsystems if `flags` is 0, otherwise it<br/>
	/// returns the initialization status of the specified subsystems.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Init<br/>
	/// @sa SDL_InitSubSystem
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WasInit")]
	public static partial SDL_InitFlags SDL_WasInit(SDL_InitFlags flags);

	/// <summary>
	/// Clean up all initialized subsystems.<br/>
	/// You should call this function even if you have already shutdown each<br/>
	/// initialized subsystem with SDL_QuitSubSystem(). It is safe to call this<br/>
	/// function even in the case of errors in initialization.<br/>
	/// You can use this function with atexit() to ensure that it is run when your<br/>
	/// application is shutdown, but it is not wise to do this from a library or<br/>
	/// other dynamically loaded code.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Init<br/>
	/// @sa SDL_QuitSubSystem
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Quit")]
	public static partial void SDL_Quit();

	/// <summary>
	/// Specify basic metadata about your app.<br/>
	/// You can optionally provide metadata about your app to SDL. This is not<br/>
	/// required, but strongly encouraged.<br/>
	/// There are several locations where SDL can make use of metadata (an "About"<br/>
	/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
	/// mixers, etc). Any piece of metadata can be left as NULL, if a specific<br/>
	/// detail doesn't make sense for the app.<br/>
	/// This function should be called as early as possible, before SDL_Init.<br/>
	/// Multiple calls to this function are allowed, but various state might not<br/>
	/// change once it has been set up with a previous call to this function.<br/>
	/// Passing a NULL removes any previous metadata.<br/>
	/// This is a simplified interface for the most important information. You can<br/>
	/// supply significantly more detailed metadata with<br/>
	/// SDL_SetAppMetadataProperty().<br/>
	/// <br/>
	/// @param appname The name of the application ("My Game 2: Bad Guy's<br/>
	/// Revenge!").<br/>
	/// @param appversion The version of the application ("1.0.0beta5" or a git<br/>
	/// hash, or whatever makes sense).<br/>
	/// @param appidentifier A unique string in reverse-domain format that<br/>
	/// identifies this app ("com.example.mygame2").<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAppMetadataProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAppMetadata")]
	public static partial SDLBool SDL_SetAppMetadata(byte* appname, byte* appversion, byte* appidentifier);

	[LibraryImport(LibName, EntryPoint = "SDL_SetAppMetadata")]
	public static partial SDLBool SDL_SetAppMetadata(ReadOnlySpan<byte> appname, ReadOnlySpan<byte> appversion, ReadOnlySpan<byte> appidentifier);

	[LibraryImport(LibName, EntryPoint = "SDL_SetAppMetadata")]
	public static partial SDLBool SDL_SetAppMetadata([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> appname, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> appversion, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> appidentifier);

	/// <summary>
	/// Specify metadata about your app through a set of properties.<br/>
	/// You can optionally provide metadata about your app to SDL. This is not<br/>
	/// required, but strongly encouraged.<br/>
	/// There are several locations where SDL can make use of metadata (an "About"<br/>
	/// box in the macOS menu bar, the name of the app can be shown on some audio<br/>
	/// mixers, etc). Any piece of metadata can be left out, if a specific detail<br/>
	/// doesn't make sense for the app.<br/>
	/// This function should be called as early as possible, before SDL_Init.<br/>
	/// Multiple calls to this function are allowed, but various state might not<br/>
	/// change once it has been set up with a previous call to this function.<br/>
	/// Once set, this metadata can be read using SDL_GetMetadataProperty().<br/>
	/// These are the supported properties:<br/>
	/// - `SDL_PROP_APP_METADATA_NAME_STRING`: The human-readable name of the<br/>
	/// application, like "My Game 2: Bad Guy's Revenge!". This will show up<br/>
	/// anywhere the OS shows the name of the application separately from window<br/>
	/// titles, such as volume control applets, etc. This defaults to "SDL<br/>
	/// Application".<br/>
	/// - `SDL_PROP_APP_METADATA_VERSION_STRING`: The version of the app that is<br/>
	/// running; there are no rules on format, so "1.0.3beta2" and "April 22nd,<br/>
	/// 2024" and a git hash are all valid options. This has no default.<br/>
	/// - `SDL_PROP_APP_METADATA_IDENTIFIER_STRING`: A unique string that<br/>
	/// identifies this app. This must be in reverse-domain format, like<br/>
	/// "com.example.mygame2". This string is used by desktop compositors to<br/>
	/// identify and group windows together, as well as match applications with<br/>
	/// associated desktop settings and icons. If you plan to package your<br/>
	/// application in a container such as Flatpak, the app ID should match the<br/>
	/// name of your Flatpak container as well. This has no default.<br/>
	/// - `SDL_PROP_APP_METADATA_CREATOR_STRING`: The human-readable name of the<br/>
	/// creator/developer/maker of this app, like "MojoWorkshop, LLC"<br/>
	/// - `SDL_PROP_APP_METADATA_COPYRIGHT_STRING`: The human-readable copyright<br/>
	/// notice, like "Copyright (c) 2024 MojoWorkshop, LLC" or whatnot. Keep this<br/>
	/// to one line, don't paste a copy of a whole software license in here. This<br/>
	/// has no default.<br/>
	/// - `SDL_PROP_APP_METADATA_URL_STRING`: A URL to the app on the web. Maybe a<br/>
	/// product page, or a storefront, or even a GitHub repository, for user's<br/>
	/// further information This has no default.<br/>
	/// - `SDL_PROP_APP_METADATA_TYPE_STRING`: The type of application this is.<br/>
	/// Currently this string can be "game" for a video game, "mediaplayer" for a<br/>
	/// media player, or generically "application" if nothing else applies.<br/>
	/// Future versions of SDL might add new types. This defaults to<br/>
	/// "application".<br/>
	/// <br/>
	/// @param name the name of the metadata property to set.<br/>
	/// @param value the value of the property, or NULL to remove that property.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAppMetadataProperty<br/>
	/// @sa SDL_SetAppMetadata
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetAppMetadataProperty")]
	public static partial SDLBool SDL_SetAppMetadataProperty(byte* name, byte* value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetAppMetadataProperty")]
	public static partial SDLBool SDL_SetAppMetadataProperty(ReadOnlySpan<byte> name, ReadOnlySpan<byte> value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetAppMetadataProperty")]
	public static partial SDLBool SDL_SetAppMetadataProperty([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value);

	/// <summary>
	/// Get metadata about your app.<br/>
	/// This returns metadata previously set using SDL_SetAppMetadata() or<br/>
	/// SDL_SetAppMetadataProperty(). See SDL_SetAppMetadataProperty() for the list<br/>
	/// of available properties and their meanings.<br/>
	/// <br/>
	/// @param name the name of the metadata property to get.<br/>
	/// @returns the current value of the metadata property, or the default if it<br/>
	/// is not set, NULL for properties with no default.<br/>
	/// @threadsafety It is safe to call this function from any thread, although<br/>
	/// the string returned is not protected and could potentially be<br/>
	/// freed if you call SDL_SetAppMetadataProperty() to set that<br/>
	/// property from another thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetAppMetadata<br/>
	/// @sa SDL_SetAppMetadataProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAppMetadataProperty")]
	public static partial byte* SDL_GetAppMetadataPropertyPtr(byte* name);

	public static string? SDL_GetAppMetadataProperty(byte* name)
	{
		return ConvertToManaged(SDL_GetAppMetadataPropertyPtr(name));
	}

	[LibraryImport(LibName, EntryPoint = "SDL_GetAppMetadataProperty")]
	public static partial byte* SDL_GetAppMetadataPropertyPtr(ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_GetAppMetadataProperty")]
	public static partial byte* SDL_GetAppMetadataPropertyPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Use this function to create a new SDL_IOStream structure for reading from<br/>
	/// and/or writing to a named file.<br/>
	/// The `mode` string is treated roughly the same as in a call to the C<br/>
	/// library's fopen(), even if SDL doesn't happen to use fopen() behind the<br/>
	/// scenes.<br/>
	/// Available `mode` strings:<br/>
	/// - "r": Open a file for reading. The file must exist.<br/>
	/// - "w": Create an empty file for writing. If a file with the same name<br/>
	/// already exists its content is erased and the file is treated as a new<br/>
	/// empty file.<br/>
	/// - "a": Append to a file. Writing operations append data at the end of the<br/>
	/// file. The file is created if it does not exist.<br/>
	/// - "r+": Open a file for update both reading and writing. The file must<br/>
	/// exist.<br/>
	/// - "w+": Create an empty file for both reading and writing. If a file with<br/>
	/// the same name already exists its content is erased and the file is<br/>
	/// treated as a new empty file.<br/>
	/// - "a+": Open a file for reading and appending. All writing operations are<br/>
	/// performed at the end of the file, protecting the previous content to be<br/>
	/// overwritten. You can reposition (fseek, rewind) the internal pointer to<br/>
	/// anywhere in the file for reading, but writing operations will move it<br/>
	/// back to the end of file. The file is created if it does not exist.<br/>
	/// **NOTE**: In order to open a file as a binary file, a "b" character has to<br/>
	/// be included in the `mode` string. This additional "b" character can either<br/>
	/// be appended at the end of the string (thus making the following compound<br/>
	/// modes: "rb", "wb", "ab", "r+b", "w+b", "a+b") or be inserted between the<br/>
	/// letter and the "+" sign for the mixed modes ("rb+", "wb+", "ab+").<br/>
	/// Additional characters may follow the sequence, although they should have no<br/>
	/// effect. For example, "t" is sometimes appended to make explicit the file is<br/>
	/// a text file.<br/>
	/// This function supports Unicode filenames, but they must be encoded in UTF-8<br/>
	/// format, regardless of the underlying operating system.<br/>
	/// In Android, SDL_IOFromFile() can be used to open content:// URIs. As a<br/>
	/// fallback, SDL_IOFromFile() will transparently open a matching filename in<br/>
	/// the app's `assets`.<br/>
	/// Closing the SDL_IOStream will close SDL's internal file handle.<br/>
	/// The following properties may be set at creation time by SDL:<br/>
	/// - `SDL_PROP_IOSTREAM_WINDOWS_HANDLE_POINTER`: a pointer, that can be cast<br/>
	/// to a win32 `HANDLE`, that this SDL_IOStream is using to access the<br/>
	/// filesystem. If the program isn't running on Windows, or SDL used some<br/>
	/// other method to access the filesystem, this property will not be set.<br/>
	/// - `SDL_PROP_IOSTREAM_STDIO_FILE_POINTER`: a pointer, that can be cast to a<br/>
	/// stdio `FILE *`, that this SDL_IOStream is using to access the filesystem.<br/>
	/// If SDL used some other method to access the filesystem, this property<br/>
	/// will not be set. PLEASE NOTE that if SDL is using a different C runtime<br/>
	/// than your app, trying to use this pointer will almost certainly result in<br/>
	/// a crash! This is mostly a problem on Windows; make sure you build SDL and<br/>
	/// your app with the same compiler and settings to avoid it.<br/>
	/// - `SDL_PROP_IOSTREAM_FILE_DESCRIPTOR_NUMBER`: a file descriptor that this<br/>
	/// SDL_IOStream is using to access the filesystem.<br/>
	/// - `SDL_PROP_IOSTREAM_ANDROID_AASSET_POINTER`: a pointer, that can be cast<br/>
	/// to an Android NDK `AAsset *`, that this SDL_IOStream is using to access<br/>
	/// the filesystem. If SDL used some other method to access the filesystem,<br/>
	/// this property will not be set.<br/>
	/// <br/>
	/// @param file a UTF-8 string representing the filename to open.<br/>
	/// @param mode an ASCII string representing the mode to be used for opening<br/>
	/// the file.<br/>
	/// @returns a pointer to the SDL_IOStream structure that is created or NULL on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseIO<br/>
	/// @sa SDL_FlushIO<br/>
	/// @sa SDL_ReadIO<br/>
	/// @sa SDL_SeekIO<br/>
	/// @sa SDL_TellIO<br/>
	/// @sa SDL_WriteIO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IOFromFile")]
	public static partial SDL_IOStream SDL_IOFromFile(byte* file, byte* mode);

	[LibraryImport(LibName, EntryPoint = "SDL_IOFromFile")]
	public static partial SDL_IOStream SDL_IOFromFile(ReadOnlySpan<byte> file, ReadOnlySpan<byte> mode);

	[LibraryImport(LibName, EntryPoint = "SDL_IOFromFile")]
	public static partial SDL_IOStream SDL_IOFromFile([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> file, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> mode);

	/// <summary>
	/// Use this function to prepare a read-write memory buffer for use with<br/>
	/// SDL_IOStream.<br/>
	/// This function sets up an SDL_IOStream struct based on a memory area of a<br/>
	/// certain size, for both read and write access.<br/>
	/// This memory buffer is not copied by the SDL_IOStream; the pointer you<br/>
	/// provide must remain valid until you close the stream. Closing the stream<br/>
	/// will not free the original buffer.<br/>
	/// If you need to make sure the SDL_IOStream never writes to the memory<br/>
	/// buffer, you should use SDL_IOFromConstMem() with a read-only buffer of<br/>
	/// memory instead.<br/>
	/// The following properties will be set at creation time by SDL:<br/>
	/// - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that<br/>
	/// was passed to this function.<br/>
	/// - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter<br/>
	/// that was passed to this function.<br/>
	/// <br/>
	/// @param mem a pointer to a buffer to feed an SDL_IOStream stream.<br/>
	/// @param size the buffer size, in bytes.<br/>
	/// @returns a pointer to a new SDL_IOStream structure or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_IOFromConstMem<br/>
	/// @sa SDL_CloseIO<br/>
	/// @sa SDL_FlushIO<br/>
	/// @sa SDL_ReadIO<br/>
	/// @sa SDL_SeekIO<br/>
	/// @sa SDL_TellIO<br/>
	/// @sa SDL_WriteIO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IOFromMem")]
	public static partial SDL_IOStream SDL_IOFromMem(nint mem, nuint size);

	/// <summary>
	/// Use this function to prepare a read-only memory buffer for use with<br/>
	/// SDL_IOStream.<br/>
	/// This function sets up an SDL_IOStream struct based on a memory area of a<br/>
	/// certain size. It assumes the memory area is not writable.<br/>
	/// Attempting to write to this SDL_IOStream stream will report an error<br/>
	/// without writing to the memory buffer.<br/>
	/// This memory buffer is not copied by the SDL_IOStream; the pointer you<br/>
	/// provide must remain valid until you close the stream. Closing the stream<br/>
	/// will not free the original buffer.<br/>
	/// If you need to write to a memory buffer, you should use SDL_IOFromMem()<br/>
	/// with a writable buffer of memory instead.<br/>
	/// The following properties will be set at creation time by SDL:<br/>
	/// - `SDL_PROP_IOSTREAM_MEMORY_POINTER`: this will be the `mem` parameter that<br/>
	/// was passed to this function.<br/>
	/// - `SDL_PROP_IOSTREAM_MEMORY_SIZE_NUMBER`: this will be the `size` parameter<br/>
	/// that was passed to this function.<br/>
	/// <br/>
	/// @param mem a pointer to a read-only buffer to feed an SDL_IOStream stream.<br/>
	/// @param size the buffer size, in bytes.<br/>
	/// @returns a pointer to a new SDL_IOStream structure or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_IOFromMem<br/>
	/// @sa SDL_CloseIO<br/>
	/// @sa SDL_ReadIO<br/>
	/// @sa SDL_SeekIO<br/>
	/// @sa SDL_TellIO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IOFromConstMem")]
	public static partial SDL_IOStream SDL_IOFromConstMem(nint mem, nuint size);

	/// <summary>
	/// Use this function to create an SDL_IOStream that is backed by dynamically<br/>
	/// allocated memory.<br/>
	/// This supports the following properties to provide access to the memory and<br/>
	/// control over allocations:<br/>
	/// - `SDL_PROP_IOSTREAM_DYNAMIC_MEMORY_POINTER`: a pointer to the internal<br/>
	/// memory of the stream. This can be set to NULL to transfer ownership of<br/>
	/// the memory to the application, which should free the memory with<br/>
	/// SDL_free(). If this is done, the next operation on the stream must be<br/>
	/// SDL_CloseIO().<br/>
	/// - `SDL_PROP_IOSTREAM_DYNAMIC_CHUNKSIZE_NUMBER`: memory will be allocated in<br/>
	/// multiples of this size, defaulting to 1024.<br/>
	/// <br/>
	/// @returns a pointer to a new SDL_IOStream structure or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseIO<br/>
	/// @sa SDL_ReadIO<br/>
	/// @sa SDL_SeekIO<br/>
	/// @sa SDL_TellIO<br/>
	/// @sa SDL_WriteIO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IOFromDynamicMem")]
	public static partial SDL_IOStream SDL_IOFromDynamicMem();

	/// <summary>
	/// Create a custom SDL_IOStream.<br/>
	/// Applications do not need to use this function unless they are providing<br/>
	/// their own SDL_IOStream implementation. If you just need an SDL_IOStream to<br/>
	/// read/write a common data source, you should use the built-in<br/>
	/// implementations in SDL, like SDL_IOFromFile() or SDL_IOFromMem(), etc.<br/>
	/// This function makes a copy of `iface` and the caller does not need to keep<br/>
	/// it around after this call.<br/>
	/// <br/>
	/// @param iface the interface that implements this SDL_IOStream, initialized<br/>
	/// using SDL_INIT_INTERFACE().<br/>
	/// @param userdata the pointer that will be passed to the interface functions.<br/>
	/// @returns a pointer to the allocated memory on success or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseIO<br/>
	/// @sa SDL_INIT_INTERFACE<br/>
	/// @sa SDL_IOFromConstMem<br/>
	/// @sa SDL_IOFromFile<br/>
	/// @sa SDL_IOFromMem
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenIO")]
	public static partial SDL_IOStream SDL_OpenIO(SDL_IOStreamInterface* iface, nint userdata);

	/// <summary>
	/// Close and free an allocated SDL_IOStream structure.<br/>
	/// SDL_CloseIO() closes and cleans up the SDL_IOStream stream. It releases any<br/>
	/// resources used by the stream and frees the SDL_IOStream itself. This<br/>
	/// returns true on success, or false if the stream failed to flush to its<br/>
	/// output (e.g. to disk).<br/>
	/// Note that if this fails to flush the stream for any reason, this function<br/>
	/// reports an error, but the SDL_IOStream is still invalid once this function<br/>
	/// returns.<br/>
	/// This call flushes any buffered writes to the operating system, but there<br/>
	/// are no guarantees that those writes have gone to physical media; they might<br/>
	/// be in the OS's file cache, waiting to go to disk later. If it's absolutely<br/>
	/// crucial that writes go to disk immediately, so they are definitely stored<br/>
	/// even if the power fails before the file cache would have caught up, one<br/>
	/// should call SDL_FlushIO() before closing. Note that flushing takes time and<br/>
	/// makes the system and your app operate less efficiently, so do so sparingly.<br/>
	/// <br/>
	/// @param context SDL_IOStream structure to close.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenIO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CloseIO")]
	public static partial SDLBool SDL_CloseIO(SDL_IOStream context);

	/// <summary>
	/// Get the properties associated with an SDL_IOStream.<br/>
	/// <br/>
	/// @param context a pointer to an SDL_IOStream structure.<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetIOProperties")]
	public static partial SDL_PropertiesID SDL_GetIOProperties(SDL_IOStream context);

	/// <summary>
	/// Query the stream status of an SDL_IOStream.<br/>
	/// This information can be useful to decide if a short read or write was due<br/>
	/// to an error, an EOF, or a non-blocking operation that isn't yet ready to<br/>
	/// complete.<br/>
	/// An SDL_IOStream's status is only expected to change after a SDL_ReadIO or<br/>
	/// SDL_WriteIO call; don't expect it to change if you just call this query<br/>
	/// function in a tight loop.<br/>
	/// <br/>
	/// @param context the SDL_IOStream to query.<br/>
	/// @returns an SDL_IOStatus enum with the current state.<br/>
	/// @threadsafety This function should not be called at the same time that<br/>
	/// another thread is operating on the same SDL_IOStream.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetIOStatus")]
	public static partial SDL_IOStatus SDL_GetIOStatus(SDL_IOStream context);

	/// <summary>
	/// Use this function to get the size of the data stream in an SDL_IOStream.<br/>
	/// <br/>
	/// @param context the SDL_IOStream to get the size of the data stream from.<br/>
	/// @returns the size of the data stream in the SDL_IOStream on success or a<br/>
	/// negative error code on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetIOSize")]
	public static partial long SDL_GetIOSize(SDL_IOStream context);

	/// <summary>
	/// Seek within an SDL_IOStream data stream.<br/>
	/// This function seeks to byte `offset`, relative to `whence`.<br/>
	/// `whence` may be any of the following values:<br/>
	/// - `SDL_IO_SEEK_SET`: seek from the beginning of data<br/>
	/// - `SDL_IO_SEEK_CUR`: seek relative to current read point<br/>
	/// - `SDL_IO_SEEK_END`: seek relative to the end of data<br/>
	/// If this stream can not seek, it will return -1.<br/>
	/// <br/>
	/// @param context a pointer to an SDL_IOStream structure.<br/>
	/// @param offset an offset in bytes, relative to `whence` location; can be<br/>
	/// negative.<br/>
	/// @param whence any of `SDL_IO_SEEK_SET`, `SDL_IO_SEEK_CUR`,<br/>
	/// `SDL_IO_SEEK_END`.<br/>
	/// @returns the final offset in the data stream after the seek or -1 on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_TellIO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SeekIO")]
	public static partial long SDL_SeekIO(SDL_IOStream context, long offset, SDL_IOWhence whence);

	/// <summary>
	/// Determine the current read/write offset in an SDL_IOStream data stream.<br/>
	/// SDL_TellIO is actually a wrapper function that calls the SDL_IOStream's<br/>
	/// `seek` method, with an offset of 0 bytes from `SDL_IO_SEEK_CUR`, to<br/>
	/// simplify application development.<br/>
	/// <br/>
	/// @param context an SDL_IOStream data stream object from which to get the<br/>
	/// current offset.<br/>
	/// @returns the current offset in the stream, or -1 if the information can not<br/>
	/// be determined.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SeekIO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_TellIO")]
	public static partial long SDL_TellIO(SDL_IOStream context);

	/// <summary>
	/// Read from a data source.<br/>
	/// This function reads up `size` bytes from the data source to the area<br/>
	/// pointed at by `ptr`. This function may read less bytes than requested. It<br/>
	/// will return zero when the data stream is completely read, and<br/>
	/// SDL_GetIOStatus() will return SDL_IO_STATUS_EOF, or on error, and<br/>
	/// SDL_GetIOStatus() will return SDL_IO_STATUS_ERROR.<br/>
	/// <br/>
	/// @param context a pointer to an SDL_IOStream structure.<br/>
	/// @param ptr a pointer to a buffer to read data into.<br/>
	/// @param size the number of bytes to read from the data source.<br/>
	/// @returns the number of bytes read, or 0 on end of file or other failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_WriteIO<br/>
	/// @sa SDL_GetIOStatus
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadIO")]
	public static partial nuint SDL_ReadIO(SDL_IOStream context, nint ptr, nuint size);

	/// <summary>
	/// Write to an SDL_IOStream data stream.<br/>
	/// This function writes exactly `size` bytes from the area pointed at by `ptr`<br/>
	/// to the stream. If this fails for any reason, it'll return less than `size`<br/>
	/// to demonstrate how far the write progressed. On success, it returns `size`.<br/>
	/// On error, this function still attempts to write as much as possible, so it<br/>
	/// might return a positive value less than the requested write size.<br/>
	/// The caller can use SDL_GetIOStatus() to determine if the problem is<br/>
	/// recoverable, such as a non-blocking write that can simply be retried later,<br/>
	/// or a fatal error.<br/>
	/// <br/>
	/// @param context a pointer to an SDL_IOStream structure.<br/>
	/// @param ptr a pointer to a buffer containing data to write.<br/>
	/// @param size the number of bytes to write.<br/>
	/// @returns the number of bytes written, which will be less than `size` on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_IOprintf<br/>
	/// @sa SDL_ReadIO<br/>
	/// @sa SDL_SeekIO<br/>
	/// @sa SDL_FlushIO<br/>
	/// @sa SDL_GetIOStatus
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteIO")]
	public static partial nuint SDL_WriteIO(SDL_IOStream context, nint ptr, nuint size);

	/// <summary>
	/// Flush any buffered data in the stream.<br/>
	/// This function makes sure that any buffered data is written to the stream.<br/>
	/// Normally this isn't necessary but if the stream is a pipe or socket it<br/>
	/// guarantees that any pending data is sent.<br/>
	/// <br/>
	/// @param context SDL_IOStream structure to flush.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenIO<br/>
	/// @sa SDL_WriteIO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_FlushIO")]
	public static partial SDLBool SDL_FlushIO(SDL_IOStream context);

	/// <summary>
	/// Load all the data from an SDL data stream.<br/>
	/// The data is allocated with a zero byte at the end (null terminated) for<br/>
	/// convenience. This extra byte is not included in the value reported via<br/>
	/// `datasize`.<br/>
	/// The data should be freed with SDL_free().<br/>
	/// <br/>
	/// @param src the SDL_IOStream to read all available data from.<br/>
	/// @param datasize a pointer filled in with the number of bytes read, may be<br/>
	/// NULL.<br/>
	/// @param closeio if true, calls SDL_CloseIO() on `src` before returning, even<br/>
	/// in the case of an error.<br/>
	/// @returns the data or NULL on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LoadFile
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LoadFile_IO")]
	public static partial nint SDL_LoadFile_IO(SDL_IOStream src, nuint* datasize, SDLBool closeio);

	/// <summary>
	/// Load all the data from a file path.<br/>
	/// The data is allocated with a zero byte at the end (null terminated) for<br/>
	/// convenience. This extra byte is not included in the value reported via<br/>
	/// `datasize`.<br/>
	/// The data should be freed with SDL_free().<br/>
	/// <br/>
	/// @param file the path to read all available data from.<br/>
	/// @param datasize if not NULL, will store the number of bytes read.<br/>
	/// @returns the data or NULL on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LoadFile_IO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LoadFile")]
	public static partial nint SDL_LoadFile(byte* file, nuint* datasize);

	[LibraryImport(LibName, EntryPoint = "SDL_LoadFile")]
	public static partial nint SDL_LoadFile(ReadOnlySpan<byte> file, nuint* datasize);

	[LibraryImport(LibName, EntryPoint = "SDL_LoadFile")]
	public static partial nint SDL_LoadFile([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> file, nuint* datasize);

	/// <summary>
	/// Use this function to read a byte from an SDL_IOStream.<br/>
	/// <br/>
	/// @param src the SDL_IOStream to read from.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadU8")]
	public static partial SDLBool SDL_ReadU8(SDL_IOStream src, byte* value);

	/// <summary>
	/// Use this function to read a signed byte from an SDL_IOStream.<br/>
	/// <br/>
	/// @param src the SDL_IOStream to read from.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadS8")]
	public static partial SDLBool SDL_ReadS8(SDL_IOStream src, sbyte* value);

	/// <summary>
	/// Use this function to read 16 bits of little-endian data from an<br/>
	/// SDL_IOStream and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadU16LE")]
	public static partial SDLBool SDL_ReadU16LE(SDL_IOStream src, ushort* value);

	/// <summary>
	/// Use this function to read 16 bits of little-endian data from an<br/>
	/// SDL_IOStream and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadS16LE")]
	public static partial SDLBool SDL_ReadS16LE(SDL_IOStream src, short* value);

	/// <summary>
	/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
	/// and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadU16BE")]
	public static partial SDLBool SDL_ReadU16BE(SDL_IOStream src, ushort* value);

	/// <summary>
	/// Use this function to read 16 bits of big-endian data from an SDL_IOStream<br/>
	/// and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadS16BE")]
	public static partial SDLBool SDL_ReadS16BE(SDL_IOStream src, short* value);

	/// <summary>
	/// Use this function to read 32 bits of little-endian data from an<br/>
	/// SDL_IOStream and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadU32LE")]
	public static partial SDLBool SDL_ReadU32LE(SDL_IOStream src, uint* value);

	/// <summary>
	/// Use this function to read 32 bits of little-endian data from an<br/>
	/// SDL_IOStream and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadS32LE")]
	public static partial SDLBool SDL_ReadS32LE(SDL_IOStream src, int* value);

	/// <summary>
	/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
	/// and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadU32BE")]
	public static partial SDLBool SDL_ReadU32BE(SDL_IOStream src, uint* value);

	/// <summary>
	/// Use this function to read 32 bits of big-endian data from an SDL_IOStream<br/>
	/// and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadS32BE")]
	public static partial SDLBool SDL_ReadS32BE(SDL_IOStream src, int* value);

	/// <summary>
	/// Use this function to read 64 bits of little-endian data from an<br/>
	/// SDL_IOStream and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadU64LE")]
	public static partial SDLBool SDL_ReadU64LE(SDL_IOStream src, ulong* value);

	/// <summary>
	/// Use this function to read 64 bits of little-endian data from an<br/>
	/// SDL_IOStream and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadS64LE")]
	public static partial SDLBool SDL_ReadS64LE(SDL_IOStream src, long* value);

	/// <summary>
	/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
	/// and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadU64BE")]
	public static partial SDLBool SDL_ReadU64BE(SDL_IOStream src, ulong* value);

	/// <summary>
	/// Use this function to read 64 bits of big-endian data from an SDL_IOStream<br/>
	/// and return in native format.<br/>
	/// SDL byteswaps the data only if necessary, so the data returned will be in<br/>
	/// the native byte order.<br/>
	/// <br/>
	/// @param src the stream from which to read data.<br/>
	/// @param value a pointer filled in with the data read.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadS64BE")]
	public static partial SDLBool SDL_ReadS64BE(SDL_IOStream src, long* value);

	/// <summary>
	/// Use this function to write a byte to an SDL_IOStream.<br/>
	/// <br/>
	/// @param dst the SDL_IOStream to write to.<br/>
	/// @param value the byte value to write.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteU8")]
	public static partial SDLBool SDL_WriteU8(SDL_IOStream dst, byte value);

	/// <summary>
	/// Use this function to write a signed byte to an SDL_IOStream.<br/>
	/// <br/>
	/// @param dst the SDL_IOStream to write to.<br/>
	/// @param value the byte value to write.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteS8")]
	public static partial SDLBool SDL_WriteS8(SDL_IOStream dst, sbyte value);

	/// <summary>
	/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
	/// little-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in little-endian<br/>
	/// format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteU16LE")]
	public static partial SDLBool SDL_WriteU16LE(SDL_IOStream dst, ushort value);

	/// <summary>
	/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
	/// little-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in little-endian<br/>
	/// format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteS16LE")]
	public static partial SDLBool SDL_WriteS16LE(SDL_IOStream dst, short value);

	/// <summary>
	/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
	/// big-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in big-endian format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteU16BE")]
	public static partial SDLBool SDL_WriteU16BE(SDL_IOStream dst, ushort value);

	/// <summary>
	/// Use this function to write 16 bits in native format to an SDL_IOStream as<br/>
	/// big-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in big-endian format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteS16BE")]
	public static partial SDLBool SDL_WriteS16BE(SDL_IOStream dst, short value);

	/// <summary>
	/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
	/// little-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in little-endian<br/>
	/// format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteU32LE")]
	public static partial SDLBool SDL_WriteU32LE(SDL_IOStream dst, uint value);

	/// <summary>
	/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
	/// little-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in little-endian<br/>
	/// format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteS32LE")]
	public static partial SDLBool SDL_WriteS32LE(SDL_IOStream dst, int value);

	/// <summary>
	/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
	/// big-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in big-endian format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteU32BE")]
	public static partial SDLBool SDL_WriteU32BE(SDL_IOStream dst, uint value);

	/// <summary>
	/// Use this function to write 32 bits in native format to an SDL_IOStream as<br/>
	/// big-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in big-endian format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteS32BE")]
	public static partial SDLBool SDL_WriteS32BE(SDL_IOStream dst, int value);

	/// <summary>
	/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
	/// little-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in little-endian<br/>
	/// format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteU64LE")]
	public static partial SDLBool SDL_WriteU64LE(SDL_IOStream dst, ulong value);

	/// <summary>
	/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
	/// little-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in little-endian<br/>
	/// format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteS64LE")]
	public static partial SDLBool SDL_WriteS64LE(SDL_IOStream dst, long value);

	/// <summary>
	/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
	/// big-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in big-endian format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteU64BE")]
	public static partial SDLBool SDL_WriteU64BE(SDL_IOStream dst, ulong value);

	/// <summary>
	/// Use this function to write 64 bits in native format to an SDL_IOStream as<br/>
	/// big-endian data.<br/>
	/// SDL byteswaps the data only if necessary, so the application always<br/>
	/// specifies native format, and the data written will be in big-endian format.<br/>
	/// <br/>
	/// @param dst the stream to which data will be written.<br/>
	/// @param value the data to be written, in native format.<br/>
	/// @returns true on successful write or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteS64BE")]
	public static partial SDLBool SDL_WriteS64BE(SDL_IOStream dst, long value);

	/// <summary>
	/// Locking for atomic access to the joystick API.<br/>
	/// The SDL joystick functions are thread-safe, however you can lock the<br/>
	/// joysticks while processing to guarantee that the joystick list won't change<br/>
	/// and joystick and gamepad events will not be delivered.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LockJoysticks")]
	public static partial void SDL_LockJoysticks();

	/// <summary>
	/// Unlocking for atomic access to the joystick API.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnlockJoysticks")]
	public static partial void SDL_UnlockJoysticks();

	/// <summary>
	/// Return whether a joystick is currently connected.<br/>
	/// <br/>
	/// @returns true if a joystick is connected, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoysticks
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasJoystick")]
	public static partial SDLBool SDL_HasJoystick();

	/// <summary>
	/// Get a list of currently connected joysticks.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of joysticks returned, may<br/>
	/// be NULL.<br/>
	/// @returns a 0 terminated array of joystick instance IDs or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This should be freed<br/>
	/// with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasJoystick<br/>
	/// @sa SDL_OpenJoystick
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoysticks")]
	public static partial SDL_JoystickID* SDL_GetJoysticks(out int count);

	/// <summary>
	/// Get the implementation dependent name of a joystick.<br/>
	/// This can be called before any joysticks are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the name of the selected joystick. If no name can be found, this<br/>
	/// function returns NULL; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickName<br/>
	/// @sa SDL_GetJoysticks
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickNameForID")]
	public static partial byte* SDL_GetJoystickNameForIDPtr(SDL_JoystickID instance_id);

	public static string? SDL_GetJoystickNameForID(SDL_JoystickID instance_id)
	{
		return ConvertToManaged(SDL_GetJoystickNameForIDPtr(instance_id));
	}

	/// <summary>
	/// Get the implementation dependent path of a joystick.<br/>
	/// This can be called before any joysticks are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the path of the selected joystick. If no path can be found, this<br/>
	/// function returns NULL; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickPath<br/>
	/// @sa SDL_GetJoysticks
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickPathForID")]
	public static partial byte* SDL_GetJoystickPathForIDPtr(SDL_JoystickID instance_id);

	public static string? SDL_GetJoystickPathForID(SDL_JoystickID instance_id)
	{
		return ConvertToManaged(SDL_GetJoystickPathForIDPtr(instance_id));
	}

	/// <summary>
	/// Get the player index of a joystick.<br/>
	/// This can be called before any joysticks are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the player index of a joystick, or -1 if it's not available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickPlayerIndex<br/>
	/// @sa SDL_GetJoysticks
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickPlayerIndexForID")]
	public static partial int SDL_GetJoystickPlayerIndexForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the implementation-dependent GUID of a joystick.<br/>
	/// This can be called before any joysticks are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the GUID of the selected joystick. If called with an invalid<br/>
	/// instance_id, this function returns a zero GUID.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickGUID<br/>
	/// @sa SDL_GUIDToString
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickGUIDForID")]
	public static partial Guid SDL_GetJoystickGUIDForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the USB vendor ID of a joystick, if available.<br/>
	/// This can be called before any joysticks are opened. If the vendor ID isn't<br/>
	/// available this function returns 0.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the USB vendor ID of the selected joystick. If called with an<br/>
	/// invalid instance_id, this function returns 0.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickVendor<br/>
	/// @sa SDL_GetJoysticks
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickVendorForID")]
	public static partial ushort SDL_GetJoystickVendorForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the USB product ID of a joystick, if available.<br/>
	/// This can be called before any joysticks are opened. If the product ID isn't<br/>
	/// available this function returns 0.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the USB product ID of the selected joystick. If called with an<br/>
	/// invalid instance_id, this function returns 0.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickProduct<br/>
	/// @sa SDL_GetJoysticks
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickProductForID")]
	public static partial ushort SDL_GetJoystickProductForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the product version of a joystick, if available.<br/>
	/// This can be called before any joysticks are opened. If the product version<br/>
	/// isn't available this function returns 0.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the product version of the selected joystick. If called with an<br/>
	/// invalid instance_id, this function returns 0.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickProductVersion<br/>
	/// @sa SDL_GetJoysticks
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickProductVersionForID")]
	public static partial ushort SDL_GetJoystickProductVersionForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the type of a joystick, if available.<br/>
	/// This can be called before any joysticks are opened.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns the SDL_JoystickType of the selected joystick. If called with an<br/>
	/// invalid instance_id, this function returns<br/>
	/// `SDL_JOYSTICK_TYPE_UNKNOWN`.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickType<br/>
	/// @sa SDL_GetJoysticks
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickTypeForID")]
	public static partial SDL_JoystickType SDL_GetJoystickTypeForID(SDL_JoystickID instance_id);

	/// <summary>
	/// Open a joystick for use.<br/>
	/// The joystick subsystem must be initialized before a joystick can be opened<br/>
	/// for use.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns a joystick identifier or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseJoystick
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenJoystick")]
	public static partial SDL_Joystick SDL_OpenJoystick(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the SDL_Joystick associated with an instance ID, if it has been opened.<br/>
	/// <br/>
	/// @param instance_id the instance ID to get the SDL_Joystick for.<br/>
	/// @returns an SDL_Joystick on success or NULL on failure or if it hasn't been<br/>
	/// opened yet; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickFromID")]
	public static partial SDL_Joystick SDL_GetJoystickFromID(SDL_JoystickID instance_id);

	/// <summary>
	/// Get the SDL_Joystick associated with a player index.<br/>
	/// <br/>
	/// @param player_index the player index to get the SDL_Joystick for.<br/>
	/// @returns an SDL_Joystick on success or NULL on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickPlayerIndex<br/>
	/// @sa SDL_SetJoystickPlayerIndex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickFromPlayerIndex")]
	public static partial SDL_Joystick SDL_GetJoystickFromPlayerIndex(int player_index);

	/// <summary>
	/// Attach a new virtual joystick.<br/>
	/// <br/>
	/// @param desc joystick description, initialized using SDL_INIT_INTERFACE().<br/>
	/// @returns the joystick instance ID, or 0 on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DetachVirtualJoystick
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AttachVirtualJoystick")]
	public static partial SDL_JoystickID SDL_AttachVirtualJoystick(SDL_VirtualJoystickDesc* desc);

	/// <summary>
	/// Detach a virtual joystick.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID, previously returned from<br/>
	/// SDL_AttachVirtualJoystick().<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AttachVirtualJoystick
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DetachVirtualJoystick")]
	public static partial SDLBool SDL_DetachVirtualJoystick(SDL_JoystickID instance_id);

	/// <summary>
	/// Query whether or not a joystick is virtual.<br/>
	/// <br/>
	/// @param instance_id the joystick instance ID.<br/>
	/// @returns true if the joystick is virtual, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IsJoystickVirtual")]
	public static partial SDLBool SDL_IsJoystickVirtual(SDL_JoystickID instance_id);

	/// <summary>
	/// Set the state of an axis on an opened virtual joystick.<br/>
	/// Please note that values set here will not be applied until the next call to<br/>
	/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
	/// indirectly through various other SDL APIs, including, but not limited to<br/>
	/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
	/// SDL_WaitEvent.<br/>
	/// Note that when sending trigger axes, you should scale the value to the full<br/>
	/// range of Sint16. For example, a trigger at rest would have the value of<br/>
	/// `SDL_JOYSTICK_AXIS_MIN`.<br/>
	/// <br/>
	/// @param joystick the virtual joystick on which to set state.<br/>
	/// @param axis the index of the axis on the virtual joystick to update.<br/>
	/// @param value the new value for the specified axis.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetJoystickVirtualAxis")]
	public static partial SDLBool SDL_SetJoystickVirtualAxis(SDL_Joystick joystick, int axis, short value);

	/// <summary>
	/// Generate ball motion on an opened virtual joystick.<br/>
	/// Please note that values set here will not be applied until the next call to<br/>
	/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
	/// indirectly through various other SDL APIs, including, but not limited to<br/>
	/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
	/// SDL_WaitEvent.<br/>
	/// <br/>
	/// @param joystick the virtual joystick on which to set state.<br/>
	/// @param ball the index of the ball on the virtual joystick to update.<br/>
	/// @param xrel the relative motion on the X axis.<br/>
	/// @param yrel the relative motion on the Y axis.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetJoystickVirtualBall")]
	public static partial SDLBool SDL_SetJoystickVirtualBall(SDL_Joystick joystick, int ball, short xrel, short yrel);

	/// <summary>
	/// Set the state of a button on an opened virtual joystick.<br/>
	/// Please note that values set here will not be applied until the next call to<br/>
	/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
	/// indirectly through various other SDL APIs, including, but not limited to<br/>
	/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
	/// SDL_WaitEvent.<br/>
	/// <br/>
	/// @param joystick the virtual joystick on which to set state.<br/>
	/// @param button the index of the button on the virtual joystick to update.<br/>
	/// @param down true if the button is pressed, false otherwise.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetJoystickVirtualButton")]
	public static partial SDLBool SDL_SetJoystickVirtualButton(SDL_Joystick joystick, int button, SDLBool down);

	/// <summary>
	/// Set the state of a hat on an opened virtual joystick.<br/>
	/// Please note that values set here will not be applied until the next call to<br/>
	/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
	/// indirectly through various other SDL APIs, including, but not limited to<br/>
	/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
	/// SDL_WaitEvent.<br/>
	/// <br/>
	/// @param joystick the virtual joystick on which to set state.<br/>
	/// @param hat the index of the hat on the virtual joystick to update.<br/>
	/// @param value the new value for the specified hat.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetJoystickVirtualHat")]
	public static partial SDLBool SDL_SetJoystickVirtualHat(SDL_Joystick joystick, int hat, byte value);

	/// <summary>
	/// Set touchpad finger state on an opened virtual joystick.<br/>
	/// Please note that values set here will not be applied until the next call to<br/>
	/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
	/// indirectly through various other SDL APIs, including, but not limited to<br/>
	/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
	/// SDL_WaitEvent.<br/>
	/// <br/>
	/// @param joystick the virtual joystick on which to set state.<br/>
	/// @param touchpad the index of the touchpad on the virtual joystick to<br/>
	/// update.<br/>
	/// @param finger the index of the finger on the touchpad to set.<br/>
	/// @param down true if the finger is pressed, false if the finger is released.<br/>
	/// @param x the x coordinate of the finger on the touchpad, normalized 0 to 1,<br/>
	/// with the origin in the upper left.<br/>
	/// @param y the y coordinate of the finger on the touchpad, normalized 0 to 1,<br/>
	/// with the origin in the upper left.<br/>
	/// @param pressure the pressure of the finger.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetJoystickVirtualTouchpad")]
	public static partial SDLBool SDL_SetJoystickVirtualTouchpad(SDL_Joystick joystick, int touchpad, int finger, SDLBool down, float x, float y, float pressure);

	/// <summary>
	/// Send a sensor update for an opened virtual joystick.<br/>
	/// Please note that values set here will not be applied until the next call to<br/>
	/// SDL_UpdateJoysticks, which can either be called directly, or can be called<br/>
	/// indirectly through various other SDL APIs, including, but not limited to<br/>
	/// the following: SDL_PollEvent, SDL_PumpEvents, SDL_WaitEventTimeout,<br/>
	/// SDL_WaitEvent.<br/>
	/// <br/>
	/// @param joystick the virtual joystick on which to set state.<br/>
	/// @param type the type of the sensor on the virtual joystick to update.<br/>
	/// @param sensor_timestamp a 64-bit timestamp in nanoseconds associated with<br/>
	/// the sensor reading.<br/>
	/// @param data the data associated with the sensor reading.<br/>
	/// @param num_values the number of values pointed to by `data`.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SendJoystickVirtualSensorData")]
	public static partial SDLBool SDL_SendJoystickVirtualSensorData(SDL_Joystick joystick, SDL_SensorType type, ulong sensor_timestamp, float* data, int num_values);

	/// <summary>
	/// Get the properties associated with a joystick.<br/>
	/// The following read-only properties are provided by SDL:<br/>
	/// - `SDL_PROP_JOYSTICK_CAP_MONO_LED_BOOLEAN`: true if this joystick has an<br/>
	/// LED that has adjustable brightness<br/>
	/// - `SDL_PROP_JOYSTICK_CAP_RGB_LED_BOOLEAN`: true if this joystick has an LED<br/>
	/// that has adjustable color<br/>
	/// - `SDL_PROP_JOYSTICK_CAP_PLAYER_LED_BOOLEAN`: true if this joystick has a<br/>
	/// player LED<br/>
	/// - `SDL_PROP_JOYSTICK_CAP_RUMBLE_BOOLEAN`: true if this joystick has<br/>
	/// left/right rumble<br/>
	/// - `SDL_PROP_JOYSTICK_CAP_TRIGGER_RUMBLE_BOOLEAN`: true if this joystick has<br/>
	/// simple trigger rumble<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickProperties")]
	public static partial SDL_PropertiesID SDL_GetJoystickProperties(SDL_Joystick joystick);

	/// <summary>
	/// Get the implementation dependent name of a joystick.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns the name of the selected joystick. If no name can be found, this<br/>
	/// function returns NULL; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickNameForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickName")]
	public static partial byte* SDL_GetJoystickNamePtr(SDL_Joystick joystick);

	public static string? SDL_GetJoystickName(SDL_Joystick joystick)
	{
		return ConvertToManaged(SDL_GetJoystickNamePtr(joystick));
	}

	/// <summary>
	/// Get the implementation dependent path of a joystick.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns the path of the selected joystick. If no path can be found, this<br/>
	/// function returns NULL; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickPathForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickPath")]
	public static partial byte* SDL_GetJoystickPathPtr(SDL_Joystick joystick);

	public static string? SDL_GetJoystickPath(SDL_Joystick joystick)
	{
		return ConvertToManaged(SDL_GetJoystickPathPtr(joystick));
	}

	/// <summary>
	/// Get the player index of an opened joystick.<br/>
	/// For XInput controllers this returns the XInput user index. Many joysticks<br/>
	/// will not be able to supply this information.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns the player index, or -1 if it's not available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetJoystickPlayerIndex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickPlayerIndex")]
	public static partial int SDL_GetJoystickPlayerIndex(SDL_Joystick joystick);

	/// <summary>
	/// Set the player index of an opened joystick.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @param player_index player index to assign to this joystick, or -1 to clear<br/>
	/// the player index and turn off player LEDs.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickPlayerIndex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetJoystickPlayerIndex")]
	public static partial SDLBool SDL_SetJoystickPlayerIndex(SDL_Joystick joystick, int player_index);

	/// <summary>
	/// Get the implementation-dependent GUID for the joystick.<br/>
	/// This function requires an open joystick.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns the GUID of the given joystick. If called on an invalid index,<br/>
	/// this function returns a zero GUID; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickGUIDForID<br/>
	/// @sa SDL_GUIDToString
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickGUID")]
	public static partial Guid SDL_GetJoystickGUID(SDL_Joystick joystick);

	/// <summary>
	/// Get the USB vendor ID of an opened joystick, if available.<br/>
	/// If the vendor ID isn't available this function returns 0.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns the USB vendor ID of the selected joystick, or 0 if unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickVendorForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickVendor")]
	public static partial ushort SDL_GetJoystickVendor(SDL_Joystick joystick);

	/// <summary>
	/// Get the USB product ID of an opened joystick, if available.<br/>
	/// If the product ID isn't available this function returns 0.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns the USB product ID of the selected joystick, or 0 if unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickProductForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickProduct")]
	public static partial ushort SDL_GetJoystickProduct(SDL_Joystick joystick);

	/// <summary>
	/// Get the product version of an opened joystick, if available.<br/>
	/// If the product version isn't available this function returns 0.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns the product version of the selected joystick, or 0 if unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickProductVersionForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickProductVersion")]
	public static partial ushort SDL_GetJoystickProductVersion(SDL_Joystick joystick);

	/// <summary>
	/// Get the firmware version of an opened joystick, if available.<br/>
	/// If the firmware version isn't available this function returns 0.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns the firmware version of the selected joystick, or 0 if<br/>
	/// unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickFirmwareVersion")]
	public static partial ushort SDL_GetJoystickFirmwareVersion(SDL_Joystick joystick);

	/// <summary>
	/// Get the serial number of an opened joystick, if available.<br/>
	/// Returns the serial number of the joystick, or NULL if it is not available.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns the serial number of the selected joystick, or NULL if<br/>
	/// unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickSerial")]
	public static partial byte* SDL_GetJoystickSerialPtr(SDL_Joystick joystick);

	public static string? SDL_GetJoystickSerial(SDL_Joystick joystick)
	{
		return ConvertToManaged(SDL_GetJoystickSerialPtr(joystick));
	}

	/// <summary>
	/// Get the type of an opened joystick.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick obtained from SDL_OpenJoystick().<br/>
	/// @returns the SDL_JoystickType of the selected joystick.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickTypeForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickType")]
	public static partial SDL_JoystickType SDL_GetJoystickType(SDL_Joystick joystick);

	/// <summary>
	/// Get the device information encoded in a SDL_GUID structure.<br/>
	/// <br/>
	/// @param guid the SDL_GUID you wish to get info about.<br/>
	/// @param vendor a pointer filled in with the device VID, or 0 if not<br/>
	/// available.<br/>
	/// @param product a pointer filled in with the device PID, or 0 if not<br/>
	/// available.<br/>
	/// @param version a pointer filled in with the device version, or 0 if not<br/>
	/// available.<br/>
	/// @param crc16 a pointer filled in with a CRC used to distinguish different<br/>
	/// products with the same VID/PID, or 0 if not available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickGUIDForID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickGUIDInfo")]
	public static partial void SDL_GetJoystickGUIDInfo(Guid guid, ushort* vendor, ushort* product, ushort* version, ushort* crc16);

	/// <summary>
	/// Get the status of a specified joystick.<br/>
	/// <br/>
	/// @param joystick the joystick to query.<br/>
	/// @returns true if the joystick has been opened, false if it has not; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_JoystickConnected")]
	public static partial SDLBool SDL_JoystickConnected(SDL_Joystick joystick);

	/// <summary>
	/// Get the instance ID of an opened joystick.<br/>
	/// <br/>
	/// @param joystick an SDL_Joystick structure containing joystick information.<br/>
	/// @returns the instance ID of the specified joystick on success or 0 on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickID")]
	public static partial SDL_JoystickID SDL_GetJoystickID(SDL_Joystick joystick);

	/// <summary>
	/// Get the number of general axis controls on a joystick.<br/>
	/// Often, the directional pad on a game controller will either look like 4<br/>
	/// separate buttons or a POV hat, and not axes, but all of this is up to the<br/>
	/// device and platform.<br/>
	/// <br/>
	/// @param joystick an SDL_Joystick structure containing joystick information.<br/>
	/// @returns the number of axis controls/number of axes on success or -1 on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickAxis<br/>
	/// @sa SDL_GetNumJoystickBalls<br/>
	/// @sa SDL_GetNumJoystickButtons<br/>
	/// @sa SDL_GetNumJoystickHats
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumJoystickAxes")]
	public static partial int SDL_GetNumJoystickAxes(SDL_Joystick joystick);

	/// <summary>
	/// Get the number of trackballs on a joystick.<br/>
	/// Joystick trackballs have only relative motion events associated with them<br/>
	/// and their state cannot be polled.<br/>
	/// Most joysticks do not have trackballs.<br/>
	/// <br/>
	/// @param joystick an SDL_Joystick structure containing joystick information.<br/>
	/// @returns the number of trackballs on success or -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickBall<br/>
	/// @sa SDL_GetNumJoystickAxes<br/>
	/// @sa SDL_GetNumJoystickButtons<br/>
	/// @sa SDL_GetNumJoystickHats
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumJoystickBalls")]
	public static partial int SDL_GetNumJoystickBalls(SDL_Joystick joystick);

	/// <summary>
	/// Get the number of POV hats on a joystick.<br/>
	/// <br/>
	/// @param joystick an SDL_Joystick structure containing joystick information.<br/>
	/// @returns the number of POV hats on success or -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickHat<br/>
	/// @sa SDL_GetNumJoystickAxes<br/>
	/// @sa SDL_GetNumJoystickBalls<br/>
	/// @sa SDL_GetNumJoystickButtons
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumJoystickHats")]
	public static partial int SDL_GetNumJoystickHats(SDL_Joystick joystick);

	/// <summary>
	/// Get the number of buttons on a joystick.<br/>
	/// <br/>
	/// @param joystick an SDL_Joystick structure containing joystick information.<br/>
	/// @returns the number of buttons on success or -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetJoystickButton<br/>
	/// @sa SDL_GetNumJoystickAxes<br/>
	/// @sa SDL_GetNumJoystickBalls<br/>
	/// @sa SDL_GetNumJoystickHats
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumJoystickButtons")]
	public static partial int SDL_GetNumJoystickButtons(SDL_Joystick joystick);

	/// <summary>
	/// Set the state of joystick event processing.<br/>
	/// If joystick events are disabled, you must call SDL_UpdateJoysticks()<br/>
	/// yourself and check the state of the joystick when you want joystick<br/>
	/// information.<br/>
	/// <br/>
	/// @param enabled whether to process joystick events or not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_JoystickEventsEnabled<br/>
	/// @sa SDL_UpdateJoysticks
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetJoystickEventsEnabled")]
	public static partial void SDL_SetJoystickEventsEnabled(SDLBool enabled);

	/// <summary>
	/// Query the state of joystick event processing.<br/>
	/// If joystick events are disabled, you must call SDL_UpdateJoysticks()<br/>
	/// yourself and check the state of the joystick when you want joystick<br/>
	/// information.<br/>
	/// <br/>
	/// @returns true if joystick events are being processed, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetJoystickEventsEnabled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_JoystickEventsEnabled")]
	public static partial SDLBool SDL_JoystickEventsEnabled();

	/// <summary>
	/// Update the current state of the open joysticks.<br/>
	/// This is called automatically by the event loop if any joystick events are<br/>
	/// enabled.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UpdateJoysticks")]
	public static partial void SDL_UpdateJoysticks();

	/// <summary>
	/// Get the current state of an axis control on a joystick.<br/>
	/// SDL makes no promises about what part of the joystick any given axis refers<br/>
	/// to. Your game should have some sort of configuration UI to let users<br/>
	/// specify what each axis should be bound to. Alternately, SDL's higher-level<br/>
	/// Game Controller API makes a great effort to apply order to this lower-level<br/>
	/// interface, so you know that a specific axis is the "left thumb stick," etc.<br/>
	/// The value returned by SDL_GetJoystickAxis() is a signed integer (-32768 to<br/>
	/// 32767) representing the current position of the axis. It may be necessary<br/>
	/// to impose certain tolerances on these values to account for jitter.<br/>
	/// <br/>
	/// @param joystick an SDL_Joystick structure containing joystick information.<br/>
	/// @param axis the axis to query; the axis indices start at index 0.<br/>
	/// @returns a 16-bit signed integer representing the current position of the<br/>
	/// axis or 0 on failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumJoystickAxes
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickAxis")]
	public static partial short SDL_GetJoystickAxis(SDL_Joystick joystick, int axis);

	/// <summary>
	/// Get the initial state of an axis control on a joystick.<br/>
	/// The state is a value ranging from -32768 to 32767.<br/>
	/// The axis indices start at index 0.<br/>
	/// <br/>
	/// @param joystick an SDL_Joystick structure containing joystick information.<br/>
	/// @param axis the axis to query; the axis indices start at index 0.<br/>
	/// @param state upon return, the initial value is supplied here.<br/>
	/// @returns true if this axis has any initial value, or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickAxisInitialState")]
	public static partial SDLBool SDL_GetJoystickAxisInitialState(SDL_Joystick joystick, int axis, short* state);

	/// <summary>
	/// Get the ball axis change since the last poll.<br/>
	/// Trackballs can only return relative motion since the last call to<br/>
	/// SDL_GetJoystickBall(), these motion deltas are placed into `dx` and `dy`.<br/>
	/// Most joysticks do not have trackballs.<br/>
	/// <br/>
	/// @param joystick the SDL_Joystick to query.<br/>
	/// @param ball the ball index to query; ball indices start at index 0.<br/>
	/// @param dx stores the difference in the x axis position since the last poll.<br/>
	/// @param dy stores the difference in the y axis position since the last poll.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumJoystickBalls
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickBall")]
	public static partial SDLBool SDL_GetJoystickBall(SDL_Joystick joystick, int ball, int* dx, int* dy);

	/// <summary>
	/// Get the current state of a POV hat on a joystick.<br/>
	/// The returned value will be one of the `SDL_HAT_*` values.<br/>
	/// <br/>
	/// @param joystick an SDL_Joystick structure containing joystick information.<br/>
	/// @param hat the hat index to get the state from; indices start at index 0.<br/>
	/// @returns the current hat position.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumJoystickHats
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickHat")]
	public static partial byte SDL_GetJoystickHat(SDL_Joystick joystick, int hat);

	/// <summary>
	/// Get the current state of a button on a joystick.<br/>
	/// <br/>
	/// @param joystick an SDL_Joystick structure containing joystick information.<br/>
	/// @param button the button index to get the state from; indices start at<br/>
	/// index 0.<br/>
	/// @returns true if the button is pressed, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumJoystickButtons
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickButton")]
	public static partial SDLBool SDL_GetJoystickButton(SDL_Joystick joystick, int button);

	/// <summary>
	/// Start a rumble effect.<br/>
	/// Each call to this function cancels any previous rumble effect, and calling<br/>
	/// it with 0 intensity stops any rumbling.<br/>
	/// This function requires you to process SDL events or call<br/>
	/// SDL_UpdateJoysticks() to update rumble state.<br/>
	/// <br/>
	/// @param joystick the joystick to vibrate.<br/>
	/// @param low_frequency_rumble the intensity of the low frequency (left)<br/>
	/// rumble motor, from 0 to 0xFFFF.<br/>
	/// @param high_frequency_rumble the intensity of the high frequency (right)<br/>
	/// rumble motor, from 0 to 0xFFFF.<br/>
	/// @param duration_ms the duration of the rumble effect, in milliseconds.<br/>
	/// @returns true, or false if rumble isn't supported on this joystick.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RumbleJoystick")]
	public static partial SDLBool SDL_RumbleJoystick(SDL_Joystick joystick, ushort low_frequency_rumble, ushort high_frequency_rumble, uint duration_ms);

	/// <summary>
	/// Start a rumble effect in the joystick's triggers.<br/>
	/// Each call to this function cancels any previous trigger rumble effect, and<br/>
	/// calling it with 0 intensity stops any rumbling.<br/>
	/// Note that this is rumbling of the _triggers_ and not the game controller as<br/>
	/// a whole. This is currently only supported on Xbox One controllers. If you<br/>
	/// want the (more common) whole-controller rumble, use SDL_RumbleJoystick()<br/>
	/// instead.<br/>
	/// This function requires you to process SDL events or call<br/>
	/// SDL_UpdateJoysticks() to update rumble state.<br/>
	/// <br/>
	/// @param joystick the joystick to vibrate.<br/>
	/// @param left_rumble the intensity of the left trigger rumble motor, from 0<br/>
	/// to 0xFFFF.<br/>
	/// @param right_rumble the intensity of the right trigger rumble motor, from 0<br/>
	/// to 0xFFFF.<br/>
	/// @param duration_ms the duration of the rumble effect, in milliseconds.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RumbleJoystick
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RumbleJoystickTriggers")]
	public static partial SDLBool SDL_RumbleJoystickTriggers(SDL_Joystick joystick, ushort left_rumble, ushort right_rumble, uint duration_ms);

	/// <summary>
	/// Update a joystick's LED color.<br/>
	/// An example of a joystick LED is the light on the back of a PlayStation 4's<br/>
	/// DualShock 4 controller.<br/>
	/// For joysticks with a single color LED, the maximum of the RGB values will<br/>
	/// be used as the LED brightness.<br/>
	/// <br/>
	/// @param joystick the joystick to update.<br/>
	/// @param red the intensity of the red LED.<br/>
	/// @param green the intensity of the green LED.<br/>
	/// @param blue the intensity of the blue LED.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetJoystickLED")]
	public static partial SDLBool SDL_SetJoystickLED(SDL_Joystick joystick, byte red, byte green, byte blue);

	/// <summary>
	/// Send a joystick specific effect packet.<br/>
	/// <br/>
	/// @param joystick the joystick to affect.<br/>
	/// @param data the data to send to the joystick.<br/>
	/// @param size the size of the data to send to the joystick.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SendJoystickEffect")]
	public static partial SDLBool SDL_SendJoystickEffect(SDL_Joystick joystick, nint data, int size);

	/// <summary>
	/// Close a joystick previously opened with SDL_OpenJoystick().<br/>
	/// <br/>
	/// @param joystick the joystick device to close.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenJoystick
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CloseJoystick")]
	public static partial void SDL_CloseJoystick(SDL_Joystick joystick);

	/// <summary>
	/// Get the connection state of a joystick.<br/>
	/// <br/>
	/// @param joystick the joystick to query.<br/>
	/// @returns the connection state on success or<br/>
	/// `SDL_JOYSTICK_CONNECTION_INVALID` on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickConnectionState")]
	public static partial SDL_JoystickConnectionState SDL_GetJoystickConnectionState(SDL_Joystick joystick);

	/// <summary>
	/// Get the battery state of a joystick.<br/>
	/// You should never take a battery status as absolute truth. Batteries<br/>
	/// (especially failing batteries) are delicate hardware, and the values<br/>
	/// reported here are best estimates based on what that hardware reports. It's<br/>
	/// not uncommon for older batteries to lose stored power much faster than it<br/>
	/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
	/// <br/>
	/// @param joystick the joystick to query.<br/>
	/// @param percent a pointer filled in with the percentage of battery life<br/>
	/// left, between 0 and 100, or NULL to ignore. This will be<br/>
	/// filled in with -1 we can't determine a value or there is no<br/>
	/// battery.<br/>
	/// @returns the current battery state or `SDL_POWERSTATE_ERROR` on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetJoystickPowerInfo")]
	public static partial SDL_PowerState SDL_GetJoystickPowerInfo(SDL_Joystick joystick, int* percent);

	/// <summary>
	/// Return whether a keyboard is currently connected.<br/>
	/// <br/>
	/// @returns true if a keyboard is connected, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetKeyboards
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasKeyboard")]
	public static partial SDLBool SDL_HasKeyboard();

	/// <summary>
	/// Get a list of currently connected keyboards.<br/>
	/// Note that this will include any device or virtual driver that includes<br/>
	/// keyboard functionality, including some mice, KVM switches, motherboard<br/>
	/// power buttons, etc. You should wait for input from a device before you<br/>
	/// consider it actively in use.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of keyboards returned, may<br/>
	/// be NULL.<br/>
	/// @returns a 0 terminated array of keyboards instance IDs or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This should be freed<br/>
	/// with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetKeyboardNameForID<br/>
	/// @sa SDL_HasKeyboard
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetKeyboards")]
	public static partial SDL_KeyboardID* SDL_GetKeyboards(out int count);

	/// <summary>
	/// Get the name of a keyboard.<br/>
	/// This function returns "" if the keyboard doesn't have a name.<br/>
	/// <br/>
	/// @param instance_id the keyboard instance ID.<br/>
	/// @returns the name of the selected keyboard or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetKeyboards
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetKeyboardNameForID")]
	public static partial byte* SDL_GetKeyboardNameForIDPtr(SDL_KeyboardID instance_id);

	public static string? SDL_GetKeyboardNameForID(SDL_KeyboardID instance_id)
	{
		return ConvertToManaged(SDL_GetKeyboardNameForIDPtr(instance_id));
	}

	/// <summary>
	/// Query the window which currently has keyboard focus.<br/>
	/// <br/>
	/// @returns the window with keyboard focus.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetKeyboardFocus")]
	public static partial SDL_Window SDL_GetKeyboardFocus();

	/// <summary>
	/// Get a snapshot of the current state of the keyboard.<br/>
	/// The pointer returned is a pointer to an internal SDL array. It will be<br/>
	/// valid for the whole lifetime of the application and should not be freed by<br/>
	/// the caller.<br/>
	/// A array element with a value of true means that the key is pressed and a<br/>
	/// value of false means that it is not. Indexes into this array are obtained<br/>
	/// by using SDL_Scancode values.<br/>
	/// Use SDL_PumpEvents() to update the state array.<br/>
	/// This function gives you the current state after all events have been<br/>
	/// processed, so if a key or button has been pressed and released before you<br/>
	/// process events, then the pressed state will never show up in the<br/>
	/// SDL_GetKeyboardState() calls.<br/>
	/// Note: This function doesn't take into account whether shift has been<br/>
	/// pressed or not.<br/>
	/// <br/>
	/// @param numkeys if non-NULL, receives the length of the returned array.<br/>
	/// @returns a pointer to an array of key states.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PumpEvents<br/>
	/// @sa SDL_ResetKeyboard
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetKeyboardState")]
	public static partial SDLBool* SDL_GetKeyboardState(int* numkeys);

	/// <summary>
	/// Clear the state of the keyboard.<br/>
	/// This function will generate key up events for all pressed keys.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetKeyboardState
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ResetKeyboard")]
	public static partial void SDL_ResetKeyboard();

	/// <summary>
	/// Get the current key modifier state for the keyboard.<br/>
	/// <br/>
	/// @returns an OR'd combination of the modifier keys for the keyboard. See<br/>
	/// SDL_Keymod for details.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetKeyboardState<br/>
	/// @sa SDL_SetModState
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetModState")]
	public static partial SDL_Keymod SDL_GetModState();

	/// <summary>
	/// Set the current key modifier state for the keyboard.<br/>
	/// The inverse of SDL_GetModState(), SDL_SetModState() allows you to impose<br/>
	/// modifier key states on your application. Simply pass your desired modifier<br/>
	/// states into `modstate`. This value may be a bitwise, OR'd combination of<br/>
	/// SDL_Keymod values.<br/>
	/// This does not change the keyboard state, only the key modifier flags that<br/>
	/// SDL reports.<br/>
	/// <br/>
	/// @param modstate the desired SDL_Keymod for the keyboard.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetModState
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetModState")]
	public static partial void SDL_SetModState(SDL_Keymod modstate);

	/// <summary>
	/// Get the key code corresponding to the given scancode according to the<br/>
	/// current keyboard layout.<br/>
	/// If you want to get the keycode as it would be delivered in key events,<br/>
	/// including options specified in SDL_HINT_KEYCODE_OPTIONS, then you should<br/>
	/// pass `key_event` as true. Otherwise this function simply translates the<br/>
	/// scancode based on the given modifier state.<br/>
	/// <br/>
	/// @param scancode the desired SDL_Scancode to query.<br/>
	/// @param modstate the modifier state to use when translating the scancode to<br/>
	/// a keycode.<br/>
	/// @param key_event true if the keycode will be used in key events.<br/>
	/// @returns the SDL_Keycode that corresponds to the given SDL_Scancode.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetKeyName<br/>
	/// @sa SDL_GetScancodeFromKey
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetKeyFromScancode")]
	public static partial SDL_Keycode SDL_GetKeyFromScancode(SDL_Scancode scancode, SDL_Keymod modstate, SDLBool key_event);

	/// <summary>
	/// Get the scancode corresponding to the given key code according to the<br/>
	/// current keyboard layout.<br/>
	/// Note that there may be multiple scancode+modifier states that can generate<br/>
	/// this keycode, this will just return the first one found.<br/>
	/// <br/>
	/// @param key the desired SDL_Keycode to query.<br/>
	/// @param modstate a pointer to the modifier state that would be used when the<br/>
	/// scancode generates this key, may be NULL.<br/>
	/// @returns the SDL_Scancode that corresponds to the given SDL_Keycode.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetKeyFromScancode<br/>
	/// @sa SDL_GetScancodeName
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetScancodeFromKey")]
	public static partial SDL_Scancode SDL_GetScancodeFromKey(SDL_Keycode key, SDL_Keymod* modstate);

	/// <summary>
	/// Set a human-readable name for a scancode.<br/>
	/// <br/>
	/// @param scancode the desired SDL_Scancode.<br/>
	/// @param name the name to use for the scancode, encoded as UTF-8. The string<br/>
	/// is not copied, so the pointer given to this function must stay<br/>
	/// valid while SDL is being used.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetScancodeName
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetScancodeName")]
	public static partial SDLBool SDL_SetScancodeName(SDL_Scancode scancode, byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_SetScancodeName")]
	public static partial SDLBool SDL_SetScancodeName(SDL_Scancode scancode, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_SetScancodeName")]
	public static partial SDLBool SDL_SetScancodeName(SDL_Scancode scancode, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Get a human-readable name for a scancode.<br/>
	/// **Warning**: The returned name is by design not stable across platforms,<br/>
	/// e.g. the name for `SDL_SCANCODE_LGUI` is "Left GUI" under Linux but "Left<br/>
	/// Windows" under Microsoft Windows, and some scancodes like<br/>
	/// `SDL_SCANCODE_NONUSBACKSLASH` don't have any name at all. There are even<br/>
	/// scancodes that share names, e.g. `SDL_SCANCODE_RETURN` and<br/>
	/// `SDL_SCANCODE_RETURN2` (both called "Return"). This function is therefore<br/>
	/// unsuitable for creating a stable cross-platform two-way mapping between<br/>
	/// strings and scancodes.<br/>
	/// <br/>
	/// @param scancode the desired SDL_Scancode to query.<br/>
	/// @returns a pointer to the name for the scancode. If the scancode doesn't<br/>
	/// have a name this function returns an empty string ("").<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetScancodeFromKey<br/>
	/// @sa SDL_GetScancodeFromName<br/>
	/// @sa SDL_SetScancodeName
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetScancodeName")]
	public static partial byte* SDL_GetScancodeNamePtr(SDL_Scancode scancode);

	public static string? SDL_GetScancodeName(SDL_Scancode scancode)
	{
		return ConvertToManaged(SDL_GetScancodeNamePtr(scancode));
	}

	/// <summary>
	/// Get a scancode from a human-readable name.<br/>
	/// <br/>
	/// @param name the human-readable scancode name.<br/>
	/// @returns the SDL_Scancode, or `SDL_SCANCODE_UNKNOWN` if the name wasn't<br/>
	/// recognized; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetKeyFromName<br/>
	/// @sa SDL_GetScancodeFromKey<br/>
	/// @sa SDL_GetScancodeName
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetScancodeFromName")]
	public static partial SDL_Scancode SDL_GetScancodeFromName(byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_GetScancodeFromName")]
	public static partial SDL_Scancode SDL_GetScancodeFromName(ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_GetScancodeFromName")]
	public static partial SDL_Scancode SDL_GetScancodeFromName([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Get a human-readable name for a key.<br/>
	/// If the key doesn't have a name, this function returns an empty string ("").<br/>
	/// <br/>
	/// @param key the desired SDL_Keycode to query.<br/>
	/// @returns a UTF-8 encoded string of the key name.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetKeyFromName<br/>
	/// @sa SDL_GetKeyFromScancode<br/>
	/// @sa SDL_GetScancodeFromKey
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetKeyName")]
	public static partial byte* SDL_GetKeyNamePtr(SDL_Keycode key);

	public static string? SDL_GetKeyName(SDL_Keycode key)
	{
		return ConvertToManaged(SDL_GetKeyNamePtr(key));
	}

	/// <summary>
	/// Get a key code from a human-readable name.<br/>
	/// <br/>
	/// @param name the human-readable key name.<br/>
	/// @returns key code, or `SDLK_UNKNOWN` if the name wasn't recognized; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetKeyFromScancode<br/>
	/// @sa SDL_GetKeyName<br/>
	/// @sa SDL_GetScancodeFromName
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetKeyFromName")]
	public static partial SDL_Keycode SDL_GetKeyFromName(byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_GetKeyFromName")]
	public static partial SDL_Keycode SDL_GetKeyFromName(ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_GetKeyFromName")]
	public static partial SDL_Keycode SDL_GetKeyFromName([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Start accepting Unicode text input events in a window.<br/>
	/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
	/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
	/// function paired with SDL_StopTextInput().<br/>
	/// Text input events are not received by default.<br/>
	/// On some platforms using this function shows the screen keyboard.<br/>
	/// <br/>
	/// @param window the window to enable text input.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetTextInputArea<br/>
	/// @sa SDL_StartTextInputWithProperties<br/>
	/// @sa SDL_StopTextInput<br/>
	/// @sa SDL_TextInputActive
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_StartTextInput")]
	public static partial SDLBool SDL_StartTextInput(SDL_Window window);

	/// <summary>
	/// Start accepting Unicode text input events in a window, with properties<br/>
	/// describing the input.<br/>
	/// This function will enable text input (SDL_EVENT_TEXT_INPUT and<br/>
	/// SDL_EVENT_TEXT_EDITING events) in the specified window. Please use this<br/>
	/// function paired with SDL_StopTextInput().<br/>
	/// Text input events are not received by default.<br/>
	/// On some platforms using this function shows the screen keyboard.<br/>
	/// These are the supported properties:<br/>
	/// - `SDL_PROP_TEXTINPUT_TYPE_NUMBER` - an SDL_TextInputType value that<br/>
	/// describes text being input, defaults to SDL_TEXTINPUT_TYPE_TEXT.<br/>
	/// - `SDL_PROP_TEXTINPUT_CAPITALIZATION_NUMBER` - an SDL_Capitalization value<br/>
	/// that describes how text should be capitalized, defaults to<br/>
	/// SDL_CAPITALIZE_SENTENCES for normal text entry, SDL_CAPITALIZE_WORDS for<br/>
	/// SDL_TEXTINPUT_TYPE_TEXT_NAME, and SDL_CAPITALIZE_NONE for e-mail<br/>
	/// addresses, usernames, and passwords.<br/>
	/// - `SDL_PROP_TEXTINPUT_AUTOCORRECT_BOOLEAN` - true to enable auto completion<br/>
	/// and auto correction, defaults to true.<br/>
	/// - `SDL_PROP_TEXTINPUT_MULTILINE_BOOLEAN` - true if multiple lines of text<br/>
	/// are allowed. This defaults to true if SDL_HINT_RETURN_KEY_HIDES_IME is<br/>
	/// "0" or is not set, and defaults to false if SDL_HINT_RETURN_KEY_HIDES_IME<br/>
	/// is "1".<br/>
	/// On Android you can directly specify the input type:<br/>
	/// - `SDL_PROP_TEXTINPUT_ANDROID_INPUTTYPE_NUMBER` - the text input type to<br/>
	/// use, overriding other properties. This is documented at<br/>
	/// https://developer.android.com/reference/android/text/InputType<br/>
	/// <br/>
	/// @param window the window to enable text input.<br/>
	/// @param props the properties to use.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetTextInputArea<br/>
	/// @sa SDL_StartTextInput<br/>
	/// @sa SDL_StopTextInput<br/>
	/// @sa SDL_TextInputActive
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_StartTextInputWithProperties")]
	public static partial SDLBool SDL_StartTextInputWithProperties(SDL_Window window, SDL_PropertiesID props);

	/// <summary>
	/// Check whether or not Unicode text input events are enabled for a window.<br/>
	/// <br/>
	/// @param window the window to check.<br/>
	/// @returns true if text input events are enabled else false.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StartTextInput
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_TextInputActive")]
	public static partial SDLBool SDL_TextInputActive(SDL_Window window);

	/// <summary>
	/// Stop receiving any text input events in a window.<br/>
	/// If SDL_StartTextInput() showed the screen keyboard, this function will hide<br/>
	/// it.<br/>
	/// <br/>
	/// @param window the window to disable text input.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StartTextInput
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_StopTextInput")]
	public static partial SDLBool SDL_StopTextInput(SDL_Window window);

	/// <summary>
	/// Dismiss the composition window/IME without disabling the subsystem.<br/>
	/// <br/>
	/// @param window the window to affect.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StartTextInput<br/>
	/// @sa SDL_StopTextInput
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ClearComposition")]
	public static partial SDLBool SDL_ClearComposition(SDL_Window window);

	/// <summary>
	/// Set the area used to type Unicode text input.<br/>
	/// Native input methods may place a window with word suggestions near the<br/>
	/// cursor, without covering the text being entered.<br/>
	/// <br/>
	/// @param window the window for which to set the text input area.<br/>
	/// @param rect the SDL_Rect representing the text input area, in window<br/>
	/// coordinates, or NULL to clear it.<br/>
	/// @param cursor the offset of the current cursor location relative to<br/>
	/// `rect->x`, in window coordinates.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextInputArea<br/>
	/// @sa SDL_StartTextInput
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetTextInputArea")]
	public static partial SDLBool SDL_SetTextInputArea(SDL_Window window, Rectangle* rect, int cursor);

	/// <summary>
	/// Get the area used to type Unicode text input.<br/>
	/// This returns the values previously set by SDL_SetTextInputArea().<br/>
	/// <br/>
	/// @param window the window for which to query the text input area.<br/>
	/// @param rect a pointer to an SDL_Rect filled in with the text input area,<br/>
	/// may be NULL.<br/>
	/// @param cursor a pointer to the offset of the current cursor location<br/>
	/// relative to `rect->x`, may be NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetTextInputArea
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTextInputArea")]
	public static partial SDLBool SDL_GetTextInputArea(SDL_Window window, Rectangle* rect, int* cursor);

	/// <summary>
	/// Check whether the platform has screen keyboard support.<br/>
	/// <br/>
	/// @returns true if the platform has some screen keyboard support or false if<br/>
	/// not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StartTextInput<br/>
	/// @sa SDL_ScreenKeyboardShown
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasScreenKeyboardSupport")]
	public static partial SDLBool SDL_HasScreenKeyboardSupport();

	/// <summary>
	/// Check whether the screen keyboard is shown for given window.<br/>
	/// <br/>
	/// @param window the window for which screen keyboard should be queried.<br/>
	/// @returns true if screen keyboard is shown or false if not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasScreenKeyboardSupport
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ScreenKeyboardShown")]
	public static partial SDLBool SDL_ScreenKeyboardShown(SDL_Window window);

	/// <summary>
	/// Dynamically load a shared object.<br/>
	/// <br/>
	/// @param sofile a system-dependent name of the object file.<br/>
	/// @returns an opaque pointer to the object handle or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LoadFunction<br/>
	/// @sa SDL_UnloadObject
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LoadObject")]
	public static partial SDL_SharedObject SDL_LoadObject(byte* sofile);

	[LibraryImport(LibName, EntryPoint = "SDL_LoadObject")]
	public static partial SDL_SharedObject SDL_LoadObject(ReadOnlySpan<byte> sofile);

	[LibraryImport(LibName, EntryPoint = "SDL_LoadObject")]
	public static partial SDL_SharedObject SDL_LoadObject([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> sofile);

	/// <summary>
	/// Look up the address of the named function in a shared object.<br/>
	/// This function pointer is no longer valid after calling SDL_UnloadObject().<br/>
	/// This function can only look up C function names. Other languages may have<br/>
	/// name mangling and intrinsic language support that varies from compiler to<br/>
	/// compiler.<br/>
	/// Make sure you declare your function pointers with the same calling<br/>
	/// convention as the actual library function. Your code will crash<br/>
	/// mysteriously if you do not do this.<br/>
	/// If the requested function doesn't exist, NULL is returned.<br/>
	/// <br/>
	/// @param handle a valid shared object handle returned by SDL_LoadObject().<br/>
	/// @param name the name of the function to look up.<br/>
	/// @returns a pointer to the function or NULL on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LoadObject
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LoadFunction")]
	public static partial delegate* unmanaged[Cdecl]<void>* SDL_LoadFunction(SDL_SharedObject handle, byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_LoadFunction")]
	public static partial delegate* unmanaged[Cdecl]<void>* SDL_LoadFunction(SDL_SharedObject handle, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_LoadFunction")]
	public static partial delegate* unmanaged[Cdecl]<void>* SDL_LoadFunction(SDL_SharedObject handle, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Unload a shared object from memory.<br/>
	/// Note that any pointers from this object looked up through<br/>
	/// SDL_LoadFunction() will no longer be valid.<br/>
	/// <br/>
	/// @param handle a valid shared object handle returned by SDL_LoadObject().<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LoadObject
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnloadObject")]
	public static partial void SDL_UnloadObject(SDL_SharedObject handle);

	/// <summary>
	/// Report the user's preferred locale.<br/>
	/// Returned language strings are in the format xx, where 'xx' is an ISO-639<br/>
	/// language specifier (such as "en" for English, "de" for German, etc).<br/>
	/// Country strings are in the format YY, where "YY" is an ISO-3166 country<br/>
	/// code (such as "US" for the United States, "CA" for Canada, etc). Country<br/>
	/// might be NULL if there's no specific guidance on them (so you might get {<br/>
	/// "en", "US" } for American English, but { "en", NULL } means "English<br/>
	/// language, generically"). Language strings are never NULL, except to<br/>
	/// terminate the array.<br/>
	/// Please note that not all of these strings are 2 characters; some are three<br/>
	/// or more.<br/>
	/// The returned list of locales are in the order of the user's preference. For<br/>
	/// example, a German citizen that is fluent in US English and knows enough<br/>
	/// Japanese to navigate around Tokyo might have a list like: { "de", "en_US",<br/>
	/// "jp", NULL }. Someone from England might prefer British English (where<br/>
	/// "color" is spelled "colour", etc), but will settle for anything like it: {<br/>
	/// "en_GB", "en", NULL }.<br/>
	/// This function returns NULL on error, including when the platform does not<br/>
	/// supply this information at all.<br/>
	/// This might be a "slow" call that has to query the operating system. It's<br/>
	/// best to ask for this once and save the results. However, this list can<br/>
	/// change, usually because the user has changed a system preference outside of<br/>
	/// your program; SDL will send an SDL_EVENT_LOCALE_CHANGED event in this case,<br/>
	/// if possible, and you can call this function again to get an updated copy of<br/>
	/// preferred locales.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of locales returned, may<br/>
	/// be NULL.<br/>
	/// @returns a NULL terminated array of locale pointers, or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This is a single<br/>
	/// allocation that should be freed with SDL_free() when it is no<br/>
	/// longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPreferredLocales")]
	public static partial SDL_Locale** SDL_GetPreferredLocales(out int count);

	/// <summary>
	/// Set the priority of all log categories.<br/>
	/// <br/>
	/// @param priority the SDL_LogPriority to assign.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ResetLogPriorities<br/>
	/// @sa SDL_SetLogPriority
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetLogPriorities")]
	public static partial void SDL_SetLogPriorities(SDL_LogPriority priority);

	/// <summary>
	/// Set the priority of a particular log category.<br/>
	/// <br/>
	/// @param category the category to assign a priority to.<br/>
	/// @param priority the SDL_LogPriority to assign.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetLogPriority<br/>
	/// @sa SDL_ResetLogPriorities<br/>
	/// @sa SDL_SetLogPriorities
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetLogPriority")]
	public static partial void SDL_SetLogPriority(int category, SDL_LogPriority priority);

	/// <summary>
	/// Get the priority of a particular log category.<br/>
	/// <br/>
	/// @param category the category to query.<br/>
	/// @returns the SDL_LogPriority for the requested category.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetLogPriority
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetLogPriority")]
	public static partial SDL_LogPriority SDL_GetLogPriority(int category);

	/// <summary>
	/// Reset all priorities to default.<br/>
	/// This is called by SDL_Quit().<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetLogPriorities<br/>
	/// @sa SDL_SetLogPriority
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ResetLogPriorities")]
	public static partial void SDL_ResetLogPriorities();

	/// <summary>
	/// Set the text prepended to log messages of a given priority.<br/>
	/// By default SDL_LOG_PRIORITY_INFO and below have no prefix, and<br/>
	/// SDL_LOG_PRIORITY_WARN and higher have a prefix showing their priority, e.g.<br/>
	/// "WARNING: ".<br/>
	/// <br/>
	/// @param priority the SDL_LogPriority to modify.<br/>
	/// @param prefix the prefix to use for that log priority, or NULL to use no<br/>
	/// prefix.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetLogPriorities<br/>
	/// @sa SDL_SetLogPriority
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetLogPriorityPrefix")]
	public static partial SDLBool SDL_SetLogPriorityPrefix(SDL_LogPriority priority, byte* prefix);

	[LibraryImport(LibName, EntryPoint = "SDL_SetLogPriorityPrefix")]
	public static partial SDLBool SDL_SetLogPriorityPrefix(SDL_LogPriority priority, ReadOnlySpan<byte> prefix);

	[LibraryImport(LibName, EntryPoint = "SDL_SetLogPriorityPrefix")]
	public static partial SDLBool SDL_SetLogPriorityPrefix(SDL_LogPriority priority, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> prefix);

	/// <summary>
	/// Log a message with SDL_LOG_CATEGORY_APPLICATION and SDL_LOG_PRIORITY_INFO.<br/>
	/// <br/>
	/// @param fmt a printf() style message format string.<br/>
	/// @param ... additional parameters matching % tokens in the `fmt` string, if<br/>
	/// any.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LogCritical<br/>
	/// @sa SDL_LogDebug<br/>
	/// @sa SDL_LogError<br/>
	/// @sa SDL_LogInfo<br/>
	/// @sa SDL_LogMessage<br/>
	/// @sa SDL_LogMessageV<br/>
	/// @sa SDL_LogTrace<br/>
	/// @sa SDL_LogVerbose<br/>
	/// @sa SDL_LogWarn
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Log")]
	public static partial void SDL_Log(byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_Log")]
	public static partial void SDL_Log(ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_Log")]
	public static partial void SDL_Log([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	/// <summary>
	/// Log a message with SDL_LOG_PRIORITY_TRACE.<br/>
	/// <br/>
	/// @param category the category of the message.<br/>
	/// @param fmt a printf() style message format string.<br/>
	/// @param ... additional parameters matching % tokens in the **fmt** string,<br/>
	/// if any.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Log<br/>
	/// @sa SDL_LogCritical<br/>
	/// @sa SDL_LogDebug<br/>
	/// @sa SDL_LogError<br/>
	/// @sa SDL_LogInfo<br/>
	/// @sa SDL_LogMessage<br/>
	/// @sa SDL_LogMessageV<br/>
	/// @sa SDL_LogTrace<br/>
	/// @sa SDL_LogVerbose<br/>
	/// @sa SDL_LogWarn
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LogTrace")]
	public static partial void SDL_LogTrace(int category, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogTrace")]
	public static partial void SDL_LogTrace(int category, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogTrace")]
	public static partial void SDL_LogTrace(int category, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	/// <summary>
	/// Log a message with SDL_LOG_PRIORITY_VERBOSE.<br/>
	/// <br/>
	/// @param category the category of the message.<br/>
	/// @param fmt a printf() style message format string.<br/>
	/// @param ... additional parameters matching % tokens in the **fmt** string,<br/>
	/// if any.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Log<br/>
	/// @sa SDL_LogCritical<br/>
	/// @sa SDL_LogDebug<br/>
	/// @sa SDL_LogError<br/>
	/// @sa SDL_LogInfo<br/>
	/// @sa SDL_LogMessage<br/>
	/// @sa SDL_LogMessageV<br/>
	/// @sa SDL_LogWarn
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LogVerbose")]
	public static partial void SDL_LogVerbose(int category, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogVerbose")]
	public static partial void SDL_LogVerbose(int category, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogVerbose")]
	public static partial void SDL_LogVerbose(int category, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	/// <summary>
	/// Log a message with SDL_LOG_PRIORITY_DEBUG.<br/>
	/// <br/>
	/// @param category the category of the message.<br/>
	/// @param fmt a printf() style message format string.<br/>
	/// @param ... additional parameters matching % tokens in the **fmt** string,<br/>
	/// if any.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Log<br/>
	/// @sa SDL_LogCritical<br/>
	/// @sa SDL_LogError<br/>
	/// @sa SDL_LogInfo<br/>
	/// @sa SDL_LogMessage<br/>
	/// @sa SDL_LogMessageV<br/>
	/// @sa SDL_LogTrace<br/>
	/// @sa SDL_LogVerbose<br/>
	/// @sa SDL_LogWarn
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LogDebug")]
	public static partial void SDL_LogDebug(int category, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogDebug")]
	public static partial void SDL_LogDebug(int category, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogDebug")]
	public static partial void SDL_LogDebug(int category, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	/// <summary>
	/// Log a message with SDL_LOG_PRIORITY_INFO.<br/>
	/// <br/>
	/// @param category the category of the message.<br/>
	/// @param fmt a printf() style message format string.<br/>
	/// @param ... additional parameters matching % tokens in the **fmt** string,<br/>
	/// if any.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Log<br/>
	/// @sa SDL_LogCritical<br/>
	/// @sa SDL_LogDebug<br/>
	/// @sa SDL_LogError<br/>
	/// @sa SDL_LogMessage<br/>
	/// @sa SDL_LogMessageV<br/>
	/// @sa SDL_LogTrace<br/>
	/// @sa SDL_LogVerbose<br/>
	/// @sa SDL_LogWarn
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LogInfo")]
	public static partial void SDL_LogInfo(int category, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogInfo")]
	public static partial void SDL_LogInfo(int category, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogInfo")]
	public static partial void SDL_LogInfo(int category, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	/// <summary>
	/// Log a message with SDL_LOG_PRIORITY_WARN.<br/>
	/// <br/>
	/// @param category the category of the message.<br/>
	/// @param fmt a printf() style message format string.<br/>
	/// @param ... additional parameters matching % tokens in the **fmt** string,<br/>
	/// if any.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Log<br/>
	/// @sa SDL_LogCritical<br/>
	/// @sa SDL_LogDebug<br/>
	/// @sa SDL_LogError<br/>
	/// @sa SDL_LogInfo<br/>
	/// @sa SDL_LogMessage<br/>
	/// @sa SDL_LogMessageV<br/>
	/// @sa SDL_LogTrace<br/>
	/// @sa SDL_LogVerbose
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LogWarn")]
	public static partial void SDL_LogWarn(int category, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogWarn")]
	public static partial void SDL_LogWarn(int category, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogWarn")]
	public static partial void SDL_LogWarn(int category, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	/// <summary>
	/// Log a message with SDL_LOG_PRIORITY_ERROR.<br/>
	/// <br/>
	/// @param category the category of the message.<br/>
	/// @param fmt a printf() style message format string.<br/>
	/// @param ... additional parameters matching % tokens in the **fmt** string,<br/>
	/// if any.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Log<br/>
	/// @sa SDL_LogCritical<br/>
	/// @sa SDL_LogDebug<br/>
	/// @sa SDL_LogInfo<br/>
	/// @sa SDL_LogMessage<br/>
	/// @sa SDL_LogMessageV<br/>
	/// @sa SDL_LogTrace<br/>
	/// @sa SDL_LogVerbose<br/>
	/// @sa SDL_LogWarn
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LogError")]
	public static partial void SDL_LogError(int category, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogError")]
	public static partial void SDL_LogError(int category, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogError")]
	public static partial void SDL_LogError(int category, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	/// <summary>
	/// Log a message with SDL_LOG_PRIORITY_CRITICAL.<br/>
	/// <br/>
	/// @param category the category of the message.<br/>
	/// @param fmt a printf() style message format string.<br/>
	/// @param ... additional parameters matching % tokens in the **fmt** string,<br/>
	/// if any.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Log<br/>
	/// @sa SDL_LogDebug<br/>
	/// @sa SDL_LogError<br/>
	/// @sa SDL_LogInfo<br/>
	/// @sa SDL_LogMessage<br/>
	/// @sa SDL_LogMessageV<br/>
	/// @sa SDL_LogTrace<br/>
	/// @sa SDL_LogVerbose<br/>
	/// @sa SDL_LogWarn
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LogCritical")]
	public static partial void SDL_LogCritical(int category, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogCritical")]
	public static partial void SDL_LogCritical(int category, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogCritical")]
	public static partial void SDL_LogCritical(int category, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	/// <summary>
	/// Log a message with the specified category and priority.<br/>
	/// <br/>
	/// @param category the category of the message.<br/>
	/// @param priority the priority of the message.<br/>
	/// @param fmt a printf() style message format string.<br/>
	/// @param ... additional parameters matching % tokens in the **fmt** string,<br/>
	/// if any.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Log<br/>
	/// @sa SDL_LogCritical<br/>
	/// @sa SDL_LogDebug<br/>
	/// @sa SDL_LogError<br/>
	/// @sa SDL_LogInfo<br/>
	/// @sa SDL_LogMessageV<br/>
	/// @sa SDL_LogTrace<br/>
	/// @sa SDL_LogVerbose<br/>
	/// @sa SDL_LogWarn
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LogMessage")]
	public static partial void SDL_LogMessage(int category, SDL_LogPriority priority, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogMessage")]
	public static partial void SDL_LogMessage(int category, SDL_LogPriority priority, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_LogMessage")]
	public static partial void SDL_LogMessage(int category, SDL_LogPriority priority, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	/// <summary>
	/// Get the current log output function.<br/>
	/// <br/>
	/// @param callback an SDL_LogOutputFunction filled in with the current log<br/>
	/// callback.<br/>
	/// @param userdata a pointer filled in with the pointer that is passed to<br/>
	/// `callback`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetLogOutputFunction
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetLogOutputFunction")]
	public static partial void SDL_GetLogOutputFunction(delegate* unmanaged[Cdecl]<nint, int, SDL_LogPriority, byte*, void> callback, nint userdata);

	/// <summary>
	/// Replace the default log output function with one of your own.<br/>
	/// <br/>
	/// @param callback an SDL_LogOutputFunction to call instead of the default.<br/>
	/// @param userdata a pointer that is passed to `callback`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetLogOutputFunction
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetLogOutputFunction")]
	public static partial void SDL_SetLogOutputFunction(delegate* unmanaged[Cdecl]<nint, int, SDL_LogPriority, byte*, void> callback, nint userdata);

	/// <summary>
	/// Create a modal message box.<br/>
	/// If your needs aren't complex, it might be easier to use<br/>
	/// SDL_ShowSimpleMessageBox.<br/>
	/// This function should be called on the thread that created the parent<br/>
	/// window, or on the main thread if the messagebox has no parent. It will<br/>
	/// block execution of that thread until the user clicks a button or closes the<br/>
	/// messagebox.<br/>
	/// This function may be called at any time, even before SDL_Init(). This makes<br/>
	/// it useful for reporting errors like a failure to create a renderer or<br/>
	/// OpenGL context.<br/>
	/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
	/// formal toolkit like GTK+ or Qt.<br/>
	/// Note that if SDL_Init() would fail because there isn't any available video<br/>
	/// target, this function is likely to fail for the same reasons. If this is a<br/>
	/// concern, check the return value from this function and fall back to writing<br/>
	/// to stderr if you can.<br/>
	/// <br/>
	/// @param messageboxdata the SDL_MessageBoxData structure with title, text and<br/>
	/// other options.<br/>
	/// @param buttonid the pointer to which user id of hit button should be<br/>
	/// copied.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ShowSimpleMessageBox
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShowMessageBox")]
	public static partial SDLBool SDL_ShowMessageBox(SDL_MessageBoxData* messageboxdata, int* buttonid);

	/// <summary>
	/// Display a simple modal message box.<br/>
	/// If your needs aren't complex, this function is preferred over<br/>
	/// SDL_ShowMessageBox.<br/>
	/// `flags` may be any of the following:<br/>
	/// - `SDL_MESSAGEBOX_ERROR`: error dialog<br/>
	/// - `SDL_MESSAGEBOX_WARNING`: warning dialog<br/>
	/// - `SDL_MESSAGEBOX_INFORMATION`: informational dialog<br/>
	/// This function should be called on the thread that created the parent<br/>
	/// window, or on the main thread if the messagebox has no parent. It will<br/>
	/// block execution of that thread until the user clicks a button or closes the<br/>
	/// messagebox.<br/>
	/// This function may be called at any time, even before SDL_Init(). This makes<br/>
	/// it useful for reporting errors like a failure to create a renderer or<br/>
	/// OpenGL context.<br/>
	/// On X11, SDL rolls its own dialog box with X11 primitives instead of a<br/>
	/// formal toolkit like GTK+ or Qt.<br/>
	/// Note that if SDL_Init() would fail because there isn't any available video<br/>
	/// target, this function is likely to fail for the same reasons. If this is a<br/>
	/// concern, check the return value from this function and fall back to writing<br/>
	/// to stderr if you can.<br/>
	/// <br/>
	/// @param flags an SDL_MessageBoxFlags value.<br/>
	/// @param title uTF-8 title text.<br/>
	/// @param message uTF-8 message text.<br/>
	/// @param window the parent window, or NULL for no parent.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ShowMessageBox
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShowSimpleMessageBox")]
	public static partial SDLBool SDL_ShowSimpleMessageBox(SDL_MessageBoxFlags flags, byte* title, byte* message, SDL_Window window);

	[LibraryImport(LibName, EntryPoint = "SDL_ShowSimpleMessageBox")]
	public static partial SDLBool SDL_ShowSimpleMessageBox(SDL_MessageBoxFlags flags, ReadOnlySpan<byte> title, ReadOnlySpan<byte> message, SDL_Window window);

	[LibraryImport(LibName, EntryPoint = "SDL_ShowSimpleMessageBox")]
	public static partial SDLBool SDL_ShowSimpleMessageBox(SDL_MessageBoxFlags flags, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> title, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message, SDL_Window window);

	/// <summary>
	/// Create a CAMetalLayer-backed NSView/UIView and attach it to the specified<br/>
	/// window.<br/>
	/// On macOS, this does *not* associate a MTLDevice with the CAMetalLayer on<br/>
	/// its own. It is up to user code to do that.<br/>
	/// The returned handle can be casted directly to a NSView or UIView. To access<br/>
	/// the backing CAMetalLayer, call SDL_Metal_GetLayer().<br/>
	/// <br/>
	/// @param window the window.<br/>
	/// @returns handle NSView or UIView.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Metal_DestroyView<br/>
	/// @sa SDL_Metal_GetLayer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Metal_CreateView")]
	public static partial nint SDL_Metal_CreateView(SDL_Window window);

	/// <summary>
	/// Destroy an existing SDL_MetalView object.<br/>
	/// This should be called before SDL_DestroyWindow, if SDL_Metal_CreateView was<br/>
	/// called after SDL_CreateWindow.<br/>
	/// <br/>
	/// @param view the SDL_MetalView object.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Metal_CreateView
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Metal_DestroyView")]
	public static partial void SDL_Metal_DestroyView(nint view);

	/// <summary>
	/// Get a pointer to the backing CAMetalLayer for the given view.<br/>
	/// <br/>
	/// @param view the SDL_MetalView object.<br/>
	/// @returns a pointer.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Metal_GetLayer")]
	public static partial nint SDL_Metal_GetLayer(nint view);

	/// <summary>
	/// Open a URL/URI in the browser or other appropriate external application.<br/>
	/// Open a URL in a separate, system-provided application. How this works will<br/>
	/// vary wildly depending on the platform. This will likely launch what makes<br/>
	/// sense to handle a specific URL's protocol (a web browser for `http://`,<br/>
	/// etc), but it might also be able to launch file managers for directories and<br/>
	/// other things.<br/>
	/// What happens when you open a URL varies wildly as well: your game window<br/>
	/// may lose focus (and may or may not lose focus if your game was fullscreen<br/>
	/// or grabbing input at the time). On mobile devices, your app will likely<br/>
	/// move to the background or your process might be paused. Any given platform<br/>
	/// may or may not handle a given URL.<br/>
	/// If this is unimplemented (or simply unavailable) for a platform, this will<br/>
	/// fail with an error. A successful result does not mean the URL loaded, just<br/>
	/// that we launched _something_ to handle it (or at least believe we did).<br/>
	/// All this to say: this function can be useful, but you should definitely<br/>
	/// test it on every platform you target.<br/>
	/// <br/>
	/// @param url a valid URL/URI to open. Use `file:///full/path/to/file` for<br/>
	/// local files, if supported.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenURL")]
	public static partial SDLBool SDL_OpenURL(byte* url);

	[LibraryImport(LibName, EntryPoint = "SDL_OpenURL")]
	public static partial SDLBool SDL_OpenURL(ReadOnlySpan<byte> url);

	[LibraryImport(LibName, EntryPoint = "SDL_OpenURL")]
	public static partial SDLBool SDL_OpenURL([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> url);

	/// <summary>
	/// Return whether a mouse is currently connected.<br/>
	/// <br/>
	/// @returns true if a mouse is connected, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetMice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasMouse")]
	public static partial SDLBool SDL_HasMouse();

	/// <summary>
	/// Get a list of currently connected mice.<br/>
	/// Note that this will include any device or virtual driver that includes<br/>
	/// mouse functionality, including some game controllers, KVM switches, etc.<br/>
	/// You should wait for input from a device before you consider it actively in<br/>
	/// use.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of mice returned, may be<br/>
	/// NULL.<br/>
	/// @returns a 0 terminated array of mouse instance IDs or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This should be freed<br/>
	/// with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetMouseNameForID<br/>
	/// @sa SDL_HasMouse
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetMice")]
	public static partial SDL_MouseID* SDL_GetMice(out int count);

	/// <summary>
	/// Get the name of a mouse.<br/>
	/// This function returns "" if the mouse doesn't have a name.<br/>
	/// <br/>
	/// @param instance_id the mouse instance ID.<br/>
	/// @returns the name of the selected mouse, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetMice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetMouseNameForID")]
	public static partial byte* SDL_GetMouseNameForIDPtr(SDL_MouseID instance_id);

	public static string? SDL_GetMouseNameForID(SDL_MouseID instance_id)
	{
		return ConvertToManaged(SDL_GetMouseNameForIDPtr(instance_id));
	}

	/// <summary>
	/// Get the window which currently has mouse focus.<br/>
	/// <br/>
	/// @returns the window with mouse focus.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetMouseFocus")]
	public static partial SDL_Window SDL_GetMouseFocus();

	/// <summary>
	/// Retrieve the current state of the mouse.<br/>
	/// The current button state is returned as a button bitmask, which can be<br/>
	/// tested using the SDL_BUTTON_MASK(X) macro (where `X` is generally 1 for the<br/>
	/// left, 2 for middle, 3 for the right button), and `x` and `y` are set to the<br/>
	/// mouse cursor position relative to the focus window. You can pass NULL for<br/>
	/// either `x` or `y`.<br/>
	/// <br/>
	/// @param x the x coordinate of the mouse cursor position relative to the<br/>
	/// focus window.<br/>
	/// @param y the y coordinate of the mouse cursor position relative to the<br/>
	/// focus window.<br/>
	/// @returns a 32-bit button bitmask of the current button state.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGlobalMouseState<br/>
	/// @sa SDL_GetRelativeMouseState
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetMouseState")]
	public static partial SDL_MouseButtonFlags SDL_GetMouseState(float* x, float* y);

	/// <summary>
	/// Get the current state of the mouse in relation to the desktop.<br/>
	/// This works similarly to SDL_GetMouseState(), but the coordinates will be<br/>
	/// reported relative to the top-left of the desktop. This can be useful if you<br/>
	/// need to track the mouse outside of a specific window and SDL_CaptureMouse()<br/>
	/// doesn't fit your needs. For example, it could be useful if you need to<br/>
	/// track the mouse while dragging a window, where coordinates relative to a<br/>
	/// window might not be in sync at all times.<br/>
	/// Note: SDL_GetMouseState() returns the mouse position as SDL understands it<br/>
	/// from the last pump of the event queue. This function, however, queries the<br/>
	/// OS for the current mouse position, and as such, might be a slightly less<br/>
	/// efficient function. Unless you know what you're doing and have a good<br/>
	/// reason to use this function, you probably want SDL_GetMouseState() instead.<br/>
	/// <br/>
	/// @param x filled in with the current X coord relative to the desktop; can be<br/>
	/// NULL.<br/>
	/// @param y filled in with the current Y coord relative to the desktop; can be<br/>
	/// NULL.<br/>
	/// @returns the current button state as a bitmask which can be tested using<br/>
	/// the SDL_BUTTON_MASK(X) macros.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CaptureMouse<br/>
	/// @sa SDL_GetMouseState
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGlobalMouseState")]
	public static partial SDL_MouseButtonFlags SDL_GetGlobalMouseState(float* x, float* y);

	/// <summary>
	/// Retrieve the relative state of the mouse.<br/>
	/// The current button state is returned as a button bitmask, which can be<br/>
	/// tested using the `SDL_BUTTON_MASK(X)` macros (where `X` is generally 1 for<br/>
	/// the left, 2 for middle, 3 for the right button), and `x` and `y` are set to<br/>
	/// the mouse deltas since the last call to SDL_GetRelativeMouseState() or<br/>
	/// since event initialization. You can pass NULL for either `x` or `y`.<br/>
	/// <br/>
	/// @param x a pointer filled with the last recorded x coordinate of the mouse.<br/>
	/// @param y a pointer filled with the last recorded y coordinate of the mouse.<br/>
	/// @returns a 32-bit button bitmask of the relative button state.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetMouseState
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRelativeMouseState")]
	public static partial SDL_MouseButtonFlags SDL_GetRelativeMouseState(float* x, float* y);

	/// <summary>
	/// Move the mouse cursor to the given position within the window.<br/>
	/// This function generates a mouse motion event if relative mode is not<br/>
	/// enabled. If relative mode is enabled, you can force mouse events for the<br/>
	/// warp by setting the SDL_HINT_MOUSE_RELATIVE_WARP_MOTION hint.<br/>
	/// Note that this function will appear to succeed, but not actually move the<br/>
	/// mouse when used over Microsoft Remote Desktop.<br/>
	/// <br/>
	/// @param window the window to move the mouse into, or NULL for the current<br/>
	/// mouse focus.<br/>
	/// @param x the x coordinate within the window.<br/>
	/// @param y the y coordinate within the window.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_WarpMouseGlobal
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WarpMouseInWindow")]
	public static partial void SDL_WarpMouseInWindow(SDL_Window window, float x, float y);

	/// <summary>
	/// Move the mouse to the given position in global screen space.<br/>
	/// This function generates a mouse motion event.<br/>
	/// A failure of this function usually means that it is unsupported by a<br/>
	/// platform.<br/>
	/// Note that this function will appear to succeed, but not actually move the<br/>
	/// mouse when used over Microsoft Remote Desktop.<br/>
	/// <br/>
	/// @param x the x coordinate.<br/>
	/// @param y the y coordinate.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_WarpMouseInWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WarpMouseGlobal")]
	public static partial SDLBool SDL_WarpMouseGlobal(float x, float y);

	/// <summary>
	/// Set relative mouse mode for a window.<br/>
	/// While the window has focus and relative mouse mode is enabled, the cursor<br/>
	/// is hidden, the mouse position is constrained to the window, and SDL will<br/>
	/// report continuous relative mouse motion even if the mouse is at the edge of<br/>
	/// the window.<br/>
	/// This function will flush any pending mouse motion for this window.<br/>
	/// <br/>
	/// @param window the window to change.<br/>
	/// @param enabled true to enable relative mode, false to disable.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowRelativeMouseMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowRelativeMouseMode")]
	public static partial SDLBool SDL_SetWindowRelativeMouseMode(SDL_Window window, SDLBool enabled);

	/// <summary>
	/// Query whether relative mouse mode is enabled for a window.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns true if relative mode is enabled for a window or false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowRelativeMouseMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowRelativeMouseMode")]
	public static partial SDLBool SDL_GetWindowRelativeMouseMode(SDL_Window window);

	/// <summary>
	/// Capture the mouse and to track input outside an SDL window.<br/>
	/// Capturing enables your app to obtain mouse events globally, instead of just<br/>
	/// within your window. Not all video targets support this function. When<br/>
	/// capturing is enabled, the current window will get all mouse events, but<br/>
	/// unlike relative mode, no change is made to the cursor and it is not<br/>
	/// restrained to your window.<br/>
	/// This function may also deny mouse input to other windows--both those in<br/>
	/// your application and others on the system--so you should use this function<br/>
	/// sparingly, and in small bursts. For example, you might want to track the<br/>
	/// mouse while the user is dragging something, until the user releases a mouse<br/>
	/// button. It is not recommended that you capture the mouse for long periods<br/>
	/// of time, such as the entire time your app is running. For that, you should<br/>
	/// probably use SDL_SetWindowRelativeMouseMode() or SDL_SetWindowMouseGrab(),<br/>
	/// depending on your goals.<br/>
	/// While captured, mouse events still report coordinates relative to the<br/>
	/// current (foreground) window, but those coordinates may be outside the<br/>
	/// bounds of the window (including negative values). Capturing is only allowed<br/>
	/// for the foreground window. If the window loses focus while capturing, the<br/>
	/// capture will be disabled automatically.<br/>
	/// While capturing is enabled, the current window will have the<br/>
	/// `SDL_WINDOW_MOUSE_CAPTURE` flag set.<br/>
	/// Please note that SDL will attempt to "auto capture" the mouse while the<br/>
	/// user is pressing a button; this is to try and make mouse behavior more<br/>
	/// consistent between platforms, and deal with the common case of a user<br/>
	/// dragging the mouse outside of the window. This means that if you are<br/>
	/// calling SDL_CaptureMouse() only to deal with this situation, you do not<br/>
	/// have to (although it is safe to do so). If this causes problems for your<br/>
	/// app, you can disable auto capture by setting the<br/>
	/// `SDL_HINT_MOUSE_AUTO_CAPTURE` hint to zero.<br/>
	/// <br/>
	/// @param enabled true to enable capturing, false to disable.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGlobalMouseState
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CaptureMouse")]
	public static partial SDLBool SDL_CaptureMouse(SDLBool enabled);

	/// <summary>
	/// Create a cursor using the specified bitmap data and mask (in MSB format).<br/>
	/// `mask` has to be in MSB (Most Significant Bit) format.<br/>
	/// The cursor width (`w`) must be a multiple of 8 bits.<br/>
	/// The cursor is created in black and white according to the following:<br/>
	/// - data=0, mask=1: white<br/>
	/// - data=1, mask=1: black<br/>
	/// - data=0, mask=0: transparent<br/>
	/// - data=1, mask=0: inverted color if possible, black if not.<br/>
	/// Cursors created with this function must be freed with SDL_DestroyCursor().<br/>
	/// If you want to have a color cursor, or create your cursor from an<br/>
	/// SDL_Surface, you should use SDL_CreateColorCursor(). Alternately, you can<br/>
	/// hide the cursor and draw your own as part of your game's rendering, but it<br/>
	/// will be bound to the framerate.<br/>
	/// Also, SDL_CreateSystemCursor() is available, which provides several<br/>
	/// readily-available system cursors to pick from.<br/>
	/// <br/>
	/// @param data the color value for each pixel of the cursor.<br/>
	/// @param mask the mask value for each pixel of the cursor.<br/>
	/// @param w the width of the cursor.<br/>
	/// @param h the height of the cursor.<br/>
	/// @param hot_x the x-axis offset from the left of the cursor image to the<br/>
	/// mouse x position, in the range of 0 to `w` - 1.<br/>
	/// @param hot_y the y-axis offset from the top of the cursor image to the<br/>
	/// mouse y position, in the range of 0 to `h` - 1.<br/>
	/// @returns a new cursor with the specified parameters on success or NULL on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateColorCursor<br/>
	/// @sa SDL_CreateSystemCursor<br/>
	/// @sa SDL_DestroyCursor<br/>
	/// @sa SDL_SetCursor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateCursor")]
	public static partial SDL_Cursor SDL_CreateCursor(byte* data, byte* mask, int w, int h, int hot_x, int hot_y);

	/// <summary>
	/// Create a color cursor.<br/>
	/// If this function is passed a surface with alternate representations, the<br/>
	/// surface will be interpreted as the content to be used for 100% display<br/>
	/// scale, and the alternate representations will be used for high DPI<br/>
	/// situations. For example, if the original surface is 32x32, then on a 2x<br/>
	/// macOS display or 200% display scale on Windows, a 64x64 version of the<br/>
	/// image will be used, if available. If a matching version of the image isn't<br/>
	/// available, the closest larger size image will be downscaled to the<br/>
	/// appropriate size and be used instead, if available. Otherwise, the closest<br/>
	/// smaller image will be upscaled and be used instead.<br/>
	/// <br/>
	/// @param surface an SDL_Surface structure representing the cursor image.<br/>
	/// @param hot_x the x position of the cursor hot spot.<br/>
	/// @param hot_y the y position of the cursor hot spot.<br/>
	/// @returns the new cursor on success or NULL on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateCursor<br/>
	/// @sa SDL_CreateSystemCursor<br/>
	/// @sa SDL_DestroyCursor<br/>
	/// @sa SDL_SetCursor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateColorCursor")]
	public static partial SDL_Cursor SDL_CreateColorCursor(SDL_Surface* surface, int hot_x, int hot_y);

	/// <summary>
	/// Create a system cursor.<br/>
	/// <br/>
	/// @param id an SDL_SystemCursor enum value.<br/>
	/// @returns a cursor on success or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroyCursor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateSystemCursor")]
	public static partial SDL_Cursor SDL_CreateSystemCursor(SDL_SystemCursor id);

	/// <summary>
	/// Set the active cursor.<br/>
	/// This function sets the currently active cursor to the specified one. If the<br/>
	/// cursor is currently visible, the change will be immediately represented on<br/>
	/// the display. SDL_SetCursor(NULL) can be used to force cursor redraw, if<br/>
	/// this is desired for any reason.<br/>
	/// <br/>
	/// @param cursor a cursor to make active.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetCursor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetCursor")]
	public static partial SDLBool SDL_SetCursor(SDL_Cursor cursor);

	/// <summary>
	/// Get the active cursor.<br/>
	/// This function returns a pointer to the current cursor which is owned by the<br/>
	/// library. It is not necessary to free the cursor with SDL_DestroyCursor().<br/>
	/// <br/>
	/// @returns the active cursor or NULL if there is no mouse.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetCursor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCursor")]
	public static partial SDL_Cursor SDL_GetCursor();

	/// <summary>
	/// Get the default cursor.<br/>
	/// You do not have to call SDL_DestroyCursor() on the return value, but it is<br/>
	/// safe to do so.<br/>
	/// <br/>
	/// @returns the default cursor on success or NULL on failuree; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDefaultCursor")]
	public static partial SDL_Cursor SDL_GetDefaultCursor();

	/// <summary>
	/// Free a previously-created cursor.<br/>
	/// Use this function to free cursor resources created with SDL_CreateCursor(),<br/>
	/// SDL_CreateColorCursor() or SDL_CreateSystemCursor().<br/>
	/// <br/>
	/// @param cursor the cursor to free.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateColorCursor<br/>
	/// @sa SDL_CreateCursor<br/>
	/// @sa SDL_CreateSystemCursor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyCursor")]
	public static partial void SDL_DestroyCursor(SDL_Cursor cursor);

	/// <summary>
	/// Show the cursor.<br/>
	/// <br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CursorVisible<br/>
	/// @sa SDL_HideCursor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShowCursor")]
	public static partial SDLBool SDL_ShowCursor();

	/// <summary>
	/// Hide the cursor.<br/>
	/// <br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CursorVisible<br/>
	/// @sa SDL_ShowCursor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HideCursor")]
	public static partial SDLBool SDL_HideCursor();

	/// <summary>
	/// Return whether the cursor is currently being shown.<br/>
	/// <br/>
	/// @returns `true` if the cursor is being shown, or `false` if the cursor is<br/>
	/// hidden.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HideCursor<br/>
	/// @sa SDL_ShowCursor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CursorVisible")]
	public static partial SDLBool SDL_CursorVisible();

	/// <summary>
	/// Create a new mutex.<br/>
	/// All newly-created mutexes begin in the _unlocked_ state.<br/>
	/// Calls to SDL_LockMutex() will not return while the mutex is locked by<br/>
	/// another thread. See SDL_TryLockMutex() to attempt to lock without blocking.<br/>
	/// SDL mutexes are reentrant.<br/>
	/// <br/>
	/// @returns the initialized and unlocked mutex or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroyMutex<br/>
	/// @sa SDL_LockMutex<br/>
	/// @sa SDL_TryLockMutex<br/>
	/// @sa SDL_UnlockMutex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateMutex")]
	public static partial SDL_Mutex SDL_CreateMutex();

	/// <summary>
	/// Lock the mutex.<br/>
	/// This will block until the mutex is available, which is to say it is in the<br/>
	/// unlocked state and the OS has chosen the caller as the next thread to lock<br/>
	/// it. Of all threads waiting to lock the mutex, only one may do so at a time.<br/>
	/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
	/// unlock it the same number of times before it is actually made available for<br/>
	/// other threads in the system (this is known as a "recursive mutex").<br/>
	/// This function does not fail; if mutex is NULL, it will return immediately<br/>
	/// having locked nothing. If the mutex is valid, this function will always<br/>
	/// block until it can lock the mutex, and return with it locked.<br/>
	/// <br/>
	/// @param mutex the mutex to lock.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_TryLockMutex<br/>
	/// @sa SDL_UnlockMutex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LockMutex")]
	public static partial void SDL_LockMutex(SDL_Mutex mutex);

	/// <summary>
	/// Try to lock a mutex without blocking.<br/>
	/// This works just like SDL_LockMutex(), but if the mutex is not available,<br/>
	/// this function returns false immediately.<br/>
	/// This technique is useful if you need exclusive access to a resource but<br/>
	/// don't want to wait for it, and will return to it to try again later.<br/>
	/// This function returns true if passed a NULL mutex.<br/>
	/// <br/>
	/// @param mutex the mutex to try to lock.<br/>
	/// @returns true on success, false if the mutex would block.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockMutex<br/>
	/// @sa SDL_UnlockMutex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_TryLockMutex")]
	public static partial SDLBool SDL_TryLockMutex(SDL_Mutex mutex);

	/// <summary>
	/// Unlock the mutex.<br/>
	/// It is legal for the owning thread to lock an already-locked mutex. It must<br/>
	/// unlock it the same number of times before it is actually made available for<br/>
	/// other threads in the system (this is known as a "recursive mutex").<br/>
	/// It is illegal to unlock a mutex that has not been locked by the current<br/>
	/// thread, and doing so results in undefined behavior.<br/>
	/// <br/>
	/// @param mutex the mutex to unlock.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockMutex<br/>
	/// @sa SDL_TryLockMutex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnlockMutex")]
	public static partial void SDL_UnlockMutex(SDL_Mutex mutex);

	/// <summary>
	/// Destroy a mutex created with SDL_CreateMutex().<br/>
	/// This function must be called on any mutex that is no longer needed. Failure<br/>
	/// to destroy a mutex will result in a system memory or resource leak. While<br/>
	/// it is safe to destroy a mutex that is _unlocked_, it is not safe to attempt<br/>
	/// to destroy a locked mutex, and may result in undefined behavior depending<br/>
	/// on the platform.<br/>
	/// <br/>
	/// @param mutex the mutex to destroy.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateMutex
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyMutex")]
	public static partial void SDL_DestroyMutex(SDL_Mutex mutex);

	/// <summary>
	/// Create a new read/write lock.<br/>
	/// A read/write lock is useful for situations where you have multiple threads<br/>
	/// trying to access a resource that is rarely updated. All threads requesting<br/>
	/// a read-only lock will be allowed to run in parallel; if a thread requests a<br/>
	/// write lock, it will be provided exclusive access. This makes it safe for<br/>
	/// multiple threads to use a resource at the same time if they promise not to<br/>
	/// change it, and when it has to be changed, the rwlock will serve as a<br/>
	/// gateway to make sure those changes can be made safely.<br/>
	/// In the right situation, a rwlock can be more efficient than a mutex, which<br/>
	/// only lets a single thread proceed at a time, even if it won't be modifying<br/>
	/// the data.<br/>
	/// All newly-created read/write locks begin in the _unlocked_ state.<br/>
	/// Calls to SDL_LockRWLockForReading() and SDL_LockRWLockForWriting will not<br/>
	/// return while the rwlock is locked _for writing_ by another thread. See<br/>
	/// SDL_TryLockRWLockForReading() and SDL_TryLockRWLockForWriting() to attempt<br/>
	/// to lock without blocking.<br/>
	/// SDL read/write locks are only recursive for read-only locks! They are not<br/>
	/// guaranteed to be fair, or provide access in a FIFO manner! They are not<br/>
	/// guaranteed to favor writers. You may not lock a rwlock for both read-only<br/>
	/// and write access at the same time from the same thread (so you can't<br/>
	/// promote your read-only lock to a write lock without unlocking first).<br/>
	/// <br/>
	/// @returns the initialized and unlocked read/write lock or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroyRWLock<br/>
	/// @sa SDL_LockRWLockForReading<br/>
	/// @sa SDL_LockRWLockForWriting<br/>
	/// @sa SDL_TryLockRWLockForReading<br/>
	/// @sa SDL_TryLockRWLockForWriting<br/>
	/// @sa SDL_UnlockRWLock
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateRWLock")]
	public static partial SDL_RWLock SDL_CreateRWLock();

	/// <summary>
	/// Lock the read/write lock for _read only_ operations.<br/>
	/// This will block until the rwlock is available, which is to say it is not<br/>
	/// locked for writing by any other thread. Of all threads waiting to lock the<br/>
	/// rwlock, all may do so at the same time as long as they are requesting<br/>
	/// read-only access; if a thread wants to lock for writing, only one may do so<br/>
	/// at a time, and no other threads, read-only or not, may hold the lock at the<br/>
	/// same time.<br/>
	/// It is legal for the owning thread to lock an already-locked rwlock for<br/>
	/// reading. It must unlock it the same number of times before it is actually<br/>
	/// made available for other threads in the system (this is known as a<br/>
	/// "recursive rwlock").<br/>
	/// Note that locking for writing is not recursive (this is only available to<br/>
	/// read-only locks).<br/>
	/// It is illegal to request a read-only lock from a thread that already holds<br/>
	/// the write lock. Doing so results in undefined behavior. Unlock the write<br/>
	/// lock before requesting a read-only lock. (But, of course, if you have the<br/>
	/// write lock, you don't need further locks to read in any case.)<br/>
	/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
	/// having locked nothing. If the rwlock is valid, this function will always<br/>
	/// block until it can lock the mutex, and return with it locked.<br/>
	/// <br/>
	/// @param rwlock the read/write lock to lock.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockRWLockForWriting<br/>
	/// @sa SDL_TryLockRWLockForReading<br/>
	/// @sa SDL_UnlockRWLock
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LockRWLockForReading")]
	public static partial void SDL_LockRWLockForReading(SDL_RWLock rwlock);

	/// <summary>
	/// Lock the read/write lock for _write_ operations.<br/>
	/// This will block until the rwlock is available, which is to say it is not<br/>
	/// locked for reading or writing by any other thread. Only one thread may hold<br/>
	/// the lock when it requests write access; all other threads, whether they<br/>
	/// also want to write or only want read-only access, must wait until the<br/>
	/// writer thread has released the lock.<br/>
	/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
	/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
	/// results in undefined behavior.<br/>
	/// It is illegal to request a write lock from a thread that already holds a<br/>
	/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
	/// read-only lock before requesting a write lock.<br/>
	/// This function does not fail; if rwlock is NULL, it will return immediately<br/>
	/// having locked nothing. If the rwlock is valid, this function will always<br/>
	/// block until it can lock the mutex, and return with it locked.<br/>
	/// <br/>
	/// @param rwlock the read/write lock to lock.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockRWLockForReading<br/>
	/// @sa SDL_TryLockRWLockForWriting<br/>
	/// @sa SDL_UnlockRWLock
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LockRWLockForWriting")]
	public static partial void SDL_LockRWLockForWriting(SDL_RWLock rwlock);

	/// <summary>
	/// Try to lock a read/write lock _for reading_ without blocking.<br/>
	/// This works just like SDL_LockRWLockForReading(), but if the rwlock is not<br/>
	/// available, then this function returns false immediately.<br/>
	/// This technique is useful if you need access to a resource but don't want to<br/>
	/// wait for it, and will return to it to try again later.<br/>
	/// Trying to lock for read-only access can succeed if other threads are<br/>
	/// holding read-only locks, as this won't prevent access.<br/>
	/// This function returns true if passed a NULL rwlock.<br/>
	/// <br/>
	/// @param rwlock the rwlock to try to lock.<br/>
	/// @returns true on success, false if the lock would block.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockRWLockForReading<br/>
	/// @sa SDL_TryLockRWLockForWriting<br/>
	/// @sa SDL_UnlockRWLock
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_TryLockRWLockForReading")]
	public static partial SDLBool SDL_TryLockRWLockForReading(SDL_RWLock rwlock);

	/// <summary>
	/// Try to lock a read/write lock _for writing_ without blocking.<br/>
	/// This works just like SDL_LockRWLockForWriting(), but if the rwlock is not<br/>
	/// available, then this function returns false immediately.<br/>
	/// This technique is useful if you need exclusive access to a resource but<br/>
	/// don't want to wait for it, and will return to it to try again later.<br/>
	/// It is illegal for the owning thread to lock an already-locked rwlock for<br/>
	/// writing (read-only may be locked recursively, writing can not). Doing so<br/>
	/// results in undefined behavior.<br/>
	/// It is illegal to request a write lock from a thread that already holds a<br/>
	/// read-only lock. Doing so results in undefined behavior. Unlock the<br/>
	/// read-only lock before requesting a write lock.<br/>
	/// This function returns true if passed a NULL rwlock.<br/>
	/// <br/>
	/// @param rwlock the rwlock to try to lock.<br/>
	/// @returns true on success, false if the lock would block.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockRWLockForWriting<br/>
	/// @sa SDL_TryLockRWLockForReading<br/>
	/// @sa SDL_UnlockRWLock
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_TryLockRWLockForWriting")]
	public static partial SDLBool SDL_TryLockRWLockForWriting(SDL_RWLock rwlock);

	/// <summary>
	/// Unlock the read/write lock.<br/>
	/// Use this function to unlock the rwlock, whether it was locked for read-only<br/>
	/// or write operations.<br/>
	/// It is legal for the owning thread to lock an already-locked read-only lock.<br/>
	/// It must unlock it the same number of times before it is actually made<br/>
	/// available for other threads in the system (this is known as a "recursive<br/>
	/// rwlock").<br/>
	/// It is illegal to unlock a rwlock that has not been locked by the current<br/>
	/// thread, and doing so results in undefined behavior.<br/>
	/// <br/>
	/// @param rwlock the rwlock to unlock.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockRWLockForReading<br/>
	/// @sa SDL_LockRWLockForWriting<br/>
	/// @sa SDL_TryLockRWLockForReading<br/>
	/// @sa SDL_TryLockRWLockForWriting
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnlockRWLock")]
	public static partial void SDL_UnlockRWLock(SDL_RWLock rwlock);

	/// <summary>
	/// Destroy a read/write lock created with SDL_CreateRWLock().<br/>
	/// This function must be called on any read/write lock that is no longer<br/>
	/// needed. Failure to destroy a rwlock will result in a system memory or<br/>
	/// resource leak. While it is safe to destroy a rwlock that is _unlocked_, it<br/>
	/// is not safe to attempt to destroy a locked rwlock, and may result in<br/>
	/// undefined behavior depending on the platform.<br/>
	/// <br/>
	/// @param rwlock the rwlock to destroy.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateRWLock
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyRWLock")]
	public static partial void SDL_DestroyRWLock(SDL_RWLock rwlock);

	/// <summary>
	/// Create a semaphore.<br/>
	/// This function creates a new semaphore and initializes it with the value<br/>
	/// `initial_value`. Each wait operation on the semaphore will atomically<br/>
	/// decrement the semaphore value and potentially block if the semaphore value<br/>
	/// is 0. Each post operation will atomically increment the semaphore value and<br/>
	/// wake waiting threads and allow them to retry the wait operation.<br/>
	/// <br/>
	/// @param initial_value the starting value of the semaphore.<br/>
	/// @returns a new semaphore or NULL on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroySemaphore<br/>
	/// @sa SDL_SignalSemaphore<br/>
	/// @sa SDL_TryWaitSemaphore<br/>
	/// @sa SDL_GetSemaphoreValue<br/>
	/// @sa SDL_WaitSemaphore<br/>
	/// @sa SDL_WaitSemaphoreTimeout
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateSemaphore")]
	public static partial SDL_Semaphore SDL_CreateSemaphore(uint initial_value);

	/// <summary>
	/// Destroy a semaphore.<br/>
	/// It is not safe to destroy a semaphore if there are threads currently<br/>
	/// waiting on it.<br/>
	/// <br/>
	/// @param sem the semaphore to destroy.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateSemaphore
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroySemaphore")]
	public static partial void SDL_DestroySemaphore(SDL_Semaphore sem);

	/// <summary>
	/// Wait until a semaphore has a positive value and then decrements it.<br/>
	/// This function suspends the calling thread until the semaphore pointed to by<br/>
	/// `sem` has a positive value, and then atomically decrement the semaphore<br/>
	/// value.<br/>
	/// This function is the equivalent of calling SDL_WaitSemaphoreTimeout() with<br/>
	/// a time length of -1.<br/>
	/// <br/>
	/// @param sem the semaphore wait on.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SignalSemaphore<br/>
	/// @sa SDL_TryWaitSemaphore<br/>
	/// @sa SDL_WaitSemaphoreTimeout
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WaitSemaphore")]
	public static partial void SDL_WaitSemaphore(SDL_Semaphore sem);

	/// <summary>
	/// See if a semaphore has a positive value and decrement it if it does.<br/>
	/// This function checks to see if the semaphore pointed to by `sem` has a<br/>
	/// positive value and atomically decrements the semaphore value if it does. If<br/>
	/// the semaphore doesn't have a positive value, the function immediately<br/>
	/// returns false.<br/>
	/// <br/>
	/// @param sem the semaphore to wait on.<br/>
	/// @returns true if the wait succeeds, false if the wait would block.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SignalSemaphore<br/>
	/// @sa SDL_WaitSemaphore<br/>
	/// @sa SDL_WaitSemaphoreTimeout
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_TryWaitSemaphore")]
	public static partial SDLBool SDL_TryWaitSemaphore(SDL_Semaphore sem);

	/// <summary>
	/// Wait until a semaphore has a positive value and then decrements it.<br/>
	/// This function suspends the calling thread until either the semaphore<br/>
	/// pointed to by `sem` has a positive value or the specified time has elapsed.<br/>
	/// If the call is successful it will atomically decrement the semaphore value.<br/>
	/// <br/>
	/// @param sem the semaphore to wait on.<br/>
	/// @param timeoutMS the length of the timeout, in milliseconds, or -1 to wait<br/>
	/// indefinitely.<br/>
	/// @returns true if the wait succeeds or false if the wait times out.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SignalSemaphore<br/>
	/// @sa SDL_TryWaitSemaphore<br/>
	/// @sa SDL_WaitSemaphore
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WaitSemaphoreTimeout")]
	public static partial SDLBool SDL_WaitSemaphoreTimeout(SDL_Semaphore sem, int timeoutMS);

	/// <summary>
	/// Atomically increment a semaphore's value and wake waiting threads.<br/>
	/// <br/>
	/// @param sem the semaphore to increment.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_TryWaitSemaphore<br/>
	/// @sa SDL_WaitSemaphore<br/>
	/// @sa SDL_WaitSemaphoreTimeout
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SignalSemaphore")]
	public static partial void SDL_SignalSemaphore(SDL_Semaphore sem);

	/// <summary>
	/// Get the current value of a semaphore.<br/>
	/// <br/>
	/// @param sem the semaphore to query.<br/>
	/// @returns the current value of the semaphore.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSemaphoreValue")]
	public static partial uint SDL_GetSemaphoreValue(SDL_Semaphore sem);

	/// <summary>
	/// Create a condition variable.<br/>
	/// <br/>
	/// @returns a new condition variable or NULL on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BroadcastCondition<br/>
	/// @sa SDL_SignalCondition<br/>
	/// @sa SDL_WaitCondition<br/>
	/// @sa SDL_WaitConditionTimeout<br/>
	/// @sa SDL_DestroyCondition
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateCondition")]
	public static partial SDL_Condition SDL_CreateCondition();

	/// <summary>
	/// Destroy a condition variable.<br/>
	/// <br/>
	/// @param cond the condition variable to destroy.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateCondition
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyCondition")]
	public static partial void SDL_DestroyCondition(SDL_Condition cond);

	/// <summary>
	/// Restart one of the threads that are waiting on the condition variable.<br/>
	/// <br/>
	/// @param cond the condition variable to signal.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BroadcastCondition<br/>
	/// @sa SDL_WaitCondition<br/>
	/// @sa SDL_WaitConditionTimeout
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SignalCondition")]
	public static partial void SDL_SignalCondition(SDL_Condition cond);

	/// <summary>
	/// Restart all threads that are waiting on the condition variable.<br/>
	/// <br/>
	/// @param cond the condition variable to signal.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SignalCondition<br/>
	/// @sa SDL_WaitCondition<br/>
	/// @sa SDL_WaitConditionTimeout
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BroadcastCondition")]
	public static partial void SDL_BroadcastCondition(SDL_Condition cond);

	/// <summary>
	/// Wait until a condition variable is signaled.<br/>
	/// This function unlocks the specified `mutex` and waits for another thread to<br/>
	/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
	/// variable `cond`. Once the condition variable is signaled, the mutex is<br/>
	/// re-locked and the function returns.<br/>
	/// The mutex must be locked before calling this function. Locking the mutex<br/>
	/// recursively (more than once) is not supported and leads to undefined<br/>
	/// behavior.<br/>
	/// This function is the equivalent of calling SDL_WaitConditionTimeout() with<br/>
	/// a time length of -1.<br/>
	/// <br/>
	/// @param cond the condition variable to wait on.<br/>
	/// @param mutex the mutex used to coordinate thread access.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BroadcastCondition<br/>
	/// @sa SDL_SignalCondition<br/>
	/// @sa SDL_WaitConditionTimeout
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WaitCondition")]
	public static partial void SDL_WaitCondition(SDL_Condition cond, SDL_Mutex mutex);

	/// <summary>
	/// Wait until a condition variable is signaled or a certain time has passed.<br/>
	/// This function unlocks the specified `mutex` and waits for another thread to<br/>
	/// call SDL_SignalCondition() or SDL_BroadcastCondition() on the condition<br/>
	/// variable `cond`, or for the specified time to elapse. Once the condition<br/>
	/// variable is signaled or the time elapsed, the mutex is re-locked and the<br/>
	/// function returns.<br/>
	/// The mutex must be locked before calling this function. Locking the mutex<br/>
	/// recursively (more than once) is not supported and leads to undefined<br/>
	/// behavior.<br/>
	/// <br/>
	/// @param cond the condition variable to wait on.<br/>
	/// @param mutex the mutex used to coordinate thread access.<br/>
	/// @param timeoutMS the maximum time to wait, in milliseconds, or -1 to wait<br/>
	/// indefinitely.<br/>
	/// @returns true if the condition variable is signaled, false if the condition<br/>
	/// is not signaled in the allotted time.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BroadcastCondition<br/>
	/// @sa SDL_SignalCondition<br/>
	/// @sa SDL_WaitCondition
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WaitConditionTimeout")]
	public static partial SDLBool SDL_WaitConditionTimeout(SDL_Condition cond, SDL_Mutex mutex, int timeoutMS);

	/// <summary>
	/// Return whether initialization should be done.<br/>
	/// This function checks the passed in state and if initialization should be<br/>
	/// done, sets the status to `SDL_INIT_STATUS_INITIALIZING` and returns true.<br/>
	/// If another thread is already modifying this state, it will wait until<br/>
	/// that's done before returning.<br/>
	/// If this function returns true, the calling code must call<br/>
	/// SDL_SetInitialized() to complete the initialization.<br/>
	/// <br/>
	/// @param state the initialization state to check.<br/>
	/// @returns true if initialization needs to be done, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetInitialized<br/>
	/// @sa SDL_ShouldQuit
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShouldInit")]
	public static partial SDLBool SDL_ShouldInit(SDL_InitState* state);

	/// <summary>
	/// Return whether cleanup should be done.<br/>
	/// This function checks the passed in state and if cleanup should be done,<br/>
	/// sets the status to `SDL_INIT_STATUS_UNINITIALIZING` and returns true.<br/>
	/// If this function returns true, the calling code must call<br/>
	/// SDL_SetInitialized() to complete the cleanup.<br/>
	/// <br/>
	/// @param state the initialization state to check.<br/>
	/// @returns true if cleanup needs to be done, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetInitialized<br/>
	/// @sa SDL_ShouldInit
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShouldQuit")]
	public static partial SDLBool SDL_ShouldQuit(SDL_InitState* state);

	/// <summary>
	/// Finish an initialization state transition.<br/>
	/// This function sets the status of the passed in state to<br/>
	/// `SDL_INIT_STATUS_INITIALIZED` or `SDL_INIT_STATUS_UNINITIALIZED` and allows<br/>
	/// any threads waiting for the status to proceed.<br/>
	/// <br/>
	/// @param state the initialization state to check.<br/>
	/// @param initialized the new initialization state.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ShouldInit<br/>
	/// @sa SDL_ShouldQuit
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetInitialized")]
	public static partial void SDL_SetInitialized(SDL_InitState* state, SDLBool initialized);

	/// <summary>
	/// Get the human readable name of a pixel format.<br/>
	/// <br/>
	/// @param format the pixel format to query.<br/>
	/// @returns the human readable name of the specified pixel format or<br/>
	/// "SDL_PIXELFORMAT_UNKNOWN" if the format isn't recognized.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPixelFormatName")]
	public static partial byte* SDL_GetPixelFormatNamePtr(SDL_PixelFormat format);

	public static string? SDL_GetPixelFormatName(SDL_PixelFormat format)
	{
		return ConvertToManaged(SDL_GetPixelFormatNamePtr(format));
	}

	/// <summary>
	/// Convert one of the enumerated pixel formats to a bpp value and RGBA masks.<br/>
	/// <br/>
	/// @param format one of the SDL_PixelFormat values.<br/>
	/// @param bpp a bits per pixel value; usually 15, 16, or 32.<br/>
	/// @param Rmask a pointer filled in with the red mask for the format.<br/>
	/// @param Gmask a pointer filled in with the green mask for the format.<br/>
	/// @param Bmask a pointer filled in with the blue mask for the format.<br/>
	/// @param Amask a pointer filled in with the alpha mask for the format.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPixelFormatForMasks
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetMasksForPixelFormat")]
	public static partial SDLBool SDL_GetMasksForPixelFormat(SDL_PixelFormat format, int* bpp, uint* Rmask, uint* Gmask, uint* Bmask, uint* Amask);

	/// <summary>
	/// Convert a bpp value and RGBA masks to an enumerated pixel format.<br/>
	/// This will return `SDL_PIXELFORMAT_UNKNOWN` if the conversion wasn't<br/>
	/// possible.<br/>
	/// <br/>
	/// @param bpp a bits per pixel value; usually 15, 16, or 32.<br/>
	/// @param Rmask the red mask for the format.<br/>
	/// @param Gmask the green mask for the format.<br/>
	/// @param Bmask the blue mask for the format.<br/>
	/// @param Amask the alpha mask for the format.<br/>
	/// @returns the SDL_PixelFormat value corresponding to the format masks, or<br/>
	/// SDL_PIXELFORMAT_UNKNOWN if there isn't a match.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetMasksForPixelFormat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPixelFormatForMasks")]
	public static partial SDL_PixelFormat SDL_GetPixelFormatForMasks(int bpp, uint Rmask, uint Gmask, uint Bmask, uint Amask);

	/// <summary>
	/// Create an SDL_PixelFormatDetails structure corresponding to a pixel format.<br/>
	/// Returned structure may come from a shared global cache (i.e. not newly<br/>
	/// allocated), and hence should not be modified, especially the palette. Weird<br/>
	/// errors such as `Blit combination not supported` may occur.<br/>
	/// <br/>
	/// @param format one of the SDL_PixelFormat values.<br/>
	/// @returns a pointer to a SDL_PixelFormatDetails structure or NULL on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPixelFormatDetails")]
	public static partial SDL_PixelFormatDetails* SDL_GetPixelFormatDetails(SDL_PixelFormat format);

	/// <summary>
	/// Create a palette structure with the specified number of color entries.<br/>
	/// The palette entries are initialized to white.<br/>
	/// <br/>
	/// @param ncolors represents the number of color entries in the color palette.<br/>
	/// @returns a new SDL_Palette structure on success or NULL on failure (e.g. if<br/>
	/// there wasn't enough memory); call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroyPalette<br/>
	/// @sa SDL_SetPaletteColors<br/>
	/// @sa SDL_SetSurfacePalette
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreatePalette")]
	public static partial SDL_Palette* SDL_CreatePalette(int ncolors);

	/// <summary>
	/// Set a range of colors in a palette.<br/>
	/// <br/>
	/// @param palette the SDL_Palette structure to modify.<br/>
	/// @param colors an array of SDL_Color structures to copy into the palette.<br/>
	/// @param firstcolor the index of the first palette entry to modify.<br/>
	/// @param ncolors the number of entries to modify.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread, as long as<br/>
	/// the palette is not modified or destroyed in another thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetPaletteColors")]
	public static partial SDLBool SDL_SetPaletteColors(SDL_Palette* palette, SDL_Color* colors, int firstcolor, int ncolors);

	/// <summary>
	/// Free a palette created with SDL_CreatePalette().<br/>
	/// <br/>
	/// @param palette the SDL_Palette structure to be freed.<br/>
	/// @threadsafety It is safe to call this function from any thread, as long as<br/>
	/// the palette is not modified or destroyed in another thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreatePalette
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyPalette")]
	public static partial void SDL_DestroyPalette(SDL_Palette* palette);

	/// <summary>
	/// Map an RGB triple to an opaque pixel value for a given pixel format.<br/>
	/// This function maps the RGB color value to the specified pixel format and<br/>
	/// returns the pixel value best approximating the given RGB color value for<br/>
	/// the given pixel format.<br/>
	/// If the format has a palette (8-bit) the index of the closest matching color<br/>
	/// in the palette will be returned.<br/>
	/// If the specified pixel format has an alpha component it will be returned as<br/>
	/// all 1 bits (fully opaque).<br/>
	/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
	/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
	/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
	/// for an 8-bpp format).<br/>
	/// <br/>
	/// @param format a pointer to SDL_PixelFormatDetails describing the pixel<br/>
	/// format.<br/>
	/// @param palette an optional palette for indexed formats, may be NULL.<br/>
	/// @param r the red component of the pixel in the range 0-255.<br/>
	/// @param g the green component of the pixel in the range 0-255.<br/>
	/// @param b the blue component of the pixel in the range 0-255.<br/>
	/// @returns a pixel value.<br/>
	/// @threadsafety It is safe to call this function from any thread, as long as<br/>
	/// the palette is not modified.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPixelFormatDetails<br/>
	/// @sa SDL_GetRGB<br/>
	/// @sa SDL_MapRGBA<br/>
	/// @sa SDL_MapSurfaceRGB
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_MapRGB")]
	public static partial uint SDL_MapRGB(SDL_PixelFormatDetails* format, SDL_Palette* palette, byte r, byte g, byte b);

	/// <summary>
	/// Map an RGBA quadruple to a pixel value for a given pixel format.<br/>
	/// This function maps the RGBA color value to the specified pixel format and<br/>
	/// returns the pixel value best approximating the given RGBA color value for<br/>
	/// the given pixel format.<br/>
	/// If the specified pixel format has no alpha component the alpha value will<br/>
	/// be ignored (as it will be in formats with a palette).<br/>
	/// If the format has a palette (8-bit) the index of the closest matching color<br/>
	/// in the palette will be returned.<br/>
	/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
	/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
	/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
	/// for an 8-bpp format).<br/>
	/// <br/>
	/// @param format a pointer to SDL_PixelFormatDetails describing the pixel<br/>
	/// format.<br/>
	/// @param palette an optional palette for indexed formats, may be NULL.<br/>
	/// @param r the red component of the pixel in the range 0-255.<br/>
	/// @param g the green component of the pixel in the range 0-255.<br/>
	/// @param b the blue component of the pixel in the range 0-255.<br/>
	/// @param a the alpha component of the pixel in the range 0-255.<br/>
	/// @returns a pixel value.<br/>
	/// @threadsafety It is safe to call this function from any thread, as long as<br/>
	/// the palette is not modified.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPixelFormatDetails<br/>
	/// @sa SDL_GetRGBA<br/>
	/// @sa SDL_MapRGB<br/>
	/// @sa SDL_MapSurfaceRGBA
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_MapRGBA")]
	public static partial uint SDL_MapRGBA(SDL_PixelFormatDetails* format, SDL_Palette* palette, byte r, byte g, byte b, byte a);

	/// <summary>
	/// Get RGB values from a pixel in the specified format.<br/>
	/// This function uses the entire 8-bit [0..255] range when converting color<br/>
	/// components from pixel formats with less than 8-bits per RGB component<br/>
	/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
	/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
	/// <br/>
	/// @param pixel a pixel value.<br/>
	/// @param format a pointer to SDL_PixelFormatDetails describing the pixel<br/>
	/// format.<br/>
	/// @param palette an optional palette for indexed formats, may be NULL.<br/>
	/// @param r a pointer filled in with the red component, may be NULL.<br/>
	/// @param g a pointer filled in with the green component, may be NULL.<br/>
	/// @param b a pointer filled in with the blue component, may be NULL.<br/>
	/// @threadsafety It is safe to call this function from any thread, as long as<br/>
	/// the palette is not modified.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPixelFormatDetails<br/>
	/// @sa SDL_GetRGBA<br/>
	/// @sa SDL_MapRGB<br/>
	/// @sa SDL_MapRGBA
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRGB")]
	public static partial void SDL_GetRGB(uint pixel, SDL_PixelFormatDetails* format, SDL_Palette* palette, byte* r, byte* g, byte* b);

	/// <summary>
	/// Get RGBA values from a pixel in the specified format.<br/>
	/// This function uses the entire 8-bit [0..255] range when converting color<br/>
	/// components from pixel formats with less than 8-bits per RGB component<br/>
	/// (e.g., a completely white pixel in 16-bit RGB565 format would return [0xff,<br/>
	/// 0xff, 0xff] not [0xf8, 0xfc, 0xf8]).<br/>
	/// If the surface has no alpha component, the alpha will be returned as 0xff<br/>
	/// (100% opaque).<br/>
	/// <br/>
	/// @param pixel a pixel value.<br/>
	/// @param format a pointer to SDL_PixelFormatDetails describing the pixel<br/>
	/// format.<br/>
	/// @param palette an optional palette for indexed formats, may be NULL.<br/>
	/// @param r a pointer filled in with the red component, may be NULL.<br/>
	/// @param g a pointer filled in with the green component, may be NULL.<br/>
	/// @param b a pointer filled in with the blue component, may be NULL.<br/>
	/// @param a a pointer filled in with the alpha component, may be NULL.<br/>
	/// @threadsafety It is safe to call this function from any thread, as long as<br/>
	/// the palette is not modified.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPixelFormatDetails<br/>
	/// @sa SDL_GetRGB<br/>
	/// @sa SDL_MapRGB<br/>
	/// @sa SDL_MapRGBA
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRGBA")]
	public static partial void SDL_GetRGBA(uint pixel, SDL_PixelFormatDetails* format, SDL_Palette* palette, byte* r, byte* g, byte* b, byte* a);

	/// <summary>
	/// Get the name of the platform.<br/>
	/// Here are the names returned for some (but not all) supported platforms:<br/>
	/// - "Windows"<br/>
	/// - "macOS"<br/>
	/// - "Linux"<br/>
	/// - "iOS"<br/>
	/// - "Android"<br/>
	/// <br/>
	/// @returns the name of the platform. If the correct platform name is not<br/>
	/// available, returns a string beginning with the text "Unknown".<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPlatform")]
	public static partial byte* SDL_GetPlatformPtr();

	public static string? SDL_GetPlatform()
	{
		return ConvertToManaged(SDL_GetPlatformPtr());
	}

	/// <summary>
	/// Get the current power supply details.<br/>
	/// You should never take a battery status as absolute truth. Batteries<br/>
	/// (especially failing batteries) are delicate hardware, and the values<br/>
	/// reported here are best estimates based on what that hardware reports. It's<br/>
	/// not uncommon for older batteries to lose stored power much faster than it<br/>
	/// reports, or completely drain when reporting it has 20 percent left, etc.<br/>
	/// Battery status can change at any time; if you are concerned with power<br/>
	/// state, you should call this function frequently, and perhaps ignore changes<br/>
	/// until they seem to be stable for a few seconds.<br/>
	/// It's possible a platform can only report battery percentage or time left<br/>
	/// but not both.<br/>
	/// <br/>
	/// @param seconds a pointer filled in with the seconds of battery life left,<br/>
	/// or NULL to ignore. This will be filled in with -1 if we<br/>
	/// can't determine a value or there is no battery.<br/>
	/// @param percent a pointer filled in with the percentage of battery life<br/>
	/// left, between 0 and 100, or NULL to ignore. This will be<br/>
	/// filled in with -1 we can't determine a value or there is no<br/>
	/// battery.<br/>
	/// @returns the current battery state or `SDL_POWERSTATE_ERROR` on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPowerInfo")]
	public static partial SDL_PowerState SDL_GetPowerInfo(int* seconds, int* percent);

	/// <summary>
	/// Get the global SDL properties.<br/>
	/// <br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGlobalProperties")]
	public static partial SDL_PropertiesID SDL_GetGlobalProperties();

	/// <summary>
	/// Create a group of properties.<br/>
	/// All properties are automatically destroyed when SDL_Quit() is called.<br/>
	/// <br/>
	/// @returns an ID for a new group of properties, or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroyProperties
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateProperties")]
	public static partial SDL_PropertiesID SDL_CreateProperties();

	/// <summary>
	/// Copy a group of properties.<br/>
	/// Copy all the properties from one group of properties to another, with the<br/>
	/// exception of properties requiring cleanup (set using<br/>
	/// SDL_SetPointerPropertyWithCleanup()), which will not be copied. Any<br/>
	/// property that already exists on `dst` will be overwritten.<br/>
	/// <br/>
	/// @param src the properties to copy.<br/>
	/// @param dst the destination properties.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CopyProperties")]
	public static partial SDLBool SDL_CopyProperties(SDL_PropertiesID src, SDL_PropertiesID dst);

	/// <summary>
	/// Lock a group of properties.<br/>
	/// Obtain a multi-threaded lock for these properties. Other threads will wait<br/>
	/// while trying to lock these properties until they are unlocked. Properties<br/>
	/// must be unlocked before they are destroyed.<br/>
	/// The lock is automatically taken when setting individual properties, this<br/>
	/// function is only needed when you want to set several properties atomically<br/>
	/// or want to guarantee that properties being queried aren't freed in another<br/>
	/// thread.<br/>
	/// <br/>
	/// @param props the properties to lock.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_UnlockProperties
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LockProperties")]
	public static partial SDLBool SDL_LockProperties(SDL_PropertiesID props);

	/// <summary>
	/// Unlock a group of properties.<br/>
	/// <br/>
	/// @param props the properties to unlock.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockProperties
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnlockProperties")]
	public static partial void SDL_UnlockProperties(SDL_PropertiesID props);

	/// <summary>
	/// Set a pointer property in a group of properties with a cleanup function<br/>
	/// that is called when the property is deleted.<br/>
	/// The cleanup function is also called if setting the property fails for any<br/>
	/// reason.<br/>
	/// For simply setting basic data types, like numbers, bools, or strings, use<br/>
	/// SDL_SetNumberProperty, SDL_SetBooleanProperty, or SDL_SetStringProperty<br/>
	/// instead, as those functions will handle cleanup on your behalf. This<br/>
	/// function is only for more complex, custom data.<br/>
	/// <br/>
	/// @param props the properties to modify.<br/>
	/// @param name the name of the property to modify.<br/>
	/// @param value the new value of the property, or NULL to delete the property.<br/>
	/// @param cleanup the function to call when this property is deleted, or NULL<br/>
	/// if no cleanup is necessary.<br/>
	/// @param userdata a pointer that is passed to the cleanup function.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPointerProperty<br/>
	/// @sa SDL_SetPointerProperty<br/>
	/// @sa SDL_CleanupPropertyCallback
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetPointerPropertyWithCleanup")]
	public static partial SDLBool SDL_SetPointerPropertyWithCleanup(SDL_PropertiesID props, byte* name, nint value, delegate* unmanaged[Cdecl]<nint, nint, void> cleanup, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_SetPointerPropertyWithCleanup")]
	public static partial SDLBool SDL_SetPointerPropertyWithCleanup(SDL_PropertiesID props, ReadOnlySpan<byte> name, nint value, delegate* unmanaged[Cdecl]<nint, nint, void> cleanup, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_SetPointerPropertyWithCleanup")]
	public static partial SDLBool SDL_SetPointerPropertyWithCleanup(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, nint value, delegate* unmanaged[Cdecl]<nint, nint, void> cleanup, nint userdata);

	/// <summary>
	/// Set a pointer property in a group of properties.<br/>
	/// <br/>
	/// @param props the properties to modify.<br/>
	/// @param name the name of the property to modify.<br/>
	/// @param value the new value of the property, or NULL to delete the property.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPointerProperty<br/>
	/// @sa SDL_HasProperty<br/>
	/// @sa SDL_SetBooleanProperty<br/>
	/// @sa SDL_SetFloatProperty<br/>
	/// @sa SDL_SetNumberProperty<br/>
	/// @sa SDL_SetPointerPropertyWithCleanup<br/>
	/// @sa SDL_SetStringProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetPointerProperty")]
	public static partial SDLBool SDL_SetPointerProperty(SDL_PropertiesID props, byte* name, nint value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetPointerProperty")]
	public static partial SDLBool SDL_SetPointerProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name, nint value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetPointerProperty")]
	public static partial SDLBool SDL_SetPointerProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, nint value);

	/// <summary>
	/// Set a string property in a group of properties.<br/>
	/// This function makes a copy of the string; the caller does not have to<br/>
	/// preserve the data after this call completes.<br/>
	/// <br/>
	/// @param props the properties to modify.<br/>
	/// @param name the name of the property to modify.<br/>
	/// @param value the new value of the property, or NULL to delete the property.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetStringProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetStringProperty")]
	public static partial SDLBool SDL_SetStringProperty(SDL_PropertiesID props, byte* name, byte* value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetStringProperty")]
	public static partial SDLBool SDL_SetStringProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name, ReadOnlySpan<byte> value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetStringProperty")]
	public static partial SDLBool SDL_SetStringProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value);

	/// <summary>
	/// Set an integer property in a group of properties.<br/>
	/// <br/>
	/// @param props the properties to modify.<br/>
	/// @param name the name of the property to modify.<br/>
	/// @param value the new value of the property.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumberProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetNumberProperty")]
	public static partial SDLBool SDL_SetNumberProperty(SDL_PropertiesID props, byte* name, long value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetNumberProperty")]
	public static partial SDLBool SDL_SetNumberProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name, long value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetNumberProperty")]
	public static partial SDLBool SDL_SetNumberProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, long value);

	/// <summary>
	/// Set a floating point property in a group of properties.<br/>
	/// <br/>
	/// @param props the properties to modify.<br/>
	/// @param name the name of the property to modify.<br/>
	/// @param value the new value of the property.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetFloatProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetFloatProperty")]
	public static partial SDLBool SDL_SetFloatProperty(SDL_PropertiesID props, byte* name, float value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetFloatProperty")]
	public static partial SDLBool SDL_SetFloatProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name, float value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetFloatProperty")]
	public static partial SDLBool SDL_SetFloatProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, float value);

	/// <summary>
	/// Set a boolean property in a group of properties.<br/>
	/// <br/>
	/// @param props the properties to modify.<br/>
	/// @param name the name of the property to modify.<br/>
	/// @param value the new value of the property.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetBooleanProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetBooleanProperty")]
	public static partial SDLBool SDL_SetBooleanProperty(SDL_PropertiesID props, byte* name, SDLBool value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetBooleanProperty")]
	public static partial SDLBool SDL_SetBooleanProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name, SDLBool value);

	[LibraryImport(LibName, EntryPoint = "SDL_SetBooleanProperty")]
	public static partial SDLBool SDL_SetBooleanProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, SDLBool value);

	/// <summary>
	/// Return whether a property exists in a group of properties.<br/>
	/// <br/>
	/// @param props the properties to query.<br/>
	/// @param name the name of the property to query.<br/>
	/// @returns true if the property exists, or false if it doesn't.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPropertyType
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasProperty")]
	public static partial SDLBool SDL_HasProperty(SDL_PropertiesID props, byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_HasProperty")]
	public static partial SDLBool SDL_HasProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_HasProperty")]
	public static partial SDLBool SDL_HasProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Get the type of a property in a group of properties.<br/>
	/// <br/>
	/// @param props the properties to query.<br/>
	/// @param name the name of the property to query.<br/>
	/// @returns the type of the property, or SDL_PROPERTY_TYPE_INVALID if it is<br/>
	/// not set.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPropertyType")]
	public static partial SDL_PropertyType SDL_GetPropertyType(SDL_PropertiesID props, byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_GetPropertyType")]
	public static partial SDL_PropertyType SDL_GetPropertyType(SDL_PropertiesID props, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_GetPropertyType")]
	public static partial SDL_PropertyType SDL_GetPropertyType(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Get a pointer property from a group of properties.<br/>
	/// By convention, the names of properties that SDL exposes on objects will<br/>
	/// start with "SDL.", and properties that SDL uses internally will start with<br/>
	/// "SDL.internal.". These should be considered read-only and should not be<br/>
	/// modified by applications.<br/>
	/// <br/>
	/// @param props the properties to query.<br/>
	/// @param name the name of the property to query.<br/>
	/// @param default_value the default value of the property.<br/>
	/// @returns the value of the property, or `default_value` if it is not set or<br/>
	/// not a pointer property.<br/>
	/// @threadsafety It is safe to call this function from any thread, although<br/>
	/// the data returned is not protected and could potentially be<br/>
	/// freed if you call SDL_SetPointerProperty() or<br/>
	/// SDL_ClearProperty() on these properties from another thread.<br/>
	/// If you need to avoid this, use SDL_LockProperties() and<br/>
	/// SDL_UnlockProperties().<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetBooleanProperty<br/>
	/// @sa SDL_GetFloatProperty<br/>
	/// @sa SDL_GetNumberProperty<br/>
	/// @sa SDL_GetPropertyType<br/>
	/// @sa SDL_GetStringProperty<br/>
	/// @sa SDL_HasProperty<br/>
	/// @sa SDL_SetPointerProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPointerProperty")]
	public static partial nint SDL_GetPointerProperty(SDL_PropertiesID props, byte* name, nint default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetPointerProperty")]
	public static partial nint SDL_GetPointerProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name, nint default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetPointerProperty")]
	public static partial nint SDL_GetPointerProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, nint default_value);

	/// <summary>
	/// Get a string property from a group of properties.<br/>
	/// <br/>
	/// @param props the properties to query.<br/>
	/// @param name the name of the property to query.<br/>
	/// @param default_value the default value of the property.<br/>
	/// @returns the value of the property, or `default_value` if it is not set or<br/>
	/// not a string property.<br/>
	/// @threadsafety It is safe to call this function from any thread, although<br/>
	/// the data returned is not protected and could potentially be<br/>
	/// freed if you call SDL_SetStringProperty() or<br/>
	/// SDL_ClearProperty() on these properties from another thread.<br/>
	/// If you need to avoid this, use SDL_LockProperties() and<br/>
	/// SDL_UnlockProperties().<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPropertyType<br/>
	/// @sa SDL_HasProperty<br/>
	/// @sa SDL_SetStringProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetStringProperty")]
	public static partial byte* SDL_GetStringPropertyPtr(SDL_PropertiesID props, byte* name, byte* default_value);

	public static string? SDL_GetStringProperty(SDL_PropertiesID props, byte* name, byte* default_value)
	{
		return ConvertToManaged(SDL_GetStringPropertyPtr(props, name, default_value));
	}

	[LibraryImport(LibName, EntryPoint = "SDL_GetStringProperty")]
	public static partial byte* SDL_GetStringPropertyPtr(SDL_PropertiesID props, ReadOnlySpan<byte> name, ReadOnlySpan<byte> default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetStringProperty")]
	public static partial byte* SDL_GetStringPropertyPtr(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> default_value);

	/// <summary>
	/// Get a number property from a group of properties.<br/>
	/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
	/// is a number property.<br/>
	/// <br/>
	/// @param props the properties to query.<br/>
	/// @param name the name of the property to query.<br/>
	/// @param default_value the default value of the property.<br/>
	/// @returns the value of the property, or `default_value` if it is not set or<br/>
	/// not a number property.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPropertyType<br/>
	/// @sa SDL_HasProperty<br/>
	/// @sa SDL_SetNumberProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumberProperty")]
	public static partial long SDL_GetNumberProperty(SDL_PropertiesID props, byte* name, long default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetNumberProperty")]
	public static partial long SDL_GetNumberProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name, long default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetNumberProperty")]
	public static partial long SDL_GetNumberProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, long default_value);

	/// <summary>
	/// Get a floating point property from a group of properties.<br/>
	/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
	/// is a floating point property.<br/>
	/// <br/>
	/// @param props the properties to query.<br/>
	/// @param name the name of the property to query.<br/>
	/// @param default_value the default value of the property.<br/>
	/// @returns the value of the property, or `default_value` if it is not set or<br/>
	/// not a float property.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPropertyType<br/>
	/// @sa SDL_HasProperty<br/>
	/// @sa SDL_SetFloatProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetFloatProperty")]
	public static partial float SDL_GetFloatProperty(SDL_PropertiesID props, byte* name, float default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetFloatProperty")]
	public static partial float SDL_GetFloatProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name, float default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetFloatProperty")]
	public static partial float SDL_GetFloatProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, float default_value);

	/// <summary>
	/// Get a boolean property from a group of properties.<br/>
	/// You can use SDL_GetPropertyType() to query whether the property exists and<br/>
	/// is a boolean property.<br/>
	/// <br/>
	/// @param props the properties to query.<br/>
	/// @param name the name of the property to query.<br/>
	/// @param default_value the default value of the property.<br/>
	/// @returns the value of the property, or `default_value` if it is not set or<br/>
	/// not a boolean property.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPropertyType<br/>
	/// @sa SDL_HasProperty<br/>
	/// @sa SDL_SetBooleanProperty
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetBooleanProperty")]
	public static partial SDLBool SDL_GetBooleanProperty(SDL_PropertiesID props, byte* name, SDLBool default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetBooleanProperty")]
	public static partial SDLBool SDL_GetBooleanProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name, SDLBool default_value);

	[LibraryImport(LibName, EntryPoint = "SDL_GetBooleanProperty")]
	public static partial SDLBool SDL_GetBooleanProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, SDLBool default_value);

	/// <summary>
	/// Clear a property from a group of properties.<br/>
	/// <br/>
	/// @param props the properties to modify.<br/>
	/// @param name the name of the property to clear.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ClearProperty")]
	public static partial SDLBool SDL_ClearProperty(SDL_PropertiesID props, byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_ClearProperty")]
	public static partial SDLBool SDL_ClearProperty(SDL_PropertiesID props, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_ClearProperty")]
	public static partial SDLBool SDL_ClearProperty(SDL_PropertiesID props, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Enumerate the properties contained in a group of properties.<br/>
	/// The callback function is called for each property in the group of<br/>
	/// properties. The properties are locked during enumeration.<br/>
	/// <br/>
	/// @param props the properties to query.<br/>
	/// @param callback the function to call for each property.<br/>
	/// @param userdata a pointer that is passed to `callback`.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EnumerateProperties")]
	public static partial SDLBool SDL_EnumerateProperties(SDL_PropertiesID props, delegate* unmanaged[Cdecl]<nint, SDL_PropertiesID, byte*, void> callback, nint userdata);

	/// <summary>
	/// Destroy a group of properties.<br/>
	/// All properties are deleted and their cleanup functions will be called, if<br/>
	/// any.<br/>
	/// <br/>
	/// @param props the properties to destroy.<br/>
	/// @threadsafety This function should not be called while these properties are<br/>
	/// locked or other threads might be setting or getting values<br/>
	/// from these properties.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProperties
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyProperties")]
	public static partial void SDL_DestroyProperties(SDL_PropertiesID props);

	/// <summary>
	/// Convert an SDL_Rect to SDL_FRect<br/>
	/// <br/>
	/// @param rect a pointer to an SDL_Rect.<br/>
	/// @param frect a pointer filled in with the floating point representation of<br/>
	/// `rect`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RectToFRect")]
	public static partial void SDL_RectToFRect(Rectangle* rect, RectangleF* frect);

	/// <summary>
	/// Determine whether a point resides inside a rectangle.<br/>
	/// A point is considered part of a rectangle if both `p` and `r` are not NULL,<br/>
	/// and `p`'s x and y coordinates are >= to the rectangle's top left corner,<br/>
	/// and<br/>
	/// <<br/>
	/// the rectangle's x+w and y+h. So a 1x1 rectangle considers point (0,0)<br/>
	/// as "inside" and (0,1) as not.<br/>
	/// Note that this is a forced-inline function in a header, and not a public<br/>
	/// API function available in the SDL library (which is to say, the code is<br/>
	/// embedded in the calling program and the linker and dynamic loader will not<br/>
	/// be able to find this function inside SDL itself).<br/>
	/// <br/>
	/// @param p the point to test.<br/>
	/// @param r the rectangle to test.<br/>
	/// @returns true if `p` is contained by `r`, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PointInRect")]
	public static partial SDLBool SDL_PointInRect(Point* p, Rectangle* r);

	/// <summary>
	/// Determine whether a rectangle has no area.<br/>
	/// A rectangle is considered "empty" for this function if `r` is NULL, or if<br/>
	/// `r`'s width and/or height are<br/>
	/// <<br/>
	/// = 0.<br/>
	/// Note that this is a forced-inline function in a header, and not a public<br/>
	/// API function available in the SDL library (which is to say, the code is<br/>
	/// embedded in the calling program and the linker and dynamic loader will not<br/>
	/// be able to find this function inside SDL itself).<br/>
	/// <br/>
	/// @param r the rectangle to test.<br/>
	/// @returns true if the rectangle is "empty", false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RectEmpty")]
	public static partial SDLBool SDL_RectEmpty(Rectangle* r);

	/// <summary>
	/// Determine whether two rectangles are equal.<br/>
	/// Rectangles are considered equal if both are not NULL and each of their x,<br/>
	/// y, width and height match.<br/>
	/// Note that this is a forced-inline function in a header, and not a public<br/>
	/// API function available in the SDL library (which is to say, the code is<br/>
	/// embedded in the calling program and the linker and dynamic loader will not<br/>
	/// be able to find this function inside SDL itself).<br/>
	/// <br/>
	/// @param a the first rectangle to test.<br/>
	/// @param b the second rectangle to test.<br/>
	/// @returns true if the rectangles are equal, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RectsEqual")]
	public static partial SDLBool SDL_RectsEqual(Rectangle* a, Rectangle* b);

	/// <summary>
	/// Determine whether two rectangles intersect.<br/>
	/// If either pointer is NULL the function will return false.<br/>
	/// <br/>
	/// @param A an SDL_Rect structure representing the first rectangle.<br/>
	/// @param B an SDL_Rect structure representing the second rectangle.<br/>
	/// @returns true if there is an intersection, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRectIntersection
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasRectIntersection")]
	public static partial SDLBool SDL_HasRectIntersection(Rectangle* A, Rectangle* B);

	/// <summary>
	/// Calculate the intersection of two rectangles.<br/>
	/// If `result` is NULL then this function will return false.<br/>
	/// <br/>
	/// @param A an SDL_Rect structure representing the first rectangle.<br/>
	/// @param B an SDL_Rect structure representing the second rectangle.<br/>
	/// @param result an SDL_Rect structure filled in with the intersection of<br/>
	/// rectangles `A` and `B`.<br/>
	/// @returns true if there is an intersection, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasRectIntersection
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRectIntersection")]
	public static partial SDLBool SDL_GetRectIntersection(Rectangle* A, Rectangle* B, Rectangle* result);

	/// <summary>
	/// Calculate the union of two rectangles.<br/>
	/// <br/>
	/// @param A an SDL_Rect structure representing the first rectangle.<br/>
	/// @param B an SDL_Rect structure representing the second rectangle.<br/>
	/// @param result an SDL_Rect structure filled in with the union of rectangles<br/>
	/// `A` and `B`.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRectUnion")]
	public static partial SDLBool SDL_GetRectUnion(Rectangle* A, Rectangle* B, Rectangle* result);

	/// <summary>
	/// Calculate a minimal rectangle enclosing a set of points.<br/>
	/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
	/// considered.<br/>
	/// <br/>
	/// @param points an array of SDL_Point structures representing points to be<br/>
	/// enclosed.<br/>
	/// @param count the number of structures in the `points` array.<br/>
	/// @param clip an SDL_Rect used for clipping or NULL to enclose all points.<br/>
	/// @param result an SDL_Rect structure filled in with the minimal enclosing<br/>
	/// rectangle.<br/>
	/// @returns true if any points were enclosed or false if all the points were<br/>
	/// outside of the clipping rectangle.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRectEnclosingPoints")]
	public static partial SDLBool SDL_GetRectEnclosingPoints(Point* points, int count, Rectangle* clip, Rectangle* result);

	/// <summary>
	/// Calculate the intersection of a rectangle and line segment.<br/>
	/// This function is used to clip a line segment to a rectangle. A line segment<br/>
	/// contained entirely within the rectangle or that does not intersect will<br/>
	/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
	/// both ends will be clipped to the boundary of the rectangle and the new<br/>
	/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
	/// <br/>
	/// @param rect an SDL_Rect structure representing the rectangle to intersect.<br/>
	/// @param X1 a pointer to the starting X-coordinate of the line.<br/>
	/// @param Y1 a pointer to the starting Y-coordinate of the line.<br/>
	/// @param X2 a pointer to the ending X-coordinate of the line.<br/>
	/// @param Y2 a pointer to the ending Y-coordinate of the line.<br/>
	/// @returns true if there is an intersection, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRectAndLineIntersection")]
	public static partial SDLBool SDL_GetRectAndLineIntersection(Rectangle* rect, int* X1, int* Y1, int* X2, int* Y2);

	/// <summary>
	/// Determine whether a point resides inside a floating point rectangle.<br/>
	/// A point is considered part of a rectangle if both `p` and `r` are not NULL,<br/>
	/// and `p`'s x and y coordinates are >= to the rectangle's top left corner,<br/>
	/// and<br/>
	/// <<br/>
	/// = the rectangle's x+w and y+h. So a 1x1 rectangle considers point<br/>
	/// (0,0) and (0,1) as "inside" and (0,2) as not.<br/>
	/// Note that this is a forced-inline function in a header, and not a public<br/>
	/// API function available in the SDL library (which is to say, the code is<br/>
	/// embedded in the calling program and the linker and dynamic loader will not<br/>
	/// be able to find this function inside SDL itself).<br/>
	/// <br/>
	/// @param p the point to test.<br/>
	/// @param r the rectangle to test.<br/>
	/// @returns true if `p` is contained by `r`, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PointInRectFloat")]
	public static partial SDLBool SDL_PointInRectFloat(PointF* p, RectangleF* r);

	/// <summary>
	/// Determine whether a floating point rectangle can contain any point.<br/>
	/// A rectangle is considered "empty" for this function if `r` is NULL, or if<br/>
	/// `r`'s width and/or height are<br/>
	/// <<br/>
	/// 0.0f.<br/>
	/// Note that this is a forced-inline function in a header, and not a public<br/>
	/// API function available in the SDL library (which is to say, the code is<br/>
	/// embedded in the calling program and the linker and dynamic loader will not<br/>
	/// be able to find this function inside SDL itself).<br/>
	/// <br/>
	/// @param r the rectangle to test.<br/>
	/// @returns true if the rectangle is "empty", false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RectEmptyFloat")]
	public static partial SDLBool SDL_RectEmptyFloat(RectangleF* r);

	/// <summary>
	/// Determine whether two floating point rectangles are equal, within some<br/>
	/// given epsilon.<br/>
	/// Rectangles are considered equal if both are not NULL and each of their x,<br/>
	/// y, width and height are within `epsilon` of each other. If you don't know<br/>
	/// what value to use for `epsilon`, you should call the SDL_RectsEqualFloat<br/>
	/// function instead.<br/>
	/// Note that this is a forced-inline function in a header, and not a public<br/>
	/// API function available in the SDL library (which is to say, the code is<br/>
	/// embedded in the calling program and the linker and dynamic loader will not<br/>
	/// be able to find this function inside SDL itself).<br/>
	/// <br/>
	/// @param a the first rectangle to test.<br/>
	/// @param b the second rectangle to test.<br/>
	/// @param epsilon the epsilon value for comparison.<br/>
	/// @returns true if the rectangles are equal, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RectsEqualFloat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RectsEqualEpsilon")]
	public static partial SDLBool SDL_RectsEqualEpsilon(RectangleF* a, RectangleF* b, float epsilon);

	/// <summary>
	/// Determine whether two floating point rectangles are equal, within a default<br/>
	/// epsilon.<br/>
	/// Rectangles are considered equal if both are not NULL and each of their x,<br/>
	/// y, width and height are within SDL_FLT_EPSILON of each other. This is often<br/>
	/// a reasonable way to compare two floating point rectangles and deal with the<br/>
	/// slight precision variations in floating point calculations that tend to pop<br/>
	/// up.<br/>
	/// Note that this is a forced-inline function in a header, and not a public<br/>
	/// API function available in the SDL library (which is to say, the code is<br/>
	/// embedded in the calling program and the linker and dynamic loader will not<br/>
	/// be able to find this function inside SDL itself).<br/>
	/// <br/>
	/// @param a the first rectangle to test.<br/>
	/// @param b the second rectangle to test.<br/>
	/// @returns true if the rectangles are equal, false otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RectsEqualEpsilon
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RectsEqualFloat")]
	public static partial SDLBool SDL_RectsEqualFloat(RectangleF* a, RectangleF* b);

	/// <summary>
	/// Determine whether two rectangles intersect with float precision.<br/>
	/// If either pointer is NULL the function will return false.<br/>
	/// <br/>
	/// @param A an SDL_FRect structure representing the first rectangle.<br/>
	/// @param B an SDL_FRect structure representing the second rectangle.<br/>
	/// @returns true if there is an intersection, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRectIntersection
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HasRectIntersectionFloat")]
	public static partial SDLBool SDL_HasRectIntersectionFloat(RectangleF* A, RectangleF* B);

	/// <summary>
	/// Calculate the intersection of two rectangles with float precision.<br/>
	/// If `result` is NULL then this function will return false.<br/>
	/// <br/>
	/// @param A an SDL_FRect structure representing the first rectangle.<br/>
	/// @param B an SDL_FRect structure representing the second rectangle.<br/>
	/// @param result an SDL_FRect structure filled in with the intersection of<br/>
	/// rectangles `A` and `B`.<br/>
	/// @returns true if there is an intersection, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HasRectIntersectionFloat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRectIntersectionFloat")]
	public static partial SDLBool SDL_GetRectIntersectionFloat(RectangleF* A, RectangleF* B, RectangleF* result);

	/// <summary>
	/// Calculate the union of two rectangles with float precision.<br/>
	/// <br/>
	/// @param A an SDL_FRect structure representing the first rectangle.<br/>
	/// @param B an SDL_FRect structure representing the second rectangle.<br/>
	/// @param result an SDL_FRect structure filled in with the union of rectangles<br/>
	/// `A` and `B`.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRectUnionFloat")]
	public static partial SDLBool SDL_GetRectUnionFloat(RectangleF* A, RectangleF* B, RectangleF* result);

	/// <summary>
	/// Calculate a minimal rectangle enclosing a set of points with float<br/>
	/// precision.<br/>
	/// If `clip` is not NULL then only points inside of the clipping rectangle are<br/>
	/// considered.<br/>
	/// <br/>
	/// @param points an array of SDL_FPoint structures representing points to be<br/>
	/// enclosed.<br/>
	/// @param count the number of structures in the `points` array.<br/>
	/// @param clip an SDL_FRect used for clipping or NULL to enclose all points.<br/>
	/// @param result an SDL_FRect structure filled in with the minimal enclosing<br/>
	/// rectangle.<br/>
	/// @returns true if any points were enclosed or false if all the points were<br/>
	/// outside of the clipping rectangle.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRectEnclosingPointsFloat")]
	public static partial SDLBool SDL_GetRectEnclosingPointsFloat(PointF* points, int count, RectangleF* clip, RectangleF* result);

	/// <summary>
	/// Calculate the intersection of a rectangle and line segment with float<br/>
	/// precision.<br/>
	/// This function is used to clip a line segment to a rectangle. A line segment<br/>
	/// contained entirely within the rectangle or that does not intersect will<br/>
	/// remain unchanged. A line segment that crosses the rectangle at either or<br/>
	/// both ends will be clipped to the boundary of the rectangle and the new<br/>
	/// coordinates saved in `X1`, `Y1`, `X2`, and/or `Y2` as necessary.<br/>
	/// <br/>
	/// @param rect an SDL_FRect structure representing the rectangle to intersect.<br/>
	/// @param X1 a pointer to the starting X-coordinate of the line.<br/>
	/// @param Y1 a pointer to the starting Y-coordinate of the line.<br/>
	/// @param X2 a pointer to the ending X-coordinate of the line.<br/>
	/// @param Y2 a pointer to the ending Y-coordinate of the line.<br/>
	/// @returns true if there is an intersection, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRectAndLineIntersectionFloat")]
	public static partial SDLBool SDL_GetRectAndLineIntersectionFloat(RectangleF* rect, float* X1, float* Y1, float* X2, float* Y2);

	/// <summary>
	/// Get the number of 2D rendering drivers available for the current display.<br/>
	/// A render driver is a set of code that handles rendering and texture<br/>
	/// management on a particular display. Normally there is only one, but some<br/>
	/// drivers may have several available with different capabilities.<br/>
	/// There may be none if SDL was compiled without render support.<br/>
	/// <br/>
	/// @returns the number of built in render drivers.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateRenderer<br/>
	/// @sa SDL_GetRenderDriver
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumRenderDrivers")]
	public static partial int SDL_GetNumRenderDrivers();

	/// <summary>
	/// Use this function to get the name of a built in 2D rendering driver.<br/>
	/// The list of rendering drivers is given in the order that they are normally<br/>
	/// initialized by default; the drivers that seem more reasonable to choose<br/>
	/// first (as far as the SDL developers believe) are earlier in the list.<br/>
	/// The names of drivers are all simple, low-ASCII identifiers, like "opengl",<br/>
	/// "direct3d12" or "metal". These never have Unicode characters, and are not<br/>
	/// meant to be proper names.<br/>
	/// <br/>
	/// @param index the index of the rendering driver; the value ranges from 0 to<br/>
	/// SDL_GetNumRenderDrivers() - 1.<br/>
	/// @returns the name of the rendering driver at the requested index, or NULL<br/>
	/// if an invalid index was specified.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumRenderDrivers
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderDriver")]
	public static partial byte* SDL_GetRenderDriverPtr(int index);

	public static string? SDL_GetRenderDriver(int index)
	{
		return ConvertToManaged(SDL_GetRenderDriverPtr(index));
	}

	/// <summary>
	/// Create a window and default renderer.<br/>
	/// <br/>
	/// @param title the title of the window, in UTF-8 encoding.<br/>
	/// @param width the width of the window.<br/>
	/// @param height the height of the window.<br/>
	/// @param window_flags the flags used to create the window (see<br/>
	/// SDL_CreateWindow()).<br/>
	/// @param window a pointer filled with the window, or NULL on error.<br/>
	/// @param renderer a pointer filled with the renderer, or NULL on error.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateRenderer<br/>
	/// @sa SDL_CreateWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateWindowAndRenderer")]
	public static partial SDLBool SDL_CreateWindowAndRenderer(byte* title, int width, int height, SDL_WindowFlags window_flags, SDL_Window window, SDL_Renderer renderer);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateWindowAndRenderer")]
	public static partial SDLBool SDL_CreateWindowAndRenderer(ReadOnlySpan<byte> title, int width, int height, SDL_WindowFlags window_flags, SDL_Window window, SDL_Renderer renderer);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateWindowAndRenderer")]
	public static partial SDLBool SDL_CreateWindowAndRenderer([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> title, int width, int height, SDL_WindowFlags window_flags, SDL_Window window, SDL_Renderer renderer);

	/// <summary>
	/// Create a 2D rendering context for a window.<br/>
	/// If you want a specific renderer, you can specify its name here. A list of<br/>
	/// available renderers can be obtained by calling SDL_GetRenderDriver multiple<br/>
	/// times, with indices from 0 to SDL_GetNumRenderDrivers()-1. If you don't<br/>
	/// need a specific renderer, specify NULL and SDL will attempt to choose the<br/>
	/// best option for you, based on what is available on the user's system.<br/>
	/// By default the rendering size matches the window size in pixels, but you<br/>
	/// can call SDL_SetRenderLogicalPresentation() to change the content size and<br/>
	/// scaling options.<br/>
	/// <br/>
	/// @param window the window where rendering is displayed.<br/>
	/// @param name the name of the rendering driver to initialize, or NULL to<br/>
	/// initialize the first one supporting the requested flags.<br/>
	/// @returns a valid rendering context or NULL if there was an error; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateRendererWithProperties<br/>
	/// @sa SDL_CreateSoftwareRenderer<br/>
	/// @sa SDL_DestroyRenderer<br/>
	/// @sa SDL_GetNumRenderDrivers<br/>
	/// @sa SDL_GetRenderDriver<br/>
	/// @sa SDL_GetRendererName
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateRenderer")]
	public static partial SDL_Renderer SDL_CreateRenderer(SDL_Window window, byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateRenderer")]
	public static partial SDL_Renderer SDL_CreateRenderer(SDL_Window window, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateRenderer")]
	public static partial SDL_Renderer SDL_CreateRenderer(SDL_Window window, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Create a 2D rendering context for a window, with the specified properties.<br/>
	/// These are the supported properties:<br/>
	/// - `SDL_PROP_RENDERER_CREATE_NAME_STRING`: the name of the rendering driver<br/>
	/// to use, if a specific one is desired<br/>
	/// - `SDL_PROP_RENDERER_CREATE_WINDOW_POINTER`: the window where rendering is<br/>
	/// displayed, required if this isn't a software renderer using a surface<br/>
	/// - `SDL_PROP_RENDERER_CREATE_SURFACE_POINTER`: the surface where rendering<br/>
	/// is displayed, if you want a software renderer without a window<br/>
	/// - `SDL_PROP_RENDERER_CREATE_OUTPUT_COLORSPACE_NUMBER`: an SDL_ColorSpace<br/>
	/// value describing the colorspace for output to the display, defaults to<br/>
	/// SDL_COLORSPACE_SRGB. The direct3d11, direct3d12, and metal renderers<br/>
	/// support SDL_COLORSPACE_SRGB_LINEAR, which is a linear color space and<br/>
	/// supports HDR output. If you select SDL_COLORSPACE_SRGB_LINEAR, drawing<br/>
	/// still uses the sRGB colorspace, but values can go beyond 1.0 and float<br/>
	/// (linear) format textures can be used for HDR content.<br/>
	/// - `SDL_PROP_RENDERER_CREATE_PRESENT_VSYNC_NUMBER`: non-zero if you want<br/>
	/// present synchronized with the refresh rate. This property can take any<br/>
	/// value that is supported by SDL_SetRenderVSync() for the renderer.<br/>
	/// With the vulkan renderer:<br/>
	/// - `SDL_PROP_RENDERER_CREATE_VULKAN_INSTANCE_POINTER`: the VkInstance to use<br/>
	/// with the renderer, optional.<br/>
	/// - `SDL_PROP_RENDERER_CREATE_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR to use<br/>
	/// with the renderer, optional.<br/>
	/// - `SDL_PROP_RENDERER_CREATE_VULKAN_PHYSICAL_DEVICE_POINTER`: the<br/>
	/// VkPhysicalDevice to use with the renderer, optional.<br/>
	/// - `SDL_PROP_RENDERER_CREATE_VULKAN_DEVICE_POINTER`: the VkDevice to use<br/>
	/// with the renderer, optional.<br/>
	/// - `SDL_PROP_RENDERER_CREATE_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the<br/>
	/// queue family index used for rendering.<br/>
	/// - `SDL_PROP_RENDERER_CREATE_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the<br/>
	/// queue family index used for presentation.<br/>
	/// <br/>
	/// @param props the properties to use.<br/>
	/// @returns a valid rendering context or NULL if there was an error; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProperties<br/>
	/// @sa SDL_CreateRenderer<br/>
	/// @sa SDL_CreateSoftwareRenderer<br/>
	/// @sa SDL_DestroyRenderer<br/>
	/// @sa SDL_GetRendererName
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateRendererWithProperties")]
	public static partial SDL_Renderer SDL_CreateRendererWithProperties(SDL_PropertiesID props);

	/// <summary>
	/// Create a 2D software rendering context for a surface.<br/>
	/// Two other API which can be used to create SDL_Renderer:<br/>
	/// SDL_CreateRenderer() and SDL_CreateWindowAndRenderer(). These can _also_<br/>
	/// create a software renderer, but they are intended to be used with an<br/>
	/// SDL_Window as the final destination and not an SDL_Surface.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure representing the surface where<br/>
	/// rendering is done.<br/>
	/// @returns a valid rendering context or NULL if there was an error; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroyRenderer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateSoftwareRenderer")]
	public static partial SDL_Renderer SDL_CreateSoftwareRenderer(SDL_Surface* surface);

	/// <summary>
	/// Get the renderer associated with a window.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns the rendering context on success or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderer")]
	public static partial SDL_Renderer SDL_GetRenderer(SDL_Window window);

	/// <summary>
	/// Get the window associated with a renderer.<br/>
	/// <br/>
	/// @param renderer the renderer to query.<br/>
	/// @returns the window on success or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderWindow")]
	public static partial SDL_Window SDL_GetRenderWindow(SDL_Renderer renderer);

	/// <summary>
	/// Get the name of a renderer.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @returns the name of the selected renderer, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateRenderer<br/>
	/// @sa SDL_CreateRendererWithProperties
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRendererName")]
	public static partial byte* SDL_GetRendererNamePtr(SDL_Renderer renderer);

	public static string? SDL_GetRendererName(SDL_Renderer renderer)
	{
		return ConvertToManaged(SDL_GetRendererNamePtr(renderer));
	}

	/// <summary>
	/// Get the properties associated with a renderer.<br/>
	/// The following read-only properties are provided by SDL:<br/>
	/// - `SDL_PROP_RENDERER_NAME_STRING`: the name of the rendering driver<br/>
	/// - `SDL_PROP_RENDERER_WINDOW_POINTER`: the window where rendering is<br/>
	/// displayed, if any<br/>
	/// - `SDL_PROP_RENDERER_SURFACE_POINTER`: the surface where rendering is<br/>
	/// displayed, if this is a software renderer without a window<br/>
	/// - `SDL_PROP_RENDERER_VSYNC_NUMBER`: the current vsync setting<br/>
	/// - `SDL_PROP_RENDERER_MAX_TEXTURE_SIZE_NUMBER`: the maximum texture width<br/>
	/// and height<br/>
	/// - `SDL_PROP_RENDERER_TEXTURE_FORMATS_POINTER`: a (const SDL_PixelFormat *)<br/>
	/// array of pixel formats, terminated with SDL_PIXELFORMAT_UNKNOWN,<br/>
	/// representing the available texture formats for this renderer.<br/>
	/// - `SDL_PROP_RENDERER_OUTPUT_COLORSPACE_NUMBER`: an SDL_ColorSpace value<br/>
	/// describing the colorspace for output to the display, defaults to<br/>
	/// SDL_COLORSPACE_SRGB.<br/>
	/// - `SDL_PROP_RENDERER_HDR_ENABLED_BOOLEAN`: true if the output colorspace is<br/>
	/// SDL_COLORSPACE_SRGB_LINEAR and the renderer is showing on a display with<br/>
	/// HDR enabled. This property can change dynamically when<br/>
	/// SDL_EVENT_DISPLAY_HDR_STATE_CHANGED is sent.<br/>
	/// - `SDL_PROP_RENDERER_SDR_WHITE_POINT_FLOAT`: the value of SDR white in the<br/>
	/// SDL_COLORSPACE_SRGB_LINEAR colorspace. When HDR is enabled, this value is<br/>
	/// automatically multiplied into the color scale. This property can change<br/>
	/// dynamically when SDL_EVENT_DISPLAY_HDR_STATE_CHANGED is sent.<br/>
	/// - `SDL_PROP_RENDERER_HDR_HEADROOM_FLOAT`: the additional high dynamic range<br/>
	/// that can be displayed, in terms of the SDR white point. When HDR is not<br/>
	/// enabled, this will be 1.0. This property can change dynamically when<br/>
	/// SDL_EVENT_DISPLAY_HDR_STATE_CHANGED is sent.<br/>
	/// With the direct3d renderer:<br/>
	/// - `SDL_PROP_RENDERER_D3D9_DEVICE_POINTER`: the IDirect3DDevice9 associated<br/>
	/// with the renderer<br/>
	/// With the direct3d11 renderer:<br/>
	/// - `SDL_PROP_RENDERER_D3D11_DEVICE_POINTER`: the ID3D11Device associated<br/>
	/// with the renderer<br/>
	/// - `SDL_PROP_RENDERER_D3D11_SWAPCHAIN_POINTER`: the IDXGISwapChain1<br/>
	/// associated with the renderer. This may change when the window is resized.<br/>
	/// With the direct3d12 renderer:<br/>
	/// - `SDL_PROP_RENDERER_D3D12_DEVICE_POINTER`: the ID3D12Device associated<br/>
	/// with the renderer<br/>
	/// - `SDL_PROP_RENDERER_D3D12_SWAPCHAIN_POINTER`: the IDXGISwapChain4<br/>
	/// associated with the renderer.<br/>
	/// - `SDL_PROP_RENDERER_D3D12_COMMAND_QUEUE_POINTER`: the ID3D12CommandQueue<br/>
	/// associated with the renderer<br/>
	/// With the vulkan renderer:<br/>
	/// - `SDL_PROP_RENDERER_VULKAN_INSTANCE_POINTER`: the VkInstance associated<br/>
	/// with the renderer<br/>
	/// - `SDL_PROP_RENDERER_VULKAN_SURFACE_NUMBER`: the VkSurfaceKHR associated<br/>
	/// with the renderer<br/>
	/// - `SDL_PROP_RENDERER_VULKAN_PHYSICAL_DEVICE_POINTER`: the VkPhysicalDevice<br/>
	/// associated with the renderer<br/>
	/// - `SDL_PROP_RENDERER_VULKAN_DEVICE_POINTER`: the VkDevice associated with<br/>
	/// the renderer<br/>
	/// - `SDL_PROP_RENDERER_VULKAN_GRAPHICS_QUEUE_FAMILY_INDEX_NUMBER`: the queue<br/>
	/// family index used for rendering<br/>
	/// - `SDL_PROP_RENDERER_VULKAN_PRESENT_QUEUE_FAMILY_INDEX_NUMBER`: the queue<br/>
	/// family index used for presentation<br/>
	/// - `SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER`: the number of<br/>
	/// swapchain images, or potential frames in flight, used by the Vulkan<br/>
	/// renderer<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRendererProperties")]
	public static partial SDL_PropertiesID SDL_GetRendererProperties(SDL_Renderer renderer);

	/// <summary>
	/// Get the output size in pixels of a rendering context.<br/>
	/// This returns the true output size in pixels, ignoring any render targets or<br/>
	/// logical size and presentation.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param w a pointer filled in with the width in pixels.<br/>
	/// @param h a pointer filled in with the height in pixels.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetCurrentRenderOutputSize
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderOutputSize")]
	public static partial SDLBool SDL_GetRenderOutputSize(SDL_Renderer renderer, out int w, out int h);

	/// <summary>
	/// Get the current output size in pixels of a rendering context.<br/>
	/// If a rendering target is active, this will return the size of the rendering<br/>
	/// target in pixels, otherwise if a logical size is set, it will return the<br/>
	/// logical size, otherwise it will return the value of<br/>
	/// SDL_GetRenderOutputSize().<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param w a pointer filled in with the current width.<br/>
	/// @param h a pointer filled in with the current height.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderOutputSize
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentRenderOutputSize")]
	public static partial SDLBool SDL_GetCurrentRenderOutputSize(SDL_Renderer renderer, out int w, out int h);

	/// <summary>
	/// Create a texture for a rendering context.<br/>
	/// The contents of a texture when first created are not defined.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param format one of the enumerated values in SDL_PixelFormat.<br/>
	/// @param access one of the enumerated values in SDL_TextureAccess.<br/>
	/// @param w the width of the texture in pixels.<br/>
	/// @param h the height of the texture in pixels.<br/>
	/// @returns a pointer to the created texture or NULL if no rendering context<br/>
	/// was active, the format was unsupported, or the width or height<br/>
	/// were out of range; call SDL_GetError() for more information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateTextureFromSurface<br/>
	/// @sa SDL_CreateTextureWithProperties<br/>
	/// @sa SDL_DestroyTexture<br/>
	/// @sa SDL_GetTextureSize<br/>
	/// @sa SDL_UpdateTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateTexture")]
	public static partial SDL_Texture* SDL_CreateTexture(SDL_Renderer renderer, SDL_PixelFormat format, SDL_TextureAccess access, int w, int h);

	/// <summary>
	/// Create a texture from an existing surface.<br/>
	/// The surface is not modified or freed by this function.<br/>
	/// The SDL_TextureAccess hint for the created texture is<br/>
	/// `SDL_TEXTUREACCESS_STATIC`.<br/>
	/// The pixel format of the created texture may be different from the pixel<br/>
	/// format of the surface, and can be queried using the<br/>
	/// SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param surface the SDL_Surface structure containing pixel data used to fill<br/>
	/// the texture.<br/>
	/// @returns the created texture or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateTexture<br/>
	/// @sa SDL_CreateTextureWithProperties<br/>
	/// @sa SDL_DestroyTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateTextureFromSurface")]
	public static partial SDL_Texture* SDL_CreateTextureFromSurface(SDL_Renderer renderer, SDL_Surface* surface);

	/// <summary>
	/// Create a texture for a rendering context with the specified properties.<br/>
	/// These are the supported properties:<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_COLORSPACE_NUMBER`: an SDL_ColorSpace value<br/>
	/// describing the texture colorspace, defaults to SDL_COLORSPACE_SRGB_LINEAR<br/>
	/// for floating point textures, SDL_COLORSPACE_HDR10 for 10-bit textures,<br/>
	/// SDL_COLORSPACE_SRGB for other RGB textures and SDL_COLORSPACE_JPEG for<br/>
	/// YUV textures.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_FORMAT_NUMBER`: one of the enumerated values in<br/>
	/// SDL_PixelFormat, defaults to the best RGBA format for the renderer<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_ACCESS_NUMBER`: one of the enumerated values in<br/>
	/// SDL_TextureAccess, defaults to SDL_TEXTUREACCESS_STATIC<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_WIDTH_NUMBER`: the width of the texture in<br/>
	/// pixels, required<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_HEIGHT_NUMBER`: the height of the texture in<br/>
	/// pixels, required<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating<br/>
	/// point textures, this defines the value of 100% diffuse white, with higher<br/>
	/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
	/// to 100 for HDR10 textures and 1.0 for floating point textures.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_HDR_HEADROOM_FLOAT`: for HDR10 and floating<br/>
	/// point textures, this defines the maximum dynamic range used by the<br/>
	/// content, in terms of the SDR white point. This would be equivalent to<br/>
	/// maxCLL / SDL_PROP_TEXTURE_CREATE_SDR_WHITE_POINT_FLOAT for HDR10 content.<br/>
	/// If this is defined, any values outside the range supported by the display<br/>
	/// will be scaled into the available HDR headroom, otherwise they are<br/>
	/// clipped.<br/>
	/// With the direct3d11 renderer:<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D<br/>
	/// associated with the texture, if you want to wrap an existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D<br/>
	/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
	/// existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D<br/>
	/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
	/// existing texture.<br/>
	/// With the direct3d12 renderer:<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_POINTER`: the ID3D12Resource<br/>
	/// associated with the texture, if you want to wrap an existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource<br/>
	/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
	/// existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource<br/>
	/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
	/// existing texture.<br/>
	/// With the metal renderer:<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_METAL_PIXELBUFFER_POINTER`: the CVPixelBufferRef<br/>
	/// associated with the texture, if you want to create a texture from an<br/>
	/// existing pixel buffer.<br/>
	/// With the opengl renderer:<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_NUMBER`: the GLuint texture<br/>
	/// associated with the texture, if you want to wrap an existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
	/// associated with the UV plane of an NV12 texture, if you want to wrap an<br/>
	/// existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture<br/>
	/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
	/// existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture<br/>
	/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
	/// existing texture.<br/>
	/// With the opengles2 renderer:<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
	/// associated with the texture, if you want to wrap an existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
	/// associated with the texture, if you want to wrap an existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
	/// associated with the UV plane of an NV12 texture, if you want to wrap an<br/>
	/// existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture<br/>
	/// associated with the U plane of a YUV texture, if you want to wrap an<br/>
	/// existing texture.<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture<br/>
	/// associated with the V plane of a YUV texture, if you want to wrap an<br/>
	/// existing texture.<br/>
	/// With the vulkan renderer:<br/>
	/// - `SDL_PROP_TEXTURE_CREATE_VULKAN_TEXTURE_NUMBER`: the VkImage with layout<br/>
	/// VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL associated with the texture, if<br/>
	/// you want to wrap an existing texture.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param props the properties to use.<br/>
	/// @returns a pointer to the created texture or NULL if no rendering context<br/>
	/// was active, the format was unsupported, or the width or height<br/>
	/// were out of range; call SDL_GetError() for more information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProperties<br/>
	/// @sa SDL_CreateTexture<br/>
	/// @sa SDL_CreateTextureFromSurface<br/>
	/// @sa SDL_DestroyTexture<br/>
	/// @sa SDL_GetTextureSize<br/>
	/// @sa SDL_UpdateTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateTextureWithProperties")]
	public static partial SDL_Texture* SDL_CreateTextureWithProperties(SDL_Renderer renderer, SDL_PropertiesID props);

	/// <summary>
	/// Get the properties associated with a texture.<br/>
	/// The following read-only properties are provided by SDL:<br/>
	/// - `SDL_PROP_TEXTURE_COLORSPACE_NUMBER`: an SDL_ColorSpace value describing<br/>
	/// the texture colorspace.<br/>
	/// - `SDL_PROP_TEXTURE_FORMAT_NUMBER`: one of the enumerated values in<br/>
	/// SDL_PixelFormat.<br/>
	/// - `SDL_PROP_TEXTURE_ACCESS_NUMBER`: one of the enumerated values in<br/>
	/// SDL_TextureAccess.<br/>
	/// - `SDL_PROP_TEXTURE_WIDTH_NUMBER`: the width of the texture in pixels.<br/>
	/// - `SDL_PROP_TEXTURE_HEIGHT_NUMBER`: the height of the texture in pixels.<br/>
	/// - `SDL_PROP_TEXTURE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
	/// textures, this defines the value of 100% diffuse white, with higher<br/>
	/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
	/// to 100 for HDR10 textures and 1.0 for other textures.<br/>
	/// - `SDL_PROP_TEXTURE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
	/// textures, this defines the maximum dynamic range used by the content, in<br/>
	/// terms of the SDR white point. If this is defined, any values outside the<br/>
	/// range supported by the display will be scaled into the available HDR<br/>
	/// headroom, otherwise they are clipped. This defaults to 1.0 for SDR<br/>
	/// textures, 4.0 for HDR10 textures, and no default for floating point<br/>
	/// textures.<br/>
	/// With the direct3d11 renderer:<br/>
	/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_POINTER`: the ID3D11Texture2D associated<br/>
	/// with the texture<br/>
	/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_U_POINTER`: the ID3D11Texture2D<br/>
	/// associated with the U plane of a YUV texture<br/>
	/// - `SDL_PROP_TEXTURE_D3D11_TEXTURE_V_POINTER`: the ID3D11Texture2D<br/>
	/// associated with the V plane of a YUV texture<br/>
	/// With the direct3d12 renderer:<br/>
	/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_POINTER`: the ID3D12Resource associated<br/>
	/// with the texture<br/>
	/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_U_POINTER`: the ID3D12Resource associated<br/>
	/// with the U plane of a YUV texture<br/>
	/// - `SDL_PROP_TEXTURE_D3D12_TEXTURE_V_POINTER`: the ID3D12Resource associated<br/>
	/// with the V plane of a YUV texture<br/>
	/// With the vulkan renderer:<br/>
	/// - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_POINTER`: the VkImage associated with<br/>
	/// the texture<br/>
	/// - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_U_POINTER`: the VkImage associated with<br/>
	/// the U plane of a YUV texture<br/>
	/// - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_V_POINTER`: the VkImage associated with<br/>
	/// the V plane of a YUV texture<br/>
	/// - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_UV_POINTER`: the VkImage associated with<br/>
	/// the UV plane of a NV12/NV21 texture<br/>
	/// With the opengl renderer:<br/>
	/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_NUMBER`: the GLuint texture associated<br/>
	/// with the texture<br/>
	/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
	/// associated with the UV plane of an NV12 texture<br/>
	/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_U_NUMBER`: the GLuint texture associated<br/>
	/// with the U plane of a YUV texture<br/>
	/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_V_NUMBER`: the GLuint texture associated<br/>
	/// with the V plane of a YUV texture<br/>
	/// - `SDL_PROP_TEXTURE_OPENGL_TEXTURE_TARGET_NUMBER`: the GLenum for the<br/>
	/// texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_RECTANGLE_ARB`, etc)<br/>
	/// - `SDL_PROP_TEXTURE_OPENGL_TEX_W_FLOAT`: the texture coordinate width of<br/>
	/// the texture (0.0 - 1.0)<br/>
	/// - `SDL_PROP_TEXTURE_OPENGL_TEX_H_FLOAT`: the texture coordinate height of<br/>
	/// the texture (0.0 - 1.0)<br/>
	/// With the opengles2 renderer:<br/>
	/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_NUMBER`: the GLuint texture<br/>
	/// associated with the texture<br/>
	/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_UV_NUMBER`: the GLuint texture<br/>
	/// associated with the UV plane of an NV12 texture<br/>
	/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_U_NUMBER`: the GLuint texture<br/>
	/// associated with the U plane of a YUV texture<br/>
	/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_V_NUMBER`: the GLuint texture<br/>
	/// associated with the V plane of a YUV texture<br/>
	/// - `SDL_PROP_TEXTURE_OPENGLES2_TEXTURE_TARGET_NUMBER`: the GLenum for the<br/>
	/// texture target (`GL_TEXTURE_2D`, `GL_TEXTURE_EXTERNAL_OES`, etc)<br/>
	/// With the vulkan renderer:<br/>
	/// - `SDL_PROP_TEXTURE_VULKAN_TEXTURE_NUMBER`: the VkImage associated with the<br/>
	/// texture<br/>
	/// <br/>
	/// @param texture the texture to query.<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTextureProperties")]
	public static partial SDL_PropertiesID SDL_GetTextureProperties(SDL_Texture* texture);

	/// <summary>
	/// Get the renderer that created an SDL_Texture.<br/>
	/// <br/>
	/// @param texture the texture to query.<br/>
	/// @returns a pointer to the SDL_Renderer that created the texture, or NULL on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRendererFromTexture")]
	public static partial SDL_Renderer SDL_GetRendererFromTexture(SDL_Texture* texture);

	/// <summary>
	/// Get the size of a texture, as floating point values.<br/>
	/// <br/>
	/// @param texture the texture to query.<br/>
	/// @param w a pointer filled in with the width of the texture in pixels. This<br/>
	/// argument can be NULL if you don't need this information.<br/>
	/// @param h a pointer filled in with the height of the texture in pixels. This<br/>
	/// argument can be NULL if you don't need this information.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTextureSize")]
	public static partial SDLBool SDL_GetTextureSize(SDL_Texture* texture, float* w, float* h);

	/// <summary>
	/// Set an additional color value multiplied into render copy operations.<br/>
	/// When this texture is rendered, during the copy operation each source color<br/>
	/// channel is modulated by the appropriate color value according to the<br/>
	/// following formula:<br/>
	/// `srcC = srcC * (color / 255)`<br/>
	/// Color modulation is not always supported by the renderer; it will return<br/>
	/// false if color modulation is not supported.<br/>
	/// <br/>
	/// @param texture the texture to update.<br/>
	/// @param r the red color value multiplied into copy operations.<br/>
	/// @param g the green color value multiplied into copy operations.<br/>
	/// @param b the blue color value multiplied into copy operations.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextureColorMod<br/>
	/// @sa SDL_SetTextureAlphaMod<br/>
	/// @sa SDL_SetTextureColorModFloat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetTextureColorMod")]
	public static partial SDLBool SDL_SetTextureColorMod(SDL_Texture* texture, byte r, byte g, byte b);

	/// <summary>
	/// Set an additional color value multiplied into render copy operations.<br/>
	/// When this texture is rendered, during the copy operation each source color<br/>
	/// channel is modulated by the appropriate color value according to the<br/>
	/// following formula:<br/>
	/// `srcC = srcC * color`<br/>
	/// Color modulation is not always supported by the renderer; it will return<br/>
	/// false if color modulation is not supported.<br/>
	/// <br/>
	/// @param texture the texture to update.<br/>
	/// @param r the red color value multiplied into copy operations.<br/>
	/// @param g the green color value multiplied into copy operations.<br/>
	/// @param b the blue color value multiplied into copy operations.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextureColorModFloat<br/>
	/// @sa SDL_SetTextureAlphaModFloat<br/>
	/// @sa SDL_SetTextureColorMod
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetTextureColorModFloat")]
	public static partial SDLBool SDL_SetTextureColorModFloat(SDL_Texture* texture, float r, float g, float b);

	/// <summary>
	/// Get the additional color value multiplied into render copy operations.<br/>
	/// <br/>
	/// @param texture the texture to query.<br/>
	/// @param r a pointer filled in with the current red color value.<br/>
	/// @param g a pointer filled in with the current green color value.<br/>
	/// @param b a pointer filled in with the current blue color value.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextureAlphaMod<br/>
	/// @sa SDL_GetTextureColorModFloat<br/>
	/// @sa SDL_SetTextureColorMod
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTextureColorMod")]
	public static partial SDLBool SDL_GetTextureColorMod(SDL_Texture* texture, byte* r, byte* g, byte* b);

	/// <summary>
	/// Get the additional color value multiplied into render copy operations.<br/>
	/// <br/>
	/// @param texture the texture to query.<br/>
	/// @param r a pointer filled in with the current red color value.<br/>
	/// @param g a pointer filled in with the current green color value.<br/>
	/// @param b a pointer filled in with the current blue color value.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextureAlphaModFloat<br/>
	/// @sa SDL_GetTextureColorMod<br/>
	/// @sa SDL_SetTextureColorModFloat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTextureColorModFloat")]
	public static partial SDLBool SDL_GetTextureColorModFloat(SDL_Texture* texture, float* r, float* g, float* b);

	/// <summary>
	/// Set an additional alpha value multiplied into render copy operations.<br/>
	/// When this texture is rendered, during the copy operation the source alpha<br/>
	/// value is modulated by this alpha value according to the following formula:<br/>
	/// `srcA = srcA * (alpha / 255)`<br/>
	/// Alpha modulation is not always supported by the renderer; it will return<br/>
	/// false if alpha modulation is not supported.<br/>
	/// <br/>
	/// @param texture the texture to update.<br/>
	/// @param alpha the source alpha value multiplied into copy operations.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextureAlphaMod<br/>
	/// @sa SDL_SetTextureAlphaModFloat<br/>
	/// @sa SDL_SetTextureColorMod
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetTextureAlphaMod")]
	public static partial SDLBool SDL_SetTextureAlphaMod(SDL_Texture* texture, byte alpha);

	/// <summary>
	/// Set an additional alpha value multiplied into render copy operations.<br/>
	/// When this texture is rendered, during the copy operation the source alpha<br/>
	/// value is modulated by this alpha value according to the following formula:<br/>
	/// `srcA = srcA * alpha`<br/>
	/// Alpha modulation is not always supported by the renderer; it will return<br/>
	/// false if alpha modulation is not supported.<br/>
	/// <br/>
	/// @param texture the texture to update.<br/>
	/// @param alpha the source alpha value multiplied into copy operations.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextureAlphaModFloat<br/>
	/// @sa SDL_SetTextureAlphaMod<br/>
	/// @sa SDL_SetTextureColorModFloat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetTextureAlphaModFloat")]
	public static partial SDLBool SDL_SetTextureAlphaModFloat(SDL_Texture* texture, float alpha);

	/// <summary>
	/// Get the additional alpha value multiplied into render copy operations.<br/>
	/// <br/>
	/// @param texture the texture to query.<br/>
	/// @param alpha a pointer filled in with the current alpha value.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextureAlphaModFloat<br/>
	/// @sa SDL_GetTextureColorMod<br/>
	/// @sa SDL_SetTextureAlphaMod
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTextureAlphaMod")]
	public static partial SDLBool SDL_GetTextureAlphaMod(SDL_Texture* texture, byte* alpha);

	/// <summary>
	/// Get the additional alpha value multiplied into render copy operations.<br/>
	/// <br/>
	/// @param texture the texture to query.<br/>
	/// @param alpha a pointer filled in with the current alpha value.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextureAlphaMod<br/>
	/// @sa SDL_GetTextureColorModFloat<br/>
	/// @sa SDL_SetTextureAlphaModFloat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTextureAlphaModFloat")]
	public static partial SDLBool SDL_GetTextureAlphaModFloat(SDL_Texture* texture, float* alpha);

	/// <summary>
	/// Set the blend mode for a texture, used by SDL_RenderTexture().<br/>
	/// If the blend mode is not supported, the closest supported mode is chosen<br/>
	/// and this function returns false.<br/>
	/// <br/>
	/// @param texture the texture to update.<br/>
	/// @param blendMode the SDL_BlendMode to use for texture blending.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextureBlendMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetTextureBlendMode")]
	public static partial SDLBool SDL_SetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode blendMode);

	/// <summary>
	/// Get the blend mode used for texture copy operations.<br/>
	/// <br/>
	/// @param texture the texture to query.<br/>
	/// @param blendMode a pointer filled in with the current SDL_BlendMode.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetTextureBlendMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTextureBlendMode")]
	public static partial SDLBool SDL_GetTextureBlendMode(SDL_Texture* texture, SDL_BlendMode* blendMode);

	/// <summary>
	/// Set the scale mode used for texture scale operations.<br/>
	/// The default texture scale mode is SDL_SCALEMODE_LINEAR.<br/>
	/// If the scale mode is not supported, the closest supported mode is chosen.<br/>
	/// <br/>
	/// @param texture the texture to update.<br/>
	/// @param scaleMode the SDL_ScaleMode to use for texture scaling.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTextureScaleMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetTextureScaleMode")]
	public static partial SDLBool SDL_SetTextureScaleMode(SDL_Texture* texture, SDL_ScaleMode scaleMode);

	/// <summary>
	/// Get the scale mode used for texture scale operations.<br/>
	/// <br/>
	/// @param texture the texture to query.<br/>
	/// @param scaleMode a pointer filled in with the current scale mode.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetTextureScaleMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTextureScaleMode")]
	public static partial SDLBool SDL_GetTextureScaleMode(SDL_Texture* texture, SDL_ScaleMode* scaleMode);

	/// <summary>
	/// Update the given texture rectangle with new pixel data.<br/>
	/// The pixel data must be in the pixel format of the texture, which can be<br/>
	/// queried using the SDL_PROP_TEXTURE_FORMAT_NUMBER property.<br/>
	/// This is a fairly slow function, intended for use with static textures that<br/>
	/// do not change often.<br/>
	/// If the texture is intended to be updated often, it is preferred to create<br/>
	/// the texture as streaming and use the locking functions referenced below.<br/>
	/// While this function will work with streaming textures, for optimization<br/>
	/// reasons you may not get the pixels back if you lock the texture afterward.<br/>
	/// <br/>
	/// @param texture the texture to update.<br/>
	/// @param rect an SDL_Rect structure representing the area to update, or NULL<br/>
	/// to update the entire texture.<br/>
	/// @param pixels the raw pixel data in the format of the texture.<br/>
	/// @param pitch the number of bytes in a row of pixel data, including padding<br/>
	/// between lines.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockTexture<br/>
	/// @sa SDL_UnlockTexture<br/>
	/// @sa SDL_UpdateNVTexture<br/>
	/// @sa SDL_UpdateYUVTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UpdateTexture")]
	public static partial SDLBool SDL_UpdateTexture(SDL_Texture* texture, Rectangle* rect, nint pixels, int pitch);

	/// <summary>
	/// Update a rectangle within a planar YV12 or IYUV texture with new pixel<br/>
	/// data.<br/>
	/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
	/// block of Y and U/V planes in the proper order, but this function is<br/>
	/// available if your pixel data is not contiguous.<br/>
	/// <br/>
	/// @param texture the texture to update.<br/>
	/// @param rect a pointer to the rectangle of pixels to update, or NULL to<br/>
	/// update the entire texture.<br/>
	/// @param Yplane the raw pixel data for the Y plane.<br/>
	/// @param Ypitch the number of bytes between rows of pixel data for the Y<br/>
	/// plane.<br/>
	/// @param Uplane the raw pixel data for the U plane.<br/>
	/// @param Upitch the number of bytes between rows of pixel data for the U<br/>
	/// plane.<br/>
	/// @param Vplane the raw pixel data for the V plane.<br/>
	/// @param Vpitch the number of bytes between rows of pixel data for the V<br/>
	/// plane.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_UpdateNVTexture<br/>
	/// @sa SDL_UpdateTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UpdateYUVTexture")]
	public static partial SDLBool SDL_UpdateYUVTexture(SDL_Texture* texture, Rectangle* rect, byte* Yplane, int Ypitch, byte* Uplane, int Upitch, byte* Vplane, int Vpitch);

	/// <summary>
	/// Update a rectangle within a planar NV12 or NV21 texture with new pixels.<br/>
	/// You can use SDL_UpdateTexture() as long as your pixel data is a contiguous<br/>
	/// block of NV12/21 planes in the proper order, but this function is available<br/>
	/// if your pixel data is not contiguous.<br/>
	/// <br/>
	/// @param texture the texture to update.<br/>
	/// @param rect a pointer to the rectangle of pixels to update, or NULL to<br/>
	/// update the entire texture.<br/>
	/// @param Yplane the raw pixel data for the Y plane.<br/>
	/// @param Ypitch the number of bytes between rows of pixel data for the Y<br/>
	/// plane.<br/>
	/// @param UVplane the raw pixel data for the UV plane.<br/>
	/// @param UVpitch the number of bytes between rows of pixel data for the UV<br/>
	/// plane.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_UpdateTexture<br/>
	/// @sa SDL_UpdateYUVTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UpdateNVTexture")]
	public static partial SDLBool SDL_UpdateNVTexture(SDL_Texture* texture, Rectangle* rect, byte* Yplane, int Ypitch, byte* UVplane, int UVpitch);

	/// <summary>
	/// Lock a portion of the texture for **write-only** pixel access.<br/>
	/// As an optimization, the pixels made available for editing don't necessarily<br/>
	/// contain the old texture data. This is a write-only operation, and if you<br/>
	/// need to keep a copy of the texture data you should do that at the<br/>
	/// application level.<br/>
	/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
	/// changes.<br/>
	/// <br/>
	/// @param texture the texture to lock for access, which was created with<br/>
	/// `SDL_TEXTUREACCESS_STREAMING`.<br/>
	/// @param rect an SDL_Rect structure representing the area to lock for access;<br/>
	/// NULL to lock the entire texture.<br/>
	/// @param pixels this is filled in with a pointer to the locked pixels,<br/>
	/// appropriately offset by the locked area.<br/>
	/// @param pitch this is filled in with the pitch of the locked pixels; the<br/>
	/// pitch is the length of one row in bytes.<br/>
	/// @returns true on success or false if the texture is not valid or was not<br/>
	/// created with `SDL_TEXTUREACCESS_STREAMING`; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockTextureToSurface<br/>
	/// @sa SDL_UnlockTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LockTexture")]
	public static partial SDLBool SDL_LockTexture(SDL_Texture* texture, Rectangle* rect, nint pixels, int* pitch);

	/// <summary>
	/// Lock a portion of the texture for **write-only** pixel access, and expose<br/>
	/// it as a SDL surface.<br/>
	/// Besides providing an SDL_Surface instead of raw pixel data, this function<br/>
	/// operates like SDL_LockTexture.<br/>
	/// As an optimization, the pixels made available for editing don't necessarily<br/>
	/// contain the old texture data. This is a write-only operation, and if you<br/>
	/// need to keep a copy of the texture data you should do that at the<br/>
	/// application level.<br/>
	/// You must use SDL_UnlockTexture() to unlock the pixels and apply any<br/>
	/// changes.<br/>
	/// The returned surface is freed internally after calling SDL_UnlockTexture()<br/>
	/// or SDL_DestroyTexture(). The caller should not free it.<br/>
	/// <br/>
	/// @param texture the texture to lock for access, which must be created with<br/>
	/// `SDL_TEXTUREACCESS_STREAMING`.<br/>
	/// @param rect a pointer to the rectangle to lock for access. If the rect is<br/>
	/// NULL, the entire texture will be locked.<br/>
	/// @param surface this is filled in with an SDL surface representing the<br/>
	/// locked area.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockTexture<br/>
	/// @sa SDL_UnlockTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LockTextureToSurface")]
	public static partial SDLBool SDL_LockTextureToSurface(SDL_Texture* texture, Rectangle* rect, SDL_Surface** surface);

	/// <summary>
	/// Unlock a texture, uploading the changes to video memory, if needed.<br/>
	/// **Warning**: Please note that SDL_LockTexture() is intended to be<br/>
	/// write-only; it will not guarantee the previous contents of the texture will<br/>
	/// be provided. You must fully initialize any area of a texture that you lock<br/>
	/// before unlocking it, as the pixels might otherwise be uninitialized memory.<br/>
	/// Which is to say: locking and immediately unlocking a texture can result in<br/>
	/// corrupted textures, depending on the renderer in use.<br/>
	/// <br/>
	/// @param texture a texture locked by SDL_LockTexture().<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnlockTexture")]
	public static partial void SDL_UnlockTexture(SDL_Texture* texture);

	/// <summary>
	/// Set a texture as the current rendering target.<br/>
	/// The default render target is the window for which the renderer was created.<br/>
	/// To stop rendering to a texture and render to the window again, call this<br/>
	/// function with a NULL `texture`.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param texture the targeted texture, which must be created with the<br/>
	/// `SDL_TEXTUREACCESS_TARGET` flag, or NULL to render to the<br/>
	/// window instead of a texture.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderTarget
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetRenderTarget")]
	public static partial SDLBool SDL_SetRenderTarget(SDL_Renderer renderer, SDL_Texture* texture);

	/// <summary>
	/// Get the current render target.<br/>
	/// The default render target is the window for which the renderer was created,<br/>
	/// and is reported a NULL here.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @returns the current render target or NULL for the default render target.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderTarget
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderTarget")]
	public static partial SDL_Texture* SDL_GetRenderTarget(SDL_Renderer renderer);

	/// <summary>
	/// Set a device independent resolution and presentation mode for rendering.<br/>
	/// This function sets the width and height of the logical rendering output.<br/>
	/// The renderer will act as if the window is always the requested dimensions,<br/>
	/// scaling to the actual window resolution as necessary.<br/>
	/// This can be useful for games that expect a fixed size, but would like to<br/>
	/// scale the output to whatever is available, regardless of how a user resizes<br/>
	/// a window, or if the display is high DPI.<br/>
	/// You can disable logical coordinates by setting the mode to<br/>
	/// SDL_LOGICAL_PRESENTATION_DISABLED, and in that case you get the full pixel<br/>
	/// resolution of the output window; it is safe to toggle logical presentation<br/>
	/// during the rendering of a frame: perhaps most of the rendering is done to<br/>
	/// specific dimensions but to make fonts look sharp, the app turns off logical<br/>
	/// presentation while drawing text.<br/>
	/// Letterboxing will only happen if logical presentation is enabled during<br/>
	/// SDL_RenderPresent; be sure to reenable it first if you were using it.<br/>
	/// You can convert coordinates in an event into rendering coordinates using<br/>
	/// SDL_ConvertEventToRenderCoordinates().<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param w the width of the logical resolution.<br/>
	/// @param h the height of the logical resolution.<br/>
	/// @param mode the presentation mode used.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ConvertEventToRenderCoordinates<br/>
	/// @sa SDL_GetRenderLogicalPresentation<br/>
	/// @sa SDL_GetRenderLogicalPresentationRect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetRenderLogicalPresentation")]
	public static partial SDLBool SDL_SetRenderLogicalPresentation(SDL_Renderer renderer, int w, int h, SDL_RendererLogicalPresentation mode);

	/// <summary>
	/// Get device independent resolution and presentation mode for rendering.<br/>
	/// This function gets the width and height of the logical rendering output, or<br/>
	/// the output size in pixels if a logical resolution is not enabled.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param w an int to be filled with the width.<br/>
	/// @param h an int to be filled with the height.<br/>
	/// @param mode the presentation mode used.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderLogicalPresentation
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderLogicalPresentation")]
	public static partial SDLBool SDL_GetRenderLogicalPresentation(SDL_Renderer renderer, out int w, out int h, SDL_RendererLogicalPresentation* mode);

	/// <summary>
	/// Get the final presentation rectangle for rendering.<br/>
	/// This function returns the calculated rectangle used for logical<br/>
	/// presentation, based on the presentation mode and output size. If logical<br/>
	/// presentation is disabled, it will fill the rectangle with the output size,<br/>
	/// in pixels.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param rect a pointer filled in with the final presentation rectangle, may<br/>
	/// be NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderLogicalPresentation
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderLogicalPresentationRect")]
	public static partial SDLBool SDL_GetRenderLogicalPresentationRect(SDL_Renderer renderer, RectangleF* rect);

	/// <summary>
	/// Get a point in render coordinates when given a point in window coordinates.<br/>
	/// This takes into account several states:<br/>
	/// - The window dimensions.<br/>
	/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
	/// - The scale (SDL_SetRenderScale)<br/>
	/// - The viewport (SDL_SetRenderViewport)<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param window_x the x coordinate in window coordinates.<br/>
	/// @param window_y the y coordinate in window coordinates.<br/>
	/// @param x a pointer filled with the x coordinate in render coordinates.<br/>
	/// @param y a pointer filled with the y coordinate in render coordinates.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderLogicalPresentation<br/>
	/// @sa SDL_SetRenderScale
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderCoordinatesFromWindow")]
	public static partial SDLBool SDL_RenderCoordinatesFromWindow(SDL_Renderer renderer, float window_x, float window_y, float* x, float* y);

	/// <summary>
	/// Get a point in window coordinates when given a point in render coordinates.<br/>
	/// This takes into account several states:<br/>
	/// - The window dimensions.<br/>
	/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
	/// - The scale (SDL_SetRenderScale)<br/>
	/// - The viewport (SDL_SetRenderViewport)<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param x the x coordinate in render coordinates.<br/>
	/// @param y the y coordinate in render coordinates.<br/>
	/// @param window_x a pointer filled with the x coordinate in window<br/>
	/// coordinates.<br/>
	/// @param window_y a pointer filled with the y coordinate in window<br/>
	/// coordinates.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderLogicalPresentation<br/>
	/// @sa SDL_SetRenderScale<br/>
	/// @sa SDL_SetRenderViewport
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderCoordinatesToWindow")]
	public static partial SDLBool SDL_RenderCoordinatesToWindow(SDL_Renderer renderer, float x, float y, float* window_x, float* window_y);

	/// <summary>
	/// Convert the coordinates in an event to render coordinates.<br/>
	/// This takes into account several states:<br/>
	/// - The window dimensions.<br/>
	/// - The logical presentation settings (SDL_SetRenderLogicalPresentation)<br/>
	/// - The scale (SDL_SetRenderScale)<br/>
	/// - The viewport (SDL_SetRenderViewport)<br/>
	/// Touch coordinates are converted from normalized coordinates in the window<br/>
	/// to non-normalized rendering coordinates.<br/>
	/// Once converted, the coordinates may be outside the rendering area.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param event the event to modify.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderCoordinatesFromWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ConvertEventToRenderCoordinates")]
	public static partial SDLBool SDL_ConvertEventToRenderCoordinates(SDL_Renderer renderer, SDL_Event* @event);

	/// <summary>
	/// Set the drawing area for rendering on the current target.<br/>
	/// Drawing will clip to this area (separately from any clipping done with<br/>
	/// SDL_SetRenderClipRect), and the top left of the area will become coordinate<br/>
	/// (0, 0) for future drawing commands.<br/>
	/// The area's width and height must be >= 0.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param rect the SDL_Rect structure representing the drawing area, or NULL<br/>
	/// to set the viewport to the entire target.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderViewport<br/>
	/// @sa SDL_RenderViewportSet
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetRenderViewport")]
	public static partial SDLBool SDL_SetRenderViewport(SDL_Renderer renderer, Rectangle* rect);

	/// <summary>
	/// Get the drawing area for the current target.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param rect an SDL_Rect structure filled in with the current drawing area.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderViewportSet<br/>
	/// @sa SDL_SetRenderViewport
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderViewport")]
	public static partial SDLBool SDL_GetRenderViewport(SDL_Renderer renderer, Rectangle* rect);

	/// <summary>
	/// Return whether an explicit rectangle was set as the viewport.<br/>
	/// This is useful if you're saving and restoring the viewport and want to know<br/>
	/// whether you should restore a specific rectangle or NULL. Note that the<br/>
	/// viewport is always reset when changing rendering targets.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @returns true if the viewport was set to a specific rectangle, or false if<br/>
	/// it was set to NULL (the entire target).<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderViewport<br/>
	/// @sa SDL_SetRenderViewport
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderViewportSet")]
	public static partial SDLBool SDL_RenderViewportSet(SDL_Renderer renderer);

	/// <summary>
	/// Get the safe area for rendering within the current viewport.<br/>
	/// Some devices have portions of the screen which are partially obscured or<br/>
	/// not interactive, possibly due to on-screen controls, curved edges, camera<br/>
	/// notches, TV overscan, etc. This function provides the area of the current<br/>
	/// viewport which is safe to have interactible content. You should continue<br/>
	/// rendering into the rest of the render target, but it should not contain<br/>
	/// visually important or interactible content.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param rect a pointer filled in with the area that is safe for interactive<br/>
	/// content.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderSafeArea")]
	public static partial SDLBool SDL_GetRenderSafeArea(SDL_Renderer renderer, Rectangle* rect);

	/// <summary>
	/// Set the clip rectangle for rendering on the specified target.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param rect an SDL_Rect structure representing the clip area, relative to<br/>
	/// the viewport, or NULL to disable clipping.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderClipRect<br/>
	/// @sa SDL_RenderClipEnabled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetRenderClipRect")]
	public static partial SDLBool SDL_SetRenderClipRect(SDL_Renderer renderer, Rectangle* rect);

	/// <summary>
	/// Get the clip rectangle for the current target.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param rect an SDL_Rect structure filled in with the current clipping area<br/>
	/// or an empty rectangle if clipping is disabled.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderClipEnabled<br/>
	/// @sa SDL_SetRenderClipRect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderClipRect")]
	public static partial SDLBool SDL_GetRenderClipRect(SDL_Renderer renderer, Rectangle* rect);

	/// <summary>
	/// Get whether clipping is enabled on the given renderer.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @returns true if clipping is enabled or false if not; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderClipRect<br/>
	/// @sa SDL_SetRenderClipRect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderClipEnabled")]
	public static partial SDLBool SDL_RenderClipEnabled(SDL_Renderer renderer);

	/// <summary>
	/// Set the drawing scale for rendering on the current target.<br/>
	/// The drawing coordinates are scaled by the x/y scaling factors before they<br/>
	/// are used by the renderer. This allows resolution independent drawing with a<br/>
	/// single coordinate system.<br/>
	/// If this results in scaling or subpixel drawing by the rendering backend, it<br/>
	/// will be handled using the appropriate quality hints. For best results use<br/>
	/// integer scaling factors.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param scaleX the horizontal scaling factor.<br/>
	/// @param scaleY the vertical scaling factor.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderScale
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetRenderScale")]
	public static partial SDLBool SDL_SetRenderScale(SDL_Renderer renderer, float scaleX, float scaleY);

	/// <summary>
	/// Get the drawing scale for the current target.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param scaleX a pointer filled in with the horizontal scaling factor.<br/>
	/// @param scaleY a pointer filled in with the vertical scaling factor.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderScale
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderScale")]
	public static partial SDLBool SDL_GetRenderScale(SDL_Renderer renderer, float* scaleX, float* scaleY);

	/// <summary>
	/// Set the color used for drawing operations.<br/>
	/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
	/// SDL_RenderClear().<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param r the red value used to draw on the rendering target.<br/>
	/// @param g the green value used to draw on the rendering target.<br/>
	/// @param b the blue value used to draw on the rendering target.<br/>
	/// @param a the alpha value used to draw on the rendering target; usually<br/>
	/// `SDL_ALPHA_OPAQUE` (255). Use SDL_SetRenderDrawBlendMode to<br/>
	/// specify how the alpha channel is used.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderDrawColor<br/>
	/// @sa SDL_SetRenderDrawColorFloat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetRenderDrawColor")]
	public static partial SDLBool SDL_SetRenderDrawColor(SDL_Renderer renderer, byte r, byte g, byte b, byte a);

	/// <summary>
	/// Set the color used for drawing operations (Rect, Line and Clear).<br/>
	/// Set the color for drawing or filling rectangles, lines, and points, and for<br/>
	/// SDL_RenderClear().<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param r the red value used to draw on the rendering target.<br/>
	/// @param g the green value used to draw on the rendering target.<br/>
	/// @param b the blue value used to draw on the rendering target.<br/>
	/// @param a the alpha value used to draw on the rendering target. Use<br/>
	/// SDL_SetRenderDrawBlendMode to specify how the alpha channel is<br/>
	/// used.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderDrawColorFloat<br/>
	/// @sa SDL_SetRenderDrawColor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetRenderDrawColorFloat")]
	public static partial SDLBool SDL_SetRenderDrawColorFloat(SDL_Renderer renderer, float r, float g, float b, float a);

	/// <summary>
	/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param r a pointer filled in with the red value used to draw on the<br/>
	/// rendering target.<br/>
	/// @param g a pointer filled in with the green value used to draw on the<br/>
	/// rendering target.<br/>
	/// @param b a pointer filled in with the blue value used to draw on the<br/>
	/// rendering target.<br/>
	/// @param a a pointer filled in with the alpha value used to draw on the<br/>
	/// rendering target; usually `SDL_ALPHA_OPAQUE` (255).<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderDrawColorFloat<br/>
	/// @sa SDL_SetRenderDrawColor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderDrawColor")]
	public static partial SDLBool SDL_GetRenderDrawColor(SDL_Renderer renderer, byte* r, byte* g, byte* b, byte* a);

	/// <summary>
	/// Get the color used for drawing operations (Rect, Line and Clear).<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param r a pointer filled in with the red value used to draw on the<br/>
	/// rendering target.<br/>
	/// @param g a pointer filled in with the green value used to draw on the<br/>
	/// rendering target.<br/>
	/// @param b a pointer filled in with the blue value used to draw on the<br/>
	/// rendering target.<br/>
	/// @param a a pointer filled in with the alpha value used to draw on the<br/>
	/// rendering target.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderDrawColorFloat<br/>
	/// @sa SDL_GetRenderDrawColor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderDrawColorFloat")]
	public static partial SDLBool SDL_GetRenderDrawColorFloat(SDL_Renderer renderer, float* r, float* g, float* b, float* a);

	/// <summary>
	/// Set the color scale used for render operations.<br/>
	/// The color scale is an additional scale multiplied into the pixel color<br/>
	/// value while rendering. This can be used to adjust the brightness of colors<br/>
	/// during HDR rendering, or changing HDR video brightness when playing on an<br/>
	/// SDR display.<br/>
	/// The color scale does not affect the alpha channel, only the color<br/>
	/// brightness.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param scale the color scale value.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderColorScale
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetRenderColorScale")]
	public static partial SDLBool SDL_SetRenderColorScale(SDL_Renderer renderer, float scale);

	/// <summary>
	/// Get the color scale used for render operations.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param scale a pointer filled in with the current color scale value.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderColorScale
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderColorScale")]
	public static partial SDLBool SDL_GetRenderColorScale(SDL_Renderer renderer, float* scale);

	/// <summary>
	/// Set the blend mode used for drawing operations (Fill and Line).<br/>
	/// If the blend mode is not supported, the closest supported mode is chosen.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param blendMode the SDL_BlendMode to use for blending.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderDrawBlendMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetRenderDrawBlendMode")]
	public static partial SDLBool SDL_SetRenderDrawBlendMode(SDL_Renderer renderer, SDL_BlendMode blendMode);

	/// <summary>
	/// Get the blend mode used for drawing operations.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param blendMode a pointer filled in with the current SDL_BlendMode.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderDrawBlendMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderDrawBlendMode")]
	public static partial SDLBool SDL_GetRenderDrawBlendMode(SDL_Renderer renderer, SDL_BlendMode* blendMode);

	/// <summary>
	/// Clear the current rendering target with the drawing color.<br/>
	/// This function clears the entire rendering target, ignoring the viewport and<br/>
	/// the clip rectangle. Note, that clearing will also set/fill all pixels of<br/>
	/// the rendering target to current renderer draw color, so make sure to invoke<br/>
	/// SDL_SetRenderDrawColor() when needed.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderDrawColor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderClear")]
	public static partial SDLBool SDL_RenderClear(SDL_Renderer renderer);

	/// <summary>
	/// Draw a point on the current rendering target at subpixel precision.<br/>
	/// <br/>
	/// @param renderer the renderer which should draw a point.<br/>
	/// @param x the x coordinate of the point.<br/>
	/// @param y the y coordinate of the point.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderPoints
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderPoint")]
	public static partial SDLBool SDL_RenderPoint(SDL_Renderer renderer, float x, float y);

	/// <summary>
	/// Draw multiple points on the current rendering target at subpixel precision.<br/>
	/// <br/>
	/// @param renderer the renderer which should draw multiple points.<br/>
	/// @param points the points to draw.<br/>
	/// @param count the number of points to draw.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderPoint
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderPoints")]
	public static partial SDLBool SDL_RenderPoints(SDL_Renderer renderer, PointF* points, int count);

	/// <summary>
	/// Draw a line on the current rendering target at subpixel precision.<br/>
	/// <br/>
	/// @param renderer the renderer which should draw a line.<br/>
	/// @param x1 the x coordinate of the start point.<br/>
	/// @param y1 the y coordinate of the start point.<br/>
	/// @param x2 the x coordinate of the end point.<br/>
	/// @param y2 the y coordinate of the end point.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderLines
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderLine")]
	public static partial SDLBool SDL_RenderLine(SDL_Renderer renderer, float x1, float y1, float x2, float y2);

	/// <summary>
	/// Draw a series of connected lines on the current rendering target at<br/>
	/// subpixel precision.<br/>
	/// <br/>
	/// @param renderer the renderer which should draw multiple lines.<br/>
	/// @param points the points along the lines.<br/>
	/// @param count the number of points, drawing count-1 lines.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderLine
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderLines")]
	public static partial SDLBool SDL_RenderLines(SDL_Renderer renderer, PointF* points, int count);

	/// <summary>
	/// Draw a rectangle on the current rendering target at subpixel precision.<br/>
	/// <br/>
	/// @param renderer the renderer which should draw a rectangle.<br/>
	/// @param rect a pointer to the destination rectangle, or NULL to outline the<br/>
	/// entire rendering target.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderRects
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderRect")]
	public static partial SDLBool SDL_RenderRect(SDL_Renderer renderer, RectangleF* rect);

	/// <summary>
	/// Draw some number of rectangles on the current rendering target at subpixel<br/>
	/// precision.<br/>
	/// <br/>
	/// @param renderer the renderer which should draw multiple rectangles.<br/>
	/// @param rects a pointer to an array of destination rectangles.<br/>
	/// @param count the number of rectangles.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderRect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderRects")]
	public static partial SDLBool SDL_RenderRects(SDL_Renderer renderer, RectangleF* rects, int count);

	/// <summary>
	/// Fill a rectangle on the current rendering target with the drawing color at<br/>
	/// subpixel precision.<br/>
	/// <br/>
	/// @param renderer the renderer which should fill a rectangle.<br/>
	/// @param rect a pointer to the destination rectangle, or NULL for the entire<br/>
	/// rendering target.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderFillRects
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderFillRect")]
	public static partial SDLBool SDL_RenderFillRect(SDL_Renderer renderer, RectangleF* rect);

	/// <summary>
	/// Fill some number of rectangles on the current rendering target with the<br/>
	/// drawing color at subpixel precision.<br/>
	/// <br/>
	/// @param renderer the renderer which should fill multiple rectangles.<br/>
	/// @param rects a pointer to an array of destination rectangles.<br/>
	/// @param count the number of rectangles.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderFillRect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderFillRects")]
	public static partial SDLBool SDL_RenderFillRects(SDL_Renderer renderer, RectangleF* rects, int count);

	/// <summary>
	/// Copy a portion of the texture to the current rendering target at subpixel<br/>
	/// precision.<br/>
	/// <br/>
	/// @param renderer the renderer which should copy parts of a texture.<br/>
	/// @param texture the source texture.<br/>
	/// @param srcrect a pointer to the source rectangle, or NULL for the entire<br/>
	/// texture.<br/>
	/// @param dstrect a pointer to the destination rectangle, or NULL for the<br/>
	/// entire rendering target.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderTextureRotated<br/>
	/// @sa SDL_RenderTextureTiled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderTexture")]
	public static partial SDLBool SDL_RenderTexture(SDL_Renderer renderer, SDL_Texture* texture, RectangleF* srcrect, RectangleF* dstrect);

	/// <summary>
	/// Copy a portion of the source texture to the current rendering target, with<br/>
	/// rotation and flipping, at subpixel precision.<br/>
	/// <br/>
	/// @param renderer the renderer which should copy parts of a texture.<br/>
	/// @param texture the source texture.<br/>
	/// @param srcrect a pointer to the source rectangle, or NULL for the entire<br/>
	/// texture.<br/>
	/// @param dstrect a pointer to the destination rectangle, or NULL for the<br/>
	/// entire rendering target.<br/>
	/// @param angle an angle in degrees that indicates the rotation that will be<br/>
	/// applied to dstrect, rotating it in a clockwise direction.<br/>
	/// @param center a pointer to a point indicating the point around which<br/>
	/// dstrect will be rotated (if NULL, rotation will be done<br/>
	/// around dstrect.w/2, dstrect.h/2).<br/>
	/// @param flip an SDL_FlipMode value stating which flipping actions should be<br/>
	/// performed on the texture.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderTextureRotated")]
	public static partial SDLBool SDL_RenderTextureRotated(SDL_Renderer renderer, SDL_Texture* texture, RectangleF* srcrect, RectangleF* dstrect, double angle, PointF* center, SDL_FlipMode flip);

	/// <summary>
	/// Tile a portion of the texture to the current rendering target at subpixel<br/>
	/// precision.<br/>
	/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
	/// completely fill `dstrect`.<br/>
	/// <br/>
	/// @param renderer the renderer which should copy parts of a texture.<br/>
	/// @param texture the source texture.<br/>
	/// @param srcrect a pointer to the source rectangle, or NULL for the entire<br/>
	/// texture.<br/>
	/// @param scale the scale used to transform srcrect into the destination<br/>
	/// rectangle, e.g. a 32x32 texture with a scale of 2 would fill<br/>
	/// 64x64 tiles.<br/>
	/// @param dstrect a pointer to the destination rectangle, or NULL for the<br/>
	/// entire rendering target.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderTextureTiled")]
	public static partial SDLBool SDL_RenderTextureTiled(SDL_Renderer renderer, SDL_Texture* texture, RectangleF* srcrect, float scale, RectangleF* dstrect);

	/// <summary>
	/// Perform a scaled copy using the 9-grid algorithm to the current rendering<br/>
	/// target at subpixel precision.<br/>
	/// The pixels in the texture are split into a 3x3 grid, using the different<br/>
	/// corner sizes for each corner, and the sides and center making up the<br/>
	/// remaining pixels. The corners are then scaled using `scale` and fit into<br/>
	/// the corners of the destination rectangle. The sides and center are then<br/>
	/// stretched into place to cover the remaining destination rectangle.<br/>
	/// <br/>
	/// @param renderer the renderer which should copy parts of a texture.<br/>
	/// @param texture the source texture.<br/>
	/// @param srcrect the SDL_Rect structure representing the rectangle to be used<br/>
	/// for the 9-grid, or NULL to use the entire texture.<br/>
	/// @param left_width the width, in pixels, of the left corners in `srcrect`.<br/>
	/// @param right_width the width, in pixels, of the right corners in `srcrect`.<br/>
	/// @param top_height the height, in pixels, of the top corners in `srcrect`.<br/>
	/// @param bottom_height the height, in pixels, of the bottom corners in<br/>
	/// `srcrect`.<br/>
	/// @param scale the scale used to transform the corner of `srcrect` into the<br/>
	/// corner of `dstrect`, or 0.0f for an unscaled copy.<br/>
	/// @param dstrect a pointer to the destination rectangle, or NULL for the<br/>
	/// entire rendering target.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderTexture9Grid")]
	public static partial SDLBool SDL_RenderTexture9Grid(SDL_Renderer renderer, SDL_Texture* texture, RectangleF* srcrect, float left_width, float right_width, float top_height, float bottom_height, float scale, RectangleF* dstrect);

	/// <summary>
	/// Render a list of triangles, optionally using a texture and indices into the<br/>
	/// vertex array Color and alpha modulation is done per vertex<br/>
	/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param texture (optional) The SDL texture to use.<br/>
	/// @param vertices vertices.<br/>
	/// @param num_vertices number of vertices.<br/>
	/// @param indices (optional) An array of integer indices into the 'vertices'<br/>
	/// array, if NULL all vertices will be rendered in sequential<br/>
	/// order.<br/>
	/// @param num_indices number of indices.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderGeometryRaw
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderGeometry")]
	public static partial SDLBool SDL_RenderGeometry(SDL_Renderer renderer, SDL_Texture* texture, SDL_Vertex* vertices, int num_vertices, int* indices, int num_indices);

	/// <summary>
	/// Render a list of triangles, optionally using a texture and indices into the<br/>
	/// vertex arrays Color and alpha modulation is done per vertex<br/>
	/// (SDL_SetTextureColorMod and SDL_SetTextureAlphaMod are ignored).<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param texture (optional) The SDL texture to use.<br/>
	/// @param xy vertex positions.<br/>
	/// @param xy_stride byte size to move from one element to the next element.<br/>
	/// @param color vertex colors (as SDL_FColor).<br/>
	/// @param color_stride byte size to move from one element to the next element.<br/>
	/// @param uv vertex normalized texture coordinates.<br/>
	/// @param uv_stride byte size to move from one element to the next element.<br/>
	/// @param num_vertices number of vertices.<br/>
	/// @param indices (optional) An array of indices into the 'vertices' arrays,<br/>
	/// if NULL all vertices will be rendered in sequential order.<br/>
	/// @param num_indices number of indices.<br/>
	/// @param size_indices index size: 1 (byte), 2 (short), 4 (int).<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RenderGeometry
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderGeometryRaw")]
	public static partial SDLBool SDL_RenderGeometryRaw(SDL_Renderer renderer, SDL_Texture* texture, float* xy, int xy_stride, SDL_FColor* color, int color_stride, float* uv, int uv_stride, int num_vertices, nint indices, int num_indices, int size_indices);

	/// <summary>
	/// Read pixels from the current rendering target.<br/>
	/// The returned surface should be freed with SDL_DestroySurface()<br/>
	/// **WARNING**: This is a very slow operation, and should not be used<br/>
	/// frequently. If you're using this on the main rendering target, it should be<br/>
	/// called after rendering and before SDL_RenderPresent().<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param rect an SDL_Rect structure representing the area in pixels relative<br/>
	/// to the to current viewport, or NULL for the entire viewport.<br/>
	/// @returns a new SDL_Surface on success or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderReadPixels")]
	public static partial SDL_Surface* SDL_RenderReadPixels(SDL_Renderer renderer, Rectangle* rect);

	/// <summary>
	/// Update the screen with any rendering performed since the previous call.<br/>
	/// SDL's rendering functions operate on a backbuffer; that is, calling a<br/>
	/// rendering function such as SDL_RenderLine() does not directly put a line on<br/>
	/// the screen, but rather updates the backbuffer. As such, you compose your<br/>
	/// entire scene and *present* the composed backbuffer to the screen as a<br/>
	/// complete picture.<br/>
	/// Therefore, when using SDL's rendering API, one does all drawing intended<br/>
	/// for the frame, and then calls this function once per frame to present the<br/>
	/// final drawing to the user.<br/>
	/// The backbuffer should be considered invalidated after each present; do not<br/>
	/// assume that previous contents will exist between frames. You are strongly<br/>
	/// encouraged to call SDL_RenderClear() to initialize the backbuffer before<br/>
	/// starting each new frame's drawing, even if you plan to overwrite every<br/>
	/// pixel.<br/>
	/// Please note, that in case of rendering to a texture - there is **no need**<br/>
	/// to call `SDL_RenderPresent` after drawing needed objects to a texture, and<br/>
	/// should not be done; you are only required to change back the rendering<br/>
	/// target to default via `SDL_SetRenderTarget(renderer, NULL)` afterwards, as<br/>
	/// textures by themselves do not have a concept of backbuffers. Calling<br/>
	/// SDL_RenderPresent while rendering to a texture will still update the screen<br/>
	/// with any current drawing that has been done _to the window itself_.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateRenderer<br/>
	/// @sa SDL_RenderClear<br/>
	/// @sa SDL_RenderFillRect<br/>
	/// @sa SDL_RenderFillRects<br/>
	/// @sa SDL_RenderLine<br/>
	/// @sa SDL_RenderLines<br/>
	/// @sa SDL_RenderPoint<br/>
	/// @sa SDL_RenderPoints<br/>
	/// @sa SDL_RenderRect<br/>
	/// @sa SDL_RenderRects<br/>
	/// @sa SDL_SetRenderDrawBlendMode<br/>
	/// @sa SDL_SetRenderDrawColor
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenderPresent")]
	public static partial SDLBool SDL_RenderPresent(SDL_Renderer renderer);

	/// <summary>
	/// Destroy the specified texture.<br/>
	/// Passing NULL or an otherwise invalid texture will set the SDL error message<br/>
	/// to "Invalid texture".<br/>
	/// <br/>
	/// @param texture the texture to destroy.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateTexture<br/>
	/// @sa SDL_CreateTextureFromSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyTexture")]
	public static partial void SDL_DestroyTexture(SDL_Texture* texture);

	/// <summary>
	/// Destroy the rendering context for a window and free all associated<br/>
	/// textures.<br/>
	/// This should be called before destroying the associated window.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateRenderer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyRenderer")]
	public static partial void SDL_DestroyRenderer(SDL_Renderer renderer);

	/// <summary>
	/// Force the rendering context to flush any pending commands and state.<br/>
	/// You do not need to (and in fact, shouldn't) call this function unless you<br/>
	/// are planning to call into OpenGL/Direct3D/Metal/whatever directly, in<br/>
	/// addition to using an SDL_Renderer.<br/>
	/// This is for a very-specific case: if you are using SDL's render API, and<br/>
	/// you plan to make OpenGL/D3D/whatever calls in addition to SDL render API<br/>
	/// calls. If this applies, you should call this function between calls to<br/>
	/// SDL's render API and the low-level API you're using in cooperation.<br/>
	/// In all other cases, you can ignore this function.<br/>
	/// This call makes SDL flush any pending rendering work it was queueing up to<br/>
	/// do later in a single batch, and marks any internal cached state as invalid,<br/>
	/// so it'll prepare all its state again later, from scratch.<br/>
	/// This means you do not need to save state in your rendering code to protect<br/>
	/// the SDL renderer. However, there lots of arbitrary pieces of Direct3D and<br/>
	/// OpenGL state that can confuse things; you should use your best judgment and<br/>
	/// be prepared to make changes if specific state needs to be protected.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_FlushRenderer")]
	public static partial SDLBool SDL_FlushRenderer(SDL_Renderer renderer);

	/// <summary>
	/// Get the CAMetalLayer associated with the given Metal renderer.<br/>
	/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
	/// headers, but it can be safely cast to a `CAMetalLayer *`.<br/>
	/// <br/>
	/// @param renderer the renderer to query.<br/>
	/// @returns a `CAMetalLayer *` on success, or NULL if the renderer isn't a<br/>
	/// Metal renderer.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderMetalCommandEncoder
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderMetalLayer")]
	public static partial nint SDL_GetRenderMetalLayer(SDL_Renderer renderer);

	/// <summary>
	/// Get the Metal command encoder for the current frame.<br/>
	/// This function returns `void *`, so SDL doesn't have to include Metal's<br/>
	/// headers, but it can be safely cast to an `id<br/>
	/// <MTLRenderCommandEncoder<br/>
	/// >`.<br/>
	/// This will return NULL if Metal refuses to give SDL a drawable to render to,<br/>
	/// which might happen if the window is hidden/minimized/offscreen. This<br/>
	/// doesn't apply to command encoders for render targets, just the window's<br/>
	/// backbuffer. Check your return values!<br/>
	/// <br/>
	/// @param renderer the renderer to query.<br/>
	/// @returns an `id<br/>
	/// <MTLRenderCommandEncoder<br/>
	/// >` on success, or NULL if the<br/>
	/// renderer isn't a Metal renderer or there was an error.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderMetalLayer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderMetalCommandEncoder")]
	public static partial nint SDL_GetRenderMetalCommandEncoder(SDL_Renderer renderer);

	/// <summary>
	/// Add a set of synchronization semaphores for the current frame.<br/>
	/// The Vulkan renderer will wait for `wait_semaphore` before submitting<br/>
	/// rendering commands and signal `signal_semaphore` after rendering commands<br/>
	/// are complete for this frame.<br/>
	/// This should be called each frame that you want semaphore synchronization.<br/>
	/// The Vulkan renderer may have multiple frames in flight on the GPU, so you<br/>
	/// should have multiple semaphores that are used for synchronization. Querying<br/>
	/// SDL_PROP_RENDERER_VULKAN_SWAPCHAIN_IMAGE_COUNT_NUMBER will give you the<br/>
	/// maximum number of semaphores you'll need.<br/>
	/// <br/>
	/// @param renderer the rendering context.<br/>
	/// @param wait_stage_mask the VkPipelineStageFlags for the wait.<br/>
	/// @param wait_semaphore a VkSempahore to wait on before rendering the current<br/>
	/// frame, or 0 if not needed.<br/>
	/// @param signal_semaphore a VkSempahore that SDL will signal when rendering<br/>
	/// for the current frame is complete, or 0 if not<br/>
	/// needed.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is **NOT** safe to call this function from two threads at<br/>
	/// once.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AddVulkanRenderSemaphores")]
	public static partial SDLBool SDL_AddVulkanRenderSemaphores(SDL_Renderer renderer, uint wait_stage_mask, long wait_semaphore, long signal_semaphore);

	/// <summary>
	/// Toggle VSync of the given renderer.<br/>
	/// When a renderer is created, vsync defaults to SDL_RENDERER_VSYNC_DISABLED.<br/>
	/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
	/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
	/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
	/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
	/// supported by every driver, so you should check the return value to see<br/>
	/// whether the requested setting is supported.<br/>
	/// <br/>
	/// @param renderer the renderer to toggle.<br/>
	/// @param vsync the vertical refresh sync interval.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderVSync
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetRenderVSync")]
	public static partial SDLBool SDL_SetRenderVSync(SDL_Renderer renderer, int vsync);

	/// <summary>
	/// Get VSync of the given renderer.<br/>
	/// <br/>
	/// @param renderer the renderer to toggle.<br/>
	/// @param vsync an int filled with the current vertical refresh sync interval.<br/>
	/// See SDL_SetRenderVSync() for the meaning of the value.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety You may only call this function from the main thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetRenderVSync
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRenderVSync")]
	public static partial SDLBool SDL_GetRenderVSync(SDL_Renderer renderer, int* vsync);

	/// <summary>
	/// Get a list of currently connected sensors.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of sensors returned, may<br/>
	/// be NULL.<br/>
	/// @returns a 0 terminated array of sensor instance IDs or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This should be freed<br/>
	/// with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensors")]
	public static partial SDL_SensorID* SDL_GetSensors(out int count);

	/// <summary>
	/// Get the implementation dependent name of a sensor.<br/>
	/// This can be called before any sensors are opened.<br/>
	/// <br/>
	/// @param instance_id the sensor instance ID.<br/>
	/// @returns the sensor name, or NULL if `instance_id` is not valid.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensorNameForID")]
	public static partial byte* SDL_GetSensorNameForIDPtr(SDL_SensorID instance_id);

	public static string? SDL_GetSensorNameForID(SDL_SensorID instance_id)
	{
		return ConvertToManaged(SDL_GetSensorNameForIDPtr(instance_id));
	}

	/// <summary>
	/// Get the type of a sensor.<br/>
	/// This can be called before any sensors are opened.<br/>
	/// <br/>
	/// @param instance_id the sensor instance ID.<br/>
	/// @returns the SDL_SensorType, or `SDL_SENSOR_INVALID` if `instance_id` is<br/>
	/// not valid.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensorTypeForID")]
	public static partial SDL_SensorType SDL_GetSensorTypeForID(SDL_SensorID instance_id);

	/// <summary>
	/// Get the platform dependent type of a sensor.<br/>
	/// This can be called before any sensors are opened.<br/>
	/// <br/>
	/// @param instance_id the sensor instance ID.<br/>
	/// @returns the sensor platform dependent type, or -1 if `instance_id` is not<br/>
	/// valid.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensorNonPortableTypeForID")]
	public static partial int SDL_GetSensorNonPortableTypeForID(SDL_SensorID instance_id);

	/// <summary>
	/// Open a sensor for use.<br/>
	/// <br/>
	/// @param instance_id the sensor instance ID.<br/>
	/// @returns an SDL_Sensor object or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenSensor")]
	public static partial SDL_Sensor SDL_OpenSensor(SDL_SensorID instance_id);

	/// <summary>
	/// Return the SDL_Sensor associated with an instance ID.<br/>
	/// <br/>
	/// @param instance_id the sensor instance ID.<br/>
	/// @returns an SDL_Sensor object or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensorFromID")]
	public static partial SDL_Sensor SDL_GetSensorFromID(SDL_SensorID instance_id);

	/// <summary>
	/// Get the properties associated with a sensor.<br/>
	/// <br/>
	/// @param sensor the SDL_Sensor object.<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensorProperties")]
	public static partial SDL_PropertiesID SDL_GetSensorProperties(SDL_Sensor sensor);

	/// <summary>
	/// Get the implementation dependent name of a sensor.<br/>
	/// <br/>
	/// @param sensor the SDL_Sensor object.<br/>
	/// @returns the sensor name or NULL on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensorName")]
	public static partial byte* SDL_GetSensorNamePtr(SDL_Sensor sensor);

	public static string? SDL_GetSensorName(SDL_Sensor sensor)
	{
		return ConvertToManaged(SDL_GetSensorNamePtr(sensor));
	}

	/// <summary>
	/// Get the type of a sensor.<br/>
	/// <br/>
	/// @param sensor the SDL_Sensor object to inspect.<br/>
	/// @returns the SDL_SensorType type, or `SDL_SENSOR_INVALID` if `sensor` is<br/>
	/// NULL.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensorType")]
	public static partial SDL_SensorType SDL_GetSensorType(SDL_Sensor sensor);

	/// <summary>
	/// Get the platform dependent type of a sensor.<br/>
	/// <br/>
	/// @param sensor the SDL_Sensor object to inspect.<br/>
	/// @returns the sensor platform dependent type, or -1 if `sensor` is NULL.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensorNonPortableType")]
	public static partial int SDL_GetSensorNonPortableType(SDL_Sensor sensor);

	/// <summary>
	/// Get the instance ID of a sensor.<br/>
	/// <br/>
	/// @param sensor the SDL_Sensor object to inspect.<br/>
	/// @returns the sensor instance ID, or 0 on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensorID")]
	public static partial SDL_SensorID SDL_GetSensorID(SDL_Sensor sensor);

	/// <summary>
	/// Get the current state of an opened sensor.<br/>
	/// The number of values and interpretation of the data is sensor dependent.<br/>
	/// <br/>
	/// @param sensor the SDL_Sensor object to query.<br/>
	/// @param data a pointer filled with the current sensor state.<br/>
	/// @param num_values the number of values to write to data.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSensorData")]
	public static partial SDLBool SDL_GetSensorData(SDL_Sensor sensor, float* data, int num_values);

	/// <summary>
	/// Close a sensor previously opened with SDL_OpenSensor().<br/>
	/// <br/>
	/// @param sensor the SDL_Sensor object to close.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CloseSensor")]
	public static partial void SDL_CloseSensor(SDL_Sensor sensor);

	/// <summary>
	/// Update the current state of the open sensors.<br/>
	/// This is called automatically by the event loop if sensor events are<br/>
	/// enabled.<br/>
	/// This needs to be called from the thread that initialized the sensor<br/>
	/// subsystem.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UpdateSensors")]
	public static partial void SDL_UpdateSensors();

	/// <summary>
	/// Allocate uninitialized memory.<br/>
	/// The allocated memory returned by this function must be freed with<br/>
	/// SDL_free().<br/>
	/// If `size` is 0, it will be set to 1.<br/>
	/// If you want to allocate memory aligned to a specific alignment, consider<br/>
	/// using SDL_aligned_alloc().<br/>
	/// <br/>
	/// @param size the size to allocate.<br/>
	/// @returns a pointer to the allocated memory, or NULL if allocation failed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_free<br/>
	/// @sa SDL_calloc<br/>
	/// @sa SDL_realloc<br/>
	/// @sa SDL_aligned_alloc
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_malloc")]
	public static partial nint SDL_malloc(nuint size);

	/// <summary>
	/// Allocate a zero-initialized array.<br/>
	/// The memory returned by this function must be freed with SDL_free().<br/>
	/// If either of `nmemb` or `size` is 0, they will both be set to 1.<br/>
	/// <br/>
	/// @param nmemb the number of elements in the array.<br/>
	/// @param size the size of each element of the array.<br/>
	/// @returns a pointer to the allocated array, or NULL if allocation failed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_free<br/>
	/// @sa SDL_malloc<br/>
	/// @sa SDL_realloc
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_calloc")]
	public static partial nint SDL_calloc(nuint nmemb, nuint size);

	/// <summary>
	/// Change the size of allocated memory.<br/>
	/// The memory returned by this function must be freed with SDL_free().<br/>
	/// If `size` is 0, it will be set to 1. Note that this is unlike some other C<br/>
	/// runtime `realloc` implementations, which may treat `realloc(mem, 0)` the<br/>
	/// same way as `free(mem)`.<br/>
	/// If `mem` is NULL, the behavior of this function is equivalent to<br/>
	/// SDL_malloc(). Otherwise, the function can have one of three possible<br/>
	/// outcomes:<br/>
	/// - If it returns the same pointer as `mem`, it means that `mem` was resized<br/>
	/// in place without freeing.<br/>
	/// - If it returns a different non-NULL pointer, it means that `mem` was freed<br/>
	/// and cannot be dereferenced anymore.<br/>
	/// - If it returns NULL (indicating failure), then `mem` will remain valid and<br/>
	/// must still be freed with SDL_free().<br/>
	/// <br/>
	/// @param mem a pointer to allocated memory to reallocate, or NULL.<br/>
	/// @param size the new size of the memory.<br/>
	/// @returns a pointer to the newly allocated memory, or NULL if allocation<br/>
	/// failed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_free<br/>
	/// @sa SDL_malloc<br/>
	/// @sa SDL_calloc
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_realloc")]
	public static partial nint SDL_realloc(nint mem, nuint size);

	/// <summary>
	/// Free allocated memory.<br/>
	/// The pointer is no longer valid after this call and cannot be dereferenced<br/>
	/// anymore.<br/>
	/// If `mem` is NULL, this function does nothing.<br/>
	/// <br/>
	/// @param mem a pointer to allocated memory, or NULL.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_malloc<br/>
	/// @sa SDL_calloc<br/>
	/// @sa SDL_realloc
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_free")]
	public static partial void SDL_free(nint mem);

	/// <summary>
	/// Get the original set of SDL memory functions.<br/>
	/// This is what SDL_malloc and friends will use by default, if there has been<br/>
	/// no call to SDL_SetMemoryFunctions. This is not necessarily using the C<br/>
	/// runtime's `malloc` functions behind the scenes! Different platforms and<br/>
	/// build configurations might do any number of unexpected things.<br/>
	/// <br/>
	/// @param malloc_func filled with malloc function.<br/>
	/// @param calloc_func filled with calloc function.<br/>
	/// @param realloc_func filled with realloc function.<br/>
	/// @param free_func filled with free function.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetOriginalMemoryFunctions")]
	public static partial void SDL_GetOriginalMemoryFunctions(delegate* unmanaged[Cdecl]<nuint, nint> malloc_func, delegate* unmanaged[Cdecl]<nuint, nuint, nint> calloc_func, delegate* unmanaged[Cdecl]<nint, nuint, nint> realloc_func, delegate* unmanaged[Cdecl]<nint, void> free_func);

	/// <summary>
	/// Get the current set of SDL memory functions.<br/>
	/// <br/>
	/// @param malloc_func filled with malloc function.<br/>
	/// @param calloc_func filled with calloc function.<br/>
	/// @param realloc_func filled with realloc function.<br/>
	/// @param free_func filled with free function.<br/>
	/// @threadsafety This does not hold a lock, so do not call this in the<br/>
	/// unlikely event of a background thread calling<br/>
	/// SDL_SetMemoryFunctions simultaneously.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetMemoryFunctions<br/>
	/// @sa SDL_GetOriginalMemoryFunctions
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetMemoryFunctions")]
	public static partial void SDL_GetMemoryFunctions(delegate* unmanaged[Cdecl]<nuint, nint> malloc_func, delegate* unmanaged[Cdecl]<nuint, nuint, nint> calloc_func, delegate* unmanaged[Cdecl]<nint, nuint, nint> realloc_func, delegate* unmanaged[Cdecl]<nint, void> free_func);

	/// <summary>
	/// Replace SDL's memory allocation functions with a custom set.<br/>
	/// It is not safe to call this function once any allocations have been made,<br/>
	/// as future calls to SDL_free will use the new allocator, even if they came<br/>
	/// from an SDL_malloc made with the old one!<br/>
	/// If used, usually this needs to be the first call made into the SDL library,<br/>
	/// if not the very first thing done at program startup time.<br/>
	/// <br/>
	/// @param malloc_func custom malloc function.<br/>
	/// @param calloc_func custom calloc function.<br/>
	/// @param realloc_func custom realloc function.<br/>
	/// @param free_func custom free function.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread, but one<br/>
	/// should not replace the memory functions once any allocations<br/>
	/// are made!<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetMemoryFunctions<br/>
	/// @sa SDL_GetOriginalMemoryFunctions
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetMemoryFunctions")]
	public static partial SDLBool SDL_SetMemoryFunctions(delegate* unmanaged[Cdecl]<nuint, nint> malloc_func, delegate* unmanaged[Cdecl]<nuint, nuint, nint> calloc_func, delegate* unmanaged[Cdecl]<nint, nuint, nint> realloc_func, delegate* unmanaged[Cdecl]<nint, void> free_func);

	/// <summary>
	/// Allocate memory aligned to a specific alignment.<br/>
	/// The memory returned by this function must be freed with SDL_aligned_free(),<br/>
	/// _not_ SDL_free().<br/>
	/// If `alignment` is less than the size of `void *`, it will be increased to<br/>
	/// match that.<br/>
	/// The returned memory address will be a multiple of the alignment value, and<br/>
	/// the size of the memory allocated will be a multiple of the alignment value.<br/>
	/// <br/>
	/// @param alignment the alignment of the memory.<br/>
	/// @param size the size to allocate.<br/>
	/// @returns a pointer to the aligned memory, or NULL if allocation failed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_aligned_free
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_aligned_alloc")]
	public static partial nint SDL_aligned_alloc(nuint alignment, nuint size);

	/// <summary>
	/// Free memory allocated by SDL_aligned_alloc().<br/>
	/// The pointer is no longer valid after this call and cannot be dereferenced<br/>
	/// anymore.<br/>
	/// If `mem` is NULL, this function does nothing.<br/>
	/// <br/>
	/// @param mem a pointer previously returned by SDL_aligned_alloc(), or NULL.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_aligned_alloc
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_aligned_free")]
	public static partial void SDL_aligned_free(nint mem);

	/// <summary>
	/// Get the number of outstanding (unfreed) allocations.<br/>
	/// <br/>
	/// @returns the number of allocations.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumAllocations")]
	public static partial int SDL_GetNumAllocations();

	/// <summary>
	/// Get the process environment.<br/>
	/// This is initialized at application start and is not affected by setenv()<br/>
	/// and unsetenv() calls after that point. Use SDL_SetEnvironmentVariable() and<br/>
	/// SDL_UnsetEnvironmentVariable() if you want to modify this environment, or<br/>
	/// SDL_setenv_unsafe() or SDL_unsetenv_unsafe() if you want changes to persist<br/>
	/// in the C runtime environment after SDL_Quit().<br/>
	/// <br/>
	/// @returns a pointer to the environment for the process or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetEnvironmentVariable<br/>
	/// @sa SDL_GetEnvironmentVariables<br/>
	/// @sa SDL_SetEnvironmentVariable<br/>
	/// @sa SDL_UnsetEnvironmentVariable
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetEnvironment")]
	public static partial SDL_Environment SDL_GetEnvironment();

	/// <summary>
	/// Create a set of environment variables<br/>
	/// <br/>
	/// @param populated true to initialize it from the C runtime environment,<br/>
	/// false to create an empty environment.<br/>
	/// @returns a pointer to the new environment or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety If `populated` is false, it is safe to call this function<br/>
	/// from any thread, otherwise it is safe if no other threads are<br/>
	/// calling setenv() or unsetenv()<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetEnvironmentVariable<br/>
	/// @sa SDL_GetEnvironmentVariables<br/>
	/// @sa SDL_SetEnvironmentVariable<br/>
	/// @sa SDL_UnsetEnvironmentVariable<br/>
	/// @sa SDL_DestroyEnvironment
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateEnvironment")]
	public static partial SDL_Environment SDL_CreateEnvironment(SDLBool populated);

	/// <summary>
	/// Get the value of a variable in the environment.<br/>
	/// <br/>
	/// @param env the environment to query.<br/>
	/// @param name the name of the variable to get.<br/>
	/// @returns a pointer to the value of the variable or NULL if it can't be<br/>
	/// found.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetEnvironment<br/>
	/// @sa SDL_CreateEnvironment<br/>
	/// @sa SDL_GetEnvironmentVariables<br/>
	/// @sa SDL_SetEnvironmentVariable<br/>
	/// @sa SDL_UnsetEnvironmentVariable
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetEnvironmentVariable")]
	public static partial byte* SDL_GetEnvironmentVariablePtr(SDL_Environment env, byte* name);

	public static string? SDL_GetEnvironmentVariable(SDL_Environment env, byte* name)
	{
		return ConvertToManaged(SDL_GetEnvironmentVariablePtr(env, name));
	}

	[LibraryImport(LibName, EntryPoint = "SDL_GetEnvironmentVariable")]
	public static partial byte* SDL_GetEnvironmentVariablePtr(SDL_Environment env, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_GetEnvironmentVariable")]
	public static partial byte* SDL_GetEnvironmentVariablePtr(SDL_Environment env, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Get all variables in the environment.<br/>
	/// <br/>
	/// @param env the environment to query.<br/>
	/// @returns a NULL terminated array of pointers to environment variables in<br/>
	/// the form "variable=value" or NULL on failure; call SDL_GetError()<br/>
	/// for more information. This is a single allocation that should be<br/>
	/// freed with SDL_free() when it is no longer needed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetEnvironment<br/>
	/// @sa SDL_CreateEnvironment<br/>
	/// @sa SDL_GetEnvironmentVariables<br/>
	/// @sa SDL_SetEnvironmentVariable<br/>
	/// @sa SDL_UnsetEnvironmentVariable
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetEnvironmentVariables")]
	public static partial byte** SDL_GetEnvironmentVariables(SDL_Environment env);

	/// <summary>
	/// Set the value of a variable in the environment.<br/>
	/// <br/>
	/// @param env the environment to modify.<br/>
	/// @param name the name of the variable to set.<br/>
	/// @param value the value of the variable to set.<br/>
	/// @param overwrite true to overwrite the variable if it exists, false to<br/>
	/// return success without setting the variable if it already<br/>
	/// exists.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetEnvironment<br/>
	/// @sa SDL_CreateEnvironment<br/>
	/// @sa SDL_GetEnvironmentVariable<br/>
	/// @sa SDL_GetEnvironmentVariables<br/>
	/// @sa SDL_UnsetEnvironmentVariable
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetEnvironmentVariable")]
	public static partial SDLBool SDL_SetEnvironmentVariable(SDL_Environment env, byte* name, byte* value, SDLBool overwrite);

	[LibraryImport(LibName, EntryPoint = "SDL_SetEnvironmentVariable")]
	public static partial SDLBool SDL_SetEnvironmentVariable(SDL_Environment env, ReadOnlySpan<byte> name, ReadOnlySpan<byte> value, SDLBool overwrite);

	[LibraryImport(LibName, EntryPoint = "SDL_SetEnvironmentVariable")]
	public static partial SDLBool SDL_SetEnvironmentVariable(SDL_Environment env, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value, SDLBool overwrite);

	/// <summary>
	/// Clear a variable from the environment.<br/>
	/// <br/>
	/// @param env the environment to modify.<br/>
	/// @param name the name of the variable to unset.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetEnvironment<br/>
	/// @sa SDL_CreateEnvironment<br/>
	/// @sa SDL_GetEnvironmentVariable<br/>
	/// @sa SDL_GetEnvironmentVariables<br/>
	/// @sa SDL_SetEnvironmentVariable<br/>
	/// @sa SDL_UnsetEnvironmentVariable
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnsetEnvironmentVariable")]
	public static partial SDLBool SDL_UnsetEnvironmentVariable(SDL_Environment env, byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_UnsetEnvironmentVariable")]
	public static partial SDLBool SDL_UnsetEnvironmentVariable(SDL_Environment env, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_UnsetEnvironmentVariable")]
	public static partial SDLBool SDL_UnsetEnvironmentVariable(SDL_Environment env, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Destroy a set of environment variables.<br/>
	/// <br/>
	/// @param env the environment to destroy.<br/>
	/// @threadsafety It is safe to call this function from any thread, as long as<br/>
	/// the environment is no longer in use.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateEnvironment
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyEnvironment")]
	public static partial void SDL_DestroyEnvironment(SDL_Environment env);

	/// <summary>
	/// Get the value of a variable in the environment.<br/>
	/// This function uses SDL's cached copy of the environment and is thread-safe.<br/>
	/// <br/>
	/// @param name the name of the variable to get.<br/>
	/// @returns a pointer to the value of the variable or NULL if it can't be<br/>
	/// found.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_getenv")]
	public static partial byte* SDL_getenvPtr(byte* name);

	public static string? SDL_getenv(byte* name)
	{
		return ConvertToManaged(SDL_getenvPtr(name));
	}

	[LibraryImport(LibName, EntryPoint = "SDL_getenv")]
	public static partial byte* SDL_getenvPtr(ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_getenv")]
	public static partial byte* SDL_getenvPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Get the value of a variable in the environment.<br/>
	/// This function bypasses SDL's cached copy of the environment and is not<br/>
	/// thread-safe.<br/>
	/// <br/>
	/// @param name the name of the variable to get.<br/>
	/// @returns a pointer to the value of the variable or NULL if it can't be<br/>
	/// found.<br/>
	/// @threadsafety This function is not thread safe, consider using SDL_getenv()<br/>
	/// instead.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_getenv
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_getenv_unsafe")]
	public static partial byte* SDL_getenv_unsafePtr(byte* name);

	public static string? SDL_getenv_unsafe(byte* name)
	{
		return ConvertToManaged(SDL_getenv_unsafePtr(name));
	}

	[LibraryImport(LibName, EntryPoint = "SDL_getenv_unsafe")]
	public static partial byte* SDL_getenv_unsafePtr(ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_getenv_unsafe")]
	public static partial byte* SDL_getenv_unsafePtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Set the value of a variable in the environment.<br/>
	/// <br/>
	/// @param name the name of the variable to set.<br/>
	/// @param value the value of the variable to set.<br/>
	/// @param overwrite 1 to overwrite the variable if it exists, 0 to return<br/>
	/// success without setting the variable if it already exists.<br/>
	/// @returns 0 on success, -1 on error.<br/>
	/// @threadsafety This function is not thread safe, consider using<br/>
	/// SDL_SetEnvironmentVariable() instead.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetEnvironmentVariable
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_setenv_unsafe")]
	public static partial int SDL_setenv_unsafe(byte* name, byte* value, int overwrite);

	[LibraryImport(LibName, EntryPoint = "SDL_setenv_unsafe")]
	public static partial int SDL_setenv_unsafe(ReadOnlySpan<byte> name, ReadOnlySpan<byte> value, int overwrite);

	[LibraryImport(LibName, EntryPoint = "SDL_setenv_unsafe")]
	public static partial int SDL_setenv_unsafe([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> value, int overwrite);

	/// <summary>
	/// Clear a variable from the environment.<br/>
	/// <br/>
	/// @param name the name of the variable to unset.<br/>
	/// @returns 0 on success, -1 on error.<br/>
	/// @threadsafety This function is not thread safe, consider using<br/>
	/// SDL_UnsetEnvironmentVariable() instead.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_UnsetEnvironmentVariable
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_unsetenv_unsafe")]
	public static partial int SDL_unsetenv_unsafe(byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_unsetenv_unsafe")]
	public static partial int SDL_unsetenv_unsafe(ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_unsetenv_unsafe")]
	public static partial int SDL_unsetenv_unsafe([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Sort an array.<br/>
	/// For example:<br/>
	/// ```c<br/>
	/// typedef struct {<br/>
	/// int key;<br/>
	/// const char *string;<br/>
	/// } data;<br/>
	/// int SDLCALL compare(const void *a, const void *b)<br/>
	/// {<br/>
	/// const data *A = (const data *)a;<br/>
	/// const data *B = (const data *)b;<br/>
	/// if (A->n<br/>
	/// <<br/>
	/// B->n) {<br/>
	/// return -1;<br/>
	/// } else if (B->n<br/>
	/// <<br/>
	/// A->n) {<br/>
	/// return 1;<br/>
	/// } else {<br/>
	/// return 0;<br/>
	/// }<br/>
	/// }<br/>
	/// data values[] = {<br/>
	/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
	/// };<br/>
	/// SDL_qsort(values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
	/// ```<br/>
	/// <br/>
	/// @param base a pointer to the start of the array.<br/>
	/// @param nmemb the number of elements in the array.<br/>
	/// @param size the size of the elements in the array.<br/>
	/// @param compare a function used to compare elements in the array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_bsearch<br/>
	/// @sa SDL_qsort_r
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_qsort")]
	public static partial void SDL_qsort(nint @base, nuint nmemb, nuint size, delegate* unmanaged[Cdecl]<nint, nint, int> compare);

	/// <summary>
	/// Perform a binary search on a previously sorted array.<br/>
	/// For example:<br/>
	/// ```c<br/>
	/// typedef struct {<br/>
	/// int key;<br/>
	/// const char *string;<br/>
	/// } data;<br/>
	/// int SDLCALL compare(const void *a, const void *b)<br/>
	/// {<br/>
	/// const data *A = (const data *)a;<br/>
	/// const data *B = (const data *)b;<br/>
	/// if (A->n<br/>
	/// <<br/>
	/// B->n) {<br/>
	/// return -1;<br/>
	/// } else if (B->n<br/>
	/// <<br/>
	/// A->n) {<br/>
	/// return 1;<br/>
	/// } else {<br/>
	/// return 0;<br/>
	/// }<br/>
	/// }<br/>
	/// data values[] = {<br/>
	/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
	/// };<br/>
	/// data key = { 2, NULL };<br/>
	/// data *result = SDL_bsearch(<br/>
	/// &key<br/>
	/// , values, SDL_arraysize(values), sizeof(values[0]), compare);<br/>
	/// ```<br/>
	/// <br/>
	/// @param key a pointer to a key equal to the element being searched for.<br/>
	/// @param base a pointer to the start of the array.<br/>
	/// @param nmemb the number of elements in the array.<br/>
	/// @param size the size of the elements in the array.<br/>
	/// @param compare a function used to compare elements in the array.<br/>
	/// @returns a pointer to the matching element in the array, or NULL if not<br/>
	/// found.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_bsearch_r<br/>
	/// @sa SDL_qsort
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_bsearch")]
	public static partial nint SDL_bsearch(nint key, nint @base, nuint nmemb, nuint size, delegate* unmanaged[Cdecl]<nint, nint, int> compare);

	/// <summary>
	/// Sort an array, passing a userdata pointer to the compare function.<br/>
	/// For example:<br/>
	/// ```c<br/>
	/// typedef enum {<br/>
	/// sort_increasing,<br/>
	/// sort_decreasing,<br/>
	/// } sort_method;<br/>
	/// typedef struct {<br/>
	/// int key;<br/>
	/// const char *string;<br/>
	/// } data;<br/>
	/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
	/// {<br/>
	/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
	/// const data *A = (const data *)a;<br/>
	/// const data *B = (const data *)b;<br/>
	/// if (A->n<br/>
	/// <<br/>
	/// B->n) {<br/>
	/// return (method == sort_increasing) ? -1 : 1;<br/>
	/// } else if (B->n<br/>
	/// <<br/>
	/// A->n) {<br/>
	/// return (method == sort_increasing) ? 1 : -1;<br/>
	/// } else {<br/>
	/// return 0;<br/>
	/// }<br/>
	/// }<br/>
	/// data values[] = {<br/>
	/// { 3, "third" }, { 1, "first" }, { 2, "second" }<br/>
	/// };<br/>
	/// SDL_qsort_r(values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
	/// ```<br/>
	/// <br/>
	/// @param base a pointer to the start of the array.<br/>
	/// @param nmemb the number of elements in the array.<br/>
	/// @param size the size of the elements in the array.<br/>
	/// @param compare a function used to compare elements in the array.<br/>
	/// @param userdata a pointer to pass to the compare function.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_bsearch_r<br/>
	/// @sa SDL_qsort
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_qsort_r")]
	public static partial void SDL_qsort_r(nint @base, nuint nmemb, nuint size, delegate* unmanaged[Cdecl]<nint, nint, nint, int> compare, nint userdata);

	/// <summary>
	/// Perform a binary search on a previously sorted array, passing a userdata<br/>
	/// pointer to the compare function.<br/>
	/// For example:<br/>
	/// ```c<br/>
	/// typedef enum {<br/>
	/// sort_increasing,<br/>
	/// sort_decreasing,<br/>
	/// } sort_method;<br/>
	/// typedef struct {<br/>
	/// int key;<br/>
	/// const char *string;<br/>
	/// } data;<br/>
	/// int SDLCALL compare(const void *userdata, const void *a, const void *b)<br/>
	/// {<br/>
	/// sort_method method = (sort_method)(uintptr_t)userdata;<br/>
	/// const data *A = (const data *)a;<br/>
	/// const data *B = (const data *)b;<br/>
	/// if (A->n<br/>
	/// <<br/>
	/// B->n) {<br/>
	/// return (method == sort_increasing) ? -1 : 1;<br/>
	/// } else if (B->n<br/>
	/// <<br/>
	/// A->n) {<br/>
	/// return (method == sort_increasing) ? 1 : -1;<br/>
	/// } else {<br/>
	/// return 0;<br/>
	/// }<br/>
	/// }<br/>
	/// data values[] = {<br/>
	/// { 1, "first" }, { 2, "second" }, { 3, "third" }<br/>
	/// };<br/>
	/// data key = { 2, NULL };<br/>
	/// data *result = SDL_bsearch_r(<br/>
	/// &key<br/>
	/// , values, SDL_arraysize(values), sizeof(values[0]), compare, (const void *)(uintptr_t)sort_increasing);<br/>
	/// ```<br/>
	/// <br/>
	/// @param key a pointer to a key equal to the element being searched for.<br/>
	/// @param base a pointer to the start of the array.<br/>
	/// @param nmemb the number of elements in the array.<br/>
	/// @param size the size of the elements in the array.<br/>
	/// @param compare a function used to compare elements in the array.<br/>
	/// @param userdata a pointer to pass to the compare function.<br/>
	/// @returns a pointer to the matching element in the array, or NULL if not<br/>
	/// found.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_bsearch<br/>
	/// @sa SDL_qsort_r
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_bsearch_r")]
	public static partial nint SDL_bsearch_r(nint key, nint @base, nuint nmemb, nuint size, delegate* unmanaged[Cdecl]<nint, nint, nint, int> compare, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_abs")]
	public static partial int SDL_abs(int x);

	/// <summary>
	/// Query if a character is alphabetic (a letter).<br/>
	/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
	/// for English 'a-z' and 'A-Z' as true.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isalpha")]
	public static partial int SDL_isalpha(int x);

	/// <summary>
	/// Query if a character is alphabetic (a letter) or a number.<br/>
	/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
	/// for English 'a-z', 'A-Z', and '0-9' as true.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isalnum")]
	public static partial int SDL_isalnum(int x);

	/// <summary>
	/// Report if a character is blank (a space or tab).<br/>
	/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
	/// 0x20 (space) or 0x9 (tab) as true.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isblank")]
	public static partial int SDL_isblank(int x);

	/// <summary>
	/// Report if a character is a control character.<br/>
	/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
	/// 0 through 0x1F, and 0x7F, as true.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_iscntrl")]
	public static partial int SDL_iscntrl(int x);

	/// <summary>
	/// Report if a character is a numeric digit.<br/>
	/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
	/// '0' (0x30) through '9' (0x39), as true.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isdigit")]
	public static partial int SDL_isdigit(int x);

	/// <summary>
	/// Report if a character is a hexadecimal digit.<br/>
	/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
	/// 'A' through 'F', 'a' through 'f', and '0' through '9', as true.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isxdigit")]
	public static partial int SDL_isxdigit(int x);

	/// <summary>
	/// Report if a character is a punctuation mark.<br/>
	/// **WARNING**: Regardless of system locale, this is equivalent to<br/>
	/// `((SDL_isgraph(x))<br/>
	/// &<br/>
	/// &<br/>
	/// (!SDL_isalnum(x)))`.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_isgraph<br/>
	/// @sa SDL_isalnum
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ispunct")]
	public static partial int SDL_ispunct(int x);

	/// <summary>
	/// Report if a character is whitespace.<br/>
	/// **WARNING**: Regardless of system locale, this will only treat the<br/>
	/// following ASCII values as true:<br/>
	/// - space (0x20)<br/>
	/// - tab (0x09)<br/>
	/// - newline (0x0A)<br/>
	/// - vertical tab (0x0B)<br/>
	/// - form feed (0x0C)<br/>
	/// - return (0x0D)<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isspace")]
	public static partial int SDL_isspace(int x);

	/// <summary>
	/// Report if a character is upper case.<br/>
	/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
	/// 'A' through 'Z' as true.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isupper")]
	public static partial int SDL_isupper(int x);

	/// <summary>
	/// Report if a character is lower case.<br/>
	/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
	/// 'a' through 'z' as true.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_islower")]
	public static partial int SDL_islower(int x);

	/// <summary>
	/// Report if a character is "printable".<br/>
	/// Be advised that "printable" has a definition that goes back to text<br/>
	/// terminals from the dawn of computing, making this a sort of special case<br/>
	/// function that is not suitable for Unicode (or most any) text management.<br/>
	/// **WARNING**: Regardless of system locale, this will only treat ASCII values<br/>
	/// ' ' (0x20) through '~' (0x7E) as true.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isprint")]
	public static partial int SDL_isprint(int x);

	/// <summary>
	/// Report if a character is any "printable" except space.<br/>
	/// Be advised that "printable" has a definition that goes back to text<br/>
	/// terminals from the dawn of computing, making this a sort of special case<br/>
	/// function that is not suitable for Unicode (or most any) text management.<br/>
	/// **WARNING**: Regardless of system locale, this is equivalent to<br/>
	/// `(SDL_isprint(x))<br/>
	/// &<br/>
	/// &<br/>
	/// ((x) != ' ')`.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns non-zero if x falls within the character class, zero otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_isprint
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isgraph")]
	public static partial int SDL_isgraph(int x);

	/// <summary>
	/// Convert low-ASCII English letters to uppercase.<br/>
	/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
	/// values 'a' through 'z' to uppercase.<br/>
	/// This function returns the uppercase equivalent of `x`. If a character<br/>
	/// cannot be converted, or is already uppercase, this function returns `x`.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns capitalized version of x, or x if no conversion available.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_toupper")]
	public static partial int SDL_toupper(int x);

	/// <summary>
	/// Convert low-ASCII English letters to lowercase.<br/>
	/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
	/// values 'A' through 'Z' to lowercase.<br/>
	/// This function returns the lowercase equivalent of `x`. If a character<br/>
	/// cannot be converted, or is already lowercase, this function returns `x`.<br/>
	/// <br/>
	/// @param x character value to check.<br/>
	/// @returns lowercase version of x, or x if no conversion available.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_tolower")]
	public static partial int SDL_tolower(int x);

	[LibraryImport(LibName, EntryPoint = "SDL_crc16")]
	public static partial ushort SDL_crc16(ushort crc, nint data, nuint len);

	[LibraryImport(LibName, EntryPoint = "SDL_crc32")]
	public static partial uint SDL_crc32(uint crc, nint data, nuint len);

	[LibraryImport(LibName, EntryPoint = "SDL_murmur3_32")]
	public static partial uint SDL_murmur3_32(nint data, nuint len, uint seed);

	/// <summary>
	/// Copy non-overlapping memory.<br/>
	/// The memory regions must not overlap. If they do, use SDL_memmove() instead.<br/>
	/// <br/>
	/// @param dst The destination memory region. Must not be NULL, and must not<br/>
	/// overlap with `src`.<br/>
	/// @param src The source memory region. Must not be NULL, and must not overlap<br/>
	/// with `dst`.<br/>
	/// @param len The length in bytes of both `dst` and `src`.<br/>
	/// @returns `dst`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_memmove
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_memcpy")]
	public static partial nint SDL_memcpy(nint dst, nint src, nuint len);

	/// <summary>
	/// Copy memory.<br/>
	/// It is okay for the memory regions to overlap. If you are confident that the<br/>
	/// regions never overlap, using SDL_memcpy() may improve performance.<br/>
	/// <br/>
	/// @param dst The destination memory region. Must not be NULL.<br/>
	/// @param src The source memory region. Must not be NULL.<br/>
	/// @param len The length in bytes of both `dst` and `src`.<br/>
	/// @returns `dst`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_memcpy
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_memmove")]
	public static partial nint SDL_memmove(nint dst, nint src, nuint len);

	[LibraryImport(LibName, EntryPoint = "SDL_memset")]
	public static partial nint SDL_memset(nint dst, int c, nuint len);

	[LibraryImport(LibName, EntryPoint = "SDL_memset4")]
	public static partial nint SDL_memset4(nint dst, uint val, nuint dwords);

	[LibraryImport(LibName, EntryPoint = "SDL_memcmp")]
	public static partial int SDL_memcmp(nint s1, nint s2, nuint len);

	[LibraryImport(LibName, EntryPoint = "SDL_wcslen")]
	public static partial nuint SDL_wcslen(char* wstr);

	[LibraryImport(LibName, EntryPoint = "SDL_wcsnlen")]
	public static partial nuint SDL_wcsnlen(char* wstr, nuint maxlen);

	/// <summary>
	/// Copy a wide string.<br/>
	/// This function copies `maxlen` - 1 wide characters from `src` to `dst`, then<br/>
	/// appends a null terminator.<br/>
	/// `src` and `dst` must not overlap.<br/>
	/// If `maxlen` is 0, no wide characters are copied and no null terminator is<br/>
	/// written.<br/>
	/// <br/>
	/// @param dst The destination buffer. Must not be NULL, and must not overlap<br/>
	/// with `src`.<br/>
	/// @param src The null-terminated wide string to copy. Must not be NULL, and<br/>
	/// must not overlap with `dst`.<br/>
	/// @param maxlen The length (in wide characters) of the destination buffer.<br/>
	/// @returns The length (in wide characters, excluding the null terminator) of<br/>
	/// `src`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_wcslcat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_wcslcpy")]
	public static partial nuint SDL_wcslcpy(char* dst, char* src, nuint maxlen);

	/// <summary>
	/// Concatenate wide strings.<br/>
	/// This function appends up to `maxlen` - SDL_wcslen(dst) - 1 wide characters<br/>
	/// from `src` to the end of the wide string in `dst`, then appends a null<br/>
	/// terminator.<br/>
	/// `src` and `dst` must not overlap.<br/>
	/// If `maxlen` - SDL_wcslen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
	/// unmodified.<br/>
	/// <br/>
	/// @param dst The destination buffer already containing the first<br/>
	/// null-terminated wide string. Must not be NULL and must not<br/>
	/// overlap with `src`.<br/>
	/// @param src The second null-terminated wide string. Must not be NULL, and<br/>
	/// must not overlap with `dst`.<br/>
	/// @param maxlen The length (in wide characters) of the destination buffer.<br/>
	/// @returns The length (in wide characters, excluding the null terminator) of<br/>
	/// the string in `dst` plus the length of `src`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_wcslcpy
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_wcslcat")]
	public static partial nuint SDL_wcslcat(char* dst, char* src, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_wcsdup")]
	public static partial char* SDL_wcsdup(char* wstr);

	[LibraryImport(LibName, EntryPoint = "SDL_wcsstr")]
	public static partial char* SDL_wcsstr(char* haystack, char* needle);

	[LibraryImport(LibName, EntryPoint = "SDL_wcsnstr")]
	public static partial char* SDL_wcsnstr(char* haystack, char* needle, nuint maxlen);

	/// <summary>
	/// Compare two null-terminated wide strings.<br/>
	/// This only compares wchar_t values until it hits a null-terminating<br/>
	/// character; it does not care if the string is well-formed UTF-16 (or UTF-32,<br/>
	/// depending on your platform's wchar_t size), or uses valid Unicode values.<br/>
	/// <br/>
	/// @param str1 the first string to compare. NULL is not permitted!<br/>
	/// @param str2 the second string to compare. NULL is not permitted!<br/>
	/// @returns less than zero if str1 is "less than" str2, greater than zero if<br/>
	/// str1 is "greater than" str2, and zero if the strings match<br/>
	/// exactly.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_wcscmp")]
	public static partial int SDL_wcscmp(char* str1, char* str2);

	/// <summary>
	/// Compare two wide strings up to a number of wchar_t values.<br/>
	/// This only compares wchar_t values; it does not care if the string is<br/>
	/// well-formed UTF-16 (or UTF-32, depending on your platform's wchar_t size),<br/>
	/// or uses valid Unicode values.<br/>
	/// Note that while this function is intended to be used with UTF-16 (or<br/>
	/// UTF-32, depending on your platform's definition of wchar_t), it is<br/>
	/// comparing raw wchar_t values and not Unicode codepoints: `maxlen` specifies<br/>
	/// a wchar_t limit! If the limit lands in the middle of a multi-wchar UTF-16<br/>
	/// sequence, it will only compare a portion of the final character.<br/>
	/// `maxlen` specifies a maximum number of wchar_t to compare; if the strings<br/>
	/// match to this number of wide chars (or both have matched to a<br/>
	/// null-terminator character before this count), they will be considered<br/>
	/// equal.<br/>
	/// <br/>
	/// @param str1 the first string to compare. NULL is not permitted!<br/>
	/// @param str2 the second string to compare. NULL is not permitted!<br/>
	/// @param maxlen the maximum number of wchar_t to compare.<br/>
	/// @returns less than zero if str1 is "less than" str2, greater than zero if<br/>
	/// str1 is "greater than" str2, and zero if the strings match<br/>
	/// exactly.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_wcsncmp")]
	public static partial int SDL_wcsncmp(char* str1, char* str2, nuint maxlen);

	/// <summary>
	/// Compare two null-terminated wide strings, case-insensitively.<br/>
	/// This will work with Unicode strings, using a technique called<br/>
	/// "case-folding" to handle the vast majority of case-sensitive human<br/>
	/// languages regardless of system locale. It can deal with expanding values: a<br/>
	/// German Eszett character can compare against two ASCII 's' chars and be<br/>
	/// considered a match, for example. A notable exception: it does not handle<br/>
	/// the Turkish 'i' character; human language is complicated!<br/>
	/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
	/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
	/// handles Unicode, it expects the string to be well-formed and not a<br/>
	/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
	/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
	/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
	/// match if they convert to the same amount of replacement characters.<br/>
	/// <br/>
	/// @param str1 the first string to compare. NULL is not permitted!<br/>
	/// @param str2 the second string to compare. NULL is not permitted!<br/>
	/// @returns less than zero if str1 is "less than" str2, greater than zero if<br/>
	/// str1 is "greater than" str2, and zero if the strings match<br/>
	/// exactly.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_wcscasecmp")]
	public static partial int SDL_wcscasecmp(char* str1, char* str2);

	/// <summary>
	/// Compare two wide strings, case-insensitively, up to a number of wchar_t.<br/>
	/// This will work with Unicode strings, using a technique called<br/>
	/// "case-folding" to handle the vast majority of case-sensitive human<br/>
	/// languages regardless of system locale. It can deal with expanding values: a<br/>
	/// German Eszett character can compare against two ASCII 's' chars and be<br/>
	/// considered a match, for example. A notable exception: it does not handle<br/>
	/// the Turkish 'i' character; human language is complicated!<br/>
	/// Depending on your platform, "wchar_t" might be 2 bytes, and expected to be<br/>
	/// UTF-16 encoded (like Windows), or 4 bytes in UTF-32 format. Since this<br/>
	/// handles Unicode, it expects the string to be well-formed and not a<br/>
	/// null-terminated string of arbitrary bytes. Characters that are not valid<br/>
	/// UTF-16 (or UTF-32) are treated as Unicode character U+FFFD (REPLACEMENT<br/>
	/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
	/// match if they convert to the same amount of replacement characters.<br/>
	/// Note that while this function might deal with variable-sized characters,<br/>
	/// `maxlen` specifies a _wchar_ limit! If the limit lands in the middle of a<br/>
	/// multi-byte UTF-16 sequence, it may convert a portion of the final character<br/>
	/// to one or more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not<br/>
	/// to overflow a buffer.<br/>
	/// `maxlen` specifies a maximum number of wchar_t values to compare; if the<br/>
	/// strings match to this number of wchar_t (or both have matched to a<br/>
	/// null-terminator character before this number of bytes), they will be<br/>
	/// considered equal.<br/>
	/// <br/>
	/// @param str1 the first string to compare. NULL is not permitted!<br/>
	/// @param str2 the second string to compare. NULL is not permitted!<br/>
	/// @param maxlen the maximum number of wchar_t values to compare.<br/>
	/// @returns less than zero if str1 is "less than" str2, greater than zero if<br/>
	/// str1 is "greater than" str2, and zero if the strings match<br/>
	/// exactly.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_wcsncasecmp")]
	public static partial int SDL_wcsncasecmp(char* str1, char* str2, nuint maxlen);

	/// <summary>
	/// Parse a `long` from a wide string.<br/>
	/// If `str` starts with whitespace, then those whitespace characters are<br/>
	/// skipped before attempting to parse the number.<br/>
	/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
	/// the minimum and maximum representable `long` values.<br/>
	/// <br/>
	/// @param str The null-terminated wide string to read. Must not be NULL.<br/>
	/// @param endp If not NULL, the address of the first invalid wide character<br/>
	/// (i.e. the next character after the parsed number) will be<br/>
	/// written to this pointer.<br/>
	/// @param base The base of the integer to read. Supported values are 0 and 2<br/>
	/// to 36 inclusive. If 0, the base will be inferred from the<br/>
	/// number's prefix (0x for hexadecimal, 0 for octal, decimal<br/>
	/// otherwise).<br/>
	/// @returns The parsed `long`, or 0 if no number could be parsed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_strtol
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_wcstol")]
	public static partial global::System.Runtime.InteropServices.CLong SDL_wcstol(char* str, char** endp, int @base);

	[LibraryImport(LibName, EntryPoint = "SDL_strlen")]
	public static partial nuint SDL_strlen(byte* str);

	[LibraryImport(LibName, EntryPoint = "SDL_strlen")]
	public static partial nuint SDL_strlen(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_strlen")]
	public static partial nuint SDL_strlen([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	[LibraryImport(LibName, EntryPoint = "SDL_strnlen")]
	public static partial nuint SDL_strnlen(byte* str, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strnlen")]
	public static partial nuint SDL_strnlen(ReadOnlySpan<byte> str, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strnlen")]
	public static partial nuint SDL_strnlen([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, nuint maxlen);

	/// <summary>
	/// Copy a string.<br/>
	/// This function copies up to `maxlen` - 1 characters from `src` to `dst`,<br/>
	/// then appends a null terminator.<br/>
	/// If `maxlen` is 0, no characters are copied and no null terminator is<br/>
	/// written.<br/>
	/// If you want to copy an UTF-8 string but need to ensure that multi-byte<br/>
	/// sequences are not truncated, consider using SDL_utf8strlcpy().<br/>
	/// <br/>
	/// @param dst The destination buffer. Must not be NULL, and must not overlap<br/>
	/// with `src`.<br/>
	/// @param src The null-terminated string to copy. Must not be NULL, and must<br/>
	/// not overlap with `dst`.<br/>
	/// @param maxlen The length (in characters) of the destination buffer.<br/>
	/// @returns The length (in characters, excluding the null terminator) of<br/>
	/// `src`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_strlcat<br/>
	/// @sa SDL_utf8strlcpy
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strlcpy")]
	public static partial nuint SDL_strlcpy(byte* dst, byte* src, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strlcpy")]
	public static partial nuint SDL_strlcpy(ReadOnlySpan<byte> dst, ReadOnlySpan<byte> src, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strlcpy")]
	public static partial nuint SDL_strlcpy([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> dst, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> src, nuint maxlen);

	/// <summary>
	/// Copy an UTF-8 string.<br/>
	/// This function copies up to `dst_bytes` - 1 bytes from `src` to `dst` while<br/>
	/// also ensuring that the string written to `dst` does not end in a truncated<br/>
	/// multi-byte sequence. Finally, it appends a null terminator.<br/>
	/// `src` and `dst` must not overlap.<br/>
	/// Note that unlike SDL_strlcpy(), this function returns the number of bytes<br/>
	/// written, not the length of `src`.<br/>
	/// <br/>
	/// @param dst The destination buffer. Must not be NULL, and must not overlap<br/>
	/// with `src`.<br/>
	/// @param src The null-terminated UTF-8 string to copy. Must not be NULL, and<br/>
	/// must not overlap with `dst`.<br/>
	/// @param dst_bytes The length (in bytes) of the destination buffer. Must not<br/>
	/// be 0.<br/>
	/// @returns The number of bytes written, excluding the null terminator.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_strlcpy
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_utf8strlcpy")]
	public static partial nuint SDL_utf8strlcpy(byte* dst, byte* src, nuint dst_bytes);

	[LibraryImport(LibName, EntryPoint = "SDL_utf8strlcpy")]
	public static partial nuint SDL_utf8strlcpy(ReadOnlySpan<byte> dst, ReadOnlySpan<byte> src, nuint dst_bytes);

	[LibraryImport(LibName, EntryPoint = "SDL_utf8strlcpy")]
	public static partial nuint SDL_utf8strlcpy([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> dst, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> src, nuint dst_bytes);

	/// <summary>
	/// Concatenate strings.<br/>
	/// This function appends up to `maxlen` - SDL_strlen(dst) - 1 characters from<br/>
	/// `src` to the end of the string in `dst`, then appends a null terminator.<br/>
	/// `src` and `dst` must not overlap.<br/>
	/// If `maxlen` - SDL_strlen(dst) - 1 is less than or equal to 0, then `dst` is<br/>
	/// unmodified.<br/>
	/// <br/>
	/// @param dst The destination buffer already containing the first<br/>
	/// null-terminated string. Must not be NULL and must not overlap<br/>
	/// with `src`.<br/>
	/// @param src The second null-terminated string. Must not be NULL, and must<br/>
	/// not overlap with `dst`.<br/>
	/// @param maxlen The length (in characters) of the destination buffer.<br/>
	/// @returns The length (in characters, excluding the null terminator) of the<br/>
	/// string in `dst` plus the length of `src`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_strlcpy
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strlcat")]
	public static partial nuint SDL_strlcat(byte* dst, byte* src, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strlcat")]
	public static partial nuint SDL_strlcat(ReadOnlySpan<byte> dst, ReadOnlySpan<byte> src, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strlcat")]
	public static partial nuint SDL_strlcat([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> dst, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> src, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strdup")]
	public static partial byte* SDL_strdupPtr(byte* str);

	public static string? SDL_strdup(byte* str)
	{
		byte* resultPtr = SDL_strdupPtr(str);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strdup")]
	public static partial byte* SDL_strdupPtr(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_strdup")]
	public static partial byte* SDL_strdupPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	[LibraryImport(LibName, EntryPoint = "SDL_strndup")]
	public static partial byte* SDL_strndupPtr(byte* str, nuint maxlen);

	public static string? SDL_strndup(byte* str, nuint maxlen)
	{
		byte* resultPtr = SDL_strndupPtr(str, maxlen);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strndup")]
	public static partial byte* SDL_strndupPtr(ReadOnlySpan<byte> str, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strndup")]
	public static partial byte* SDL_strndupPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strrev")]
	public static partial byte* SDL_strrevPtr(byte* str);

	public static string? SDL_strrev(byte* str)
	{
		byte* resultPtr = SDL_strrevPtr(str);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strrev")]
	public static partial byte* SDL_strrevPtr(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_strrev")]
	public static partial byte* SDL_strrevPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	/// <summary>
	/// Convert a string to uppercase.<br/>
	/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
	/// values 'A' through 'Z' to uppercase.<br/>
	/// This function operates on a null-terminated string of bytes--even if it is<br/>
	/// malformed UTF-8!--and converts ASCII characters 'a' through 'z' to their<br/>
	/// uppercase equivalents in-place, returning the original `str` pointer.<br/>
	/// <br/>
	/// @param str the string to convert in-place. Can not be NULL.<br/>
	/// @returns the `str` pointer passed into this function.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_strlwr
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strupr")]
	public static partial byte* SDL_struprPtr(byte* str);

	public static string? SDL_strupr(byte* str)
	{
		byte* resultPtr = SDL_struprPtr(str);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strupr")]
	public static partial byte* SDL_struprPtr(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_strupr")]
	public static partial byte* SDL_struprPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	/// <summary>
	/// Convert a string to lowercase.<br/>
	/// **WARNING**: Regardless of system locale, this will only convert ASCII<br/>
	/// values 'A' through 'Z' to lowercase.<br/>
	/// This function operates on a null-terminated string of bytes--even if it is<br/>
	/// malformed UTF-8!--and converts ASCII characters 'A' through 'Z' to their<br/>
	/// lowercase equivalents in-place, returning the original `str` pointer.<br/>
	/// <br/>
	/// @param str the string to convert in-place. Can not be NULL.<br/>
	/// @returns the `str` pointer passed into this function.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_strupr
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strlwr")]
	public static partial byte* SDL_strlwrPtr(byte* str);

	public static string? SDL_strlwr(byte* str)
	{
		byte* resultPtr = SDL_strlwrPtr(str);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strlwr")]
	public static partial byte* SDL_strlwrPtr(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_strlwr")]
	public static partial byte* SDL_strlwrPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	[LibraryImport(LibName, EntryPoint = "SDL_strchr")]
	public static partial byte* SDL_strchrPtr(byte* str, int c);

	public static string? SDL_strchr(byte* str, int c)
	{
		byte* resultPtr = SDL_strchrPtr(str, c);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strchr")]
	public static partial byte* SDL_strchrPtr(ReadOnlySpan<byte> str, int c);

	[LibraryImport(LibName, EntryPoint = "SDL_strchr")]
	public static partial byte* SDL_strchrPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, int c);

	[LibraryImport(LibName, EntryPoint = "SDL_strrchr")]
	public static partial byte* SDL_strrchrPtr(byte* str, int c);

	public static string? SDL_strrchr(byte* str, int c)
	{
		byte* resultPtr = SDL_strrchrPtr(str, c);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strrchr")]
	public static partial byte* SDL_strrchrPtr(ReadOnlySpan<byte> str, int c);

	[LibraryImport(LibName, EntryPoint = "SDL_strrchr")]
	public static partial byte* SDL_strrchrPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, int c);

	[LibraryImport(LibName, EntryPoint = "SDL_strstr")]
	public static partial byte* SDL_strstrPtr(byte* haystack, byte* needle);

	public static string? SDL_strstr(byte* haystack, byte* needle)
	{
		byte* resultPtr = SDL_strstrPtr(haystack, needle);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strstr")]
	public static partial byte* SDL_strstrPtr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle);

	[LibraryImport(LibName, EntryPoint = "SDL_strstr")]
	public static partial byte* SDL_strstrPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> haystack, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> needle);

	[LibraryImport(LibName, EntryPoint = "SDL_strnstr")]
	public static partial byte* SDL_strnstrPtr(byte* haystack, byte* needle, nuint maxlen);

	public static string? SDL_strnstr(byte* haystack, byte* needle, nuint maxlen)
	{
		byte* resultPtr = SDL_strnstrPtr(haystack, needle, maxlen);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strnstr")]
	public static partial byte* SDL_strnstrPtr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strnstr")]
	public static partial byte* SDL_strnstrPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> haystack, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> needle, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strcasestr")]
	public static partial byte* SDL_strcasestrPtr(byte* haystack, byte* needle);

	public static string? SDL_strcasestr(byte* haystack, byte* needle)
	{
		byte* resultPtr = SDL_strcasestrPtr(haystack, needle);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strcasestr")]
	public static partial byte* SDL_strcasestrPtr(ReadOnlySpan<byte> haystack, ReadOnlySpan<byte> needle);

	[LibraryImport(LibName, EntryPoint = "SDL_strcasestr")]
	public static partial byte* SDL_strcasestrPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> haystack, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> needle);

	[LibraryImport(LibName, EntryPoint = "SDL_strtok_r")]
	public static partial byte* SDL_strtok_rPtr(byte* s1, byte* s2, byte** saveptr);

	public static string? SDL_strtok_r(byte* s1, byte* s2, byte** saveptr)
	{
		byte* resultPtr = SDL_strtok_rPtr(s1, s2, saveptr);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strtok_r")]
	public static partial byte* SDL_strtok_rPtr(ReadOnlySpan<byte> s1, ReadOnlySpan<byte> s2, byte** saveptr);

	[LibraryImport(LibName, EntryPoint = "SDL_strtok_r")]
	public static partial byte* SDL_strtok_rPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> s1, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> s2, byte** saveptr);

	[LibraryImport(LibName, EntryPoint = "SDL_utf8strlen")]
	public static partial nuint SDL_utf8strlen(byte* str);

	[LibraryImport(LibName, EntryPoint = "SDL_utf8strlen")]
	public static partial nuint SDL_utf8strlen(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_utf8strlen")]
	public static partial nuint SDL_utf8strlen([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	[LibraryImport(LibName, EntryPoint = "SDL_utf8strnlen")]
	public static partial nuint SDL_utf8strnlen(byte* str, nuint bytes);

	[LibraryImport(LibName, EntryPoint = "SDL_utf8strnlen")]
	public static partial nuint SDL_utf8strnlen(ReadOnlySpan<byte> str, nuint bytes);

	[LibraryImport(LibName, EntryPoint = "SDL_utf8strnlen")]
	public static partial nuint SDL_utf8strnlen([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, nuint bytes);

	[LibraryImport(LibName, EntryPoint = "SDL_itoa")]
	public static partial byte* SDL_itoaPtr(int value, byte* str, int radix);

	public static string? SDL_itoa(int value, byte* str, int radix)
	{
		byte* resultPtr = SDL_itoaPtr(value, str, radix);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_itoa")]
	public static partial byte* SDL_itoaPtr(int value, ReadOnlySpan<byte> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_itoa")]
	public static partial byte* SDL_itoaPtr(int value, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_uitoa")]
	public static partial byte* SDL_uitoaPtr(uint value, byte* str, int radix);

	public static string? SDL_uitoa(uint value, byte* str, int radix)
	{
		byte* resultPtr = SDL_uitoaPtr(value, str, radix);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_uitoa")]
	public static partial byte* SDL_uitoaPtr(uint value, ReadOnlySpan<byte> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_uitoa")]
	public static partial byte* SDL_uitoaPtr(uint value, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_ltoa")]
	public static partial byte* SDL_ltoaPtr(global::System.Runtime.InteropServices.CLong value, byte* str, int radix);

	public static string? SDL_ltoa(global::System.Runtime.InteropServices.CLong value, byte* str, int radix)
	{
		byte* resultPtr = SDL_ltoaPtr(value, str, radix);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_ltoa")]
	public static partial byte* SDL_ltoaPtr(global::System.Runtime.InteropServices.CLong value, ReadOnlySpan<byte> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_ltoa")]
	public static partial byte* SDL_ltoaPtr(global::System.Runtime.InteropServices.CLong value, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_ultoa")]
	public static partial byte* SDL_ultoaPtr(global::System.Runtime.InteropServices.CULong value, byte* str, int radix);

	public static string? SDL_ultoa(global::System.Runtime.InteropServices.CULong value, byte* str, int radix)
	{
		byte* resultPtr = SDL_ultoaPtr(value, str, radix);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_ultoa")]
	public static partial byte* SDL_ultoaPtr(global::System.Runtime.InteropServices.CULong value, ReadOnlySpan<byte> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_ultoa")]
	public static partial byte* SDL_ultoaPtr(global::System.Runtime.InteropServices.CULong value, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_lltoa")]
	public static partial byte* SDL_lltoaPtr(long value, byte* str, int radix);

	public static string? SDL_lltoa(long value, byte* str, int radix)
	{
		byte* resultPtr = SDL_lltoaPtr(value, str, radix);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_lltoa")]
	public static partial byte* SDL_lltoaPtr(long value, ReadOnlySpan<byte> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_lltoa")]
	public static partial byte* SDL_lltoaPtr(long value, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_ulltoa")]
	public static partial byte* SDL_ulltoaPtr(ulong value, byte* str, int radix);

	public static string? SDL_ulltoa(ulong value, byte* str, int radix)
	{
		byte* resultPtr = SDL_ulltoaPtr(value, str, radix);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_ulltoa")]
	public static partial byte* SDL_ulltoaPtr(ulong value, ReadOnlySpan<byte> str, int radix);

	[LibraryImport(LibName, EntryPoint = "SDL_ulltoa")]
	public static partial byte* SDL_ulltoaPtr(ulong value, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, int radix);

	/// <summary>
	/// Parse an `int` from a string.<br/>
	/// The result of calling `SDL_atoi(str)` is equivalent to<br/>
	/// `(int)SDL_strtol(str, NULL, 10)`.<br/>
	/// <br/>
	/// @param str The null-terminated string to read. Must not be NULL.<br/>
	/// @returns The parsed `int`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atof<br/>
	/// @sa SDL_strtol<br/>
	/// @sa SDL_strtoul<br/>
	/// @sa SDL_strtoll<br/>
	/// @sa SDL_strtoull<br/>
	/// @sa SDL_strtod<br/>
	/// @sa SDL_itoa
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_atoi")]
	public static partial int SDL_atoi(byte* str);

	[LibraryImport(LibName, EntryPoint = "SDL_atoi")]
	public static partial int SDL_atoi(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_atoi")]
	public static partial int SDL_atoi([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	/// <summary>
	/// Parse a `double` from a string.<br/>
	/// The result of calling `SDL_atof(str)` is equivalent to `SDL_strtod(str,<br/>
	/// NULL)`.<br/>
	/// <br/>
	/// @param str The null-terminated string to read. Must not be NULL.<br/>
	/// @returns The parsed `double`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atoi<br/>
	/// @sa SDL_strtol<br/>
	/// @sa SDL_strtoul<br/>
	/// @sa SDL_strtoll<br/>
	/// @sa SDL_strtoull<br/>
	/// @sa SDL_strtod
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_atof")]
	public static partial double SDL_atof(byte* str);

	[LibraryImport(LibName, EntryPoint = "SDL_atof")]
	public static partial double SDL_atof(ReadOnlySpan<byte> str);

	[LibraryImport(LibName, EntryPoint = "SDL_atof")]
	public static partial double SDL_atof([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str);

	/// <summary>
	/// Parse a `long` from a string.<br/>
	/// If `str` starts with whitespace, then those whitespace characters are<br/>
	/// skipped before attempting to parse the number.<br/>
	/// If the parsed number does not fit inside a `long`, the result is clamped to<br/>
	/// the minimum and maximum representable `long` values.<br/>
	/// <br/>
	/// @param str The null-terminated string to read. Must not be NULL.<br/>
	/// @param endp If not NULL, the address of the first invalid character (i.e.<br/>
	/// the next character after the parsed number) will be written to<br/>
	/// this pointer.<br/>
	/// @param base The base of the integer to read. Supported values are 0 and 2<br/>
	/// to 36 inclusive. If 0, the base will be inferred from the<br/>
	/// number's prefix (0x for hexadecimal, 0 for octal, decimal<br/>
	/// otherwise).<br/>
	/// @returns The parsed `long`, or 0 if no number could be parsed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atoi<br/>
	/// @sa SDL_atof<br/>
	/// @sa SDL_strtoul<br/>
	/// @sa SDL_strtoll<br/>
	/// @sa SDL_strtoull<br/>
	/// @sa SDL_strtod<br/>
	/// @sa SDL_ltoa<br/>
	/// @sa SDL_wcstol
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strtol")]
	public static partial global::System.Runtime.InteropServices.CLong SDL_strtol(byte* str, byte** endp, int @base);

	[LibraryImport(LibName, EntryPoint = "SDL_strtol")]
	public static partial global::System.Runtime.InteropServices.CLong SDL_strtol(ReadOnlySpan<byte> str, byte** endp, int @base);

	[LibraryImport(LibName, EntryPoint = "SDL_strtol")]
	public static partial global::System.Runtime.InteropServices.CLong SDL_strtol([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, byte** endp, int @base);

	/// <summary>
	/// Parse an `unsigned long` from a string.<br/>
	/// If `str` starts with whitespace, then those whitespace characters are<br/>
	/// skipped before attempting to parse the number.<br/>
	/// If the parsed number does not fit inside an `unsigned long`, the result is<br/>
	/// clamped to the maximum representable `unsigned long` value.<br/>
	/// <br/>
	/// @param str The null-terminated string to read. Must not be NULL.<br/>
	/// @param endp If not NULL, the address of the first invalid character (i.e.<br/>
	/// the next character after the parsed number) will be written to<br/>
	/// this pointer.<br/>
	/// @param base The base of the integer to read. Supported values are 0 and 2<br/>
	/// to 36 inclusive. If 0, the base will be inferred from the<br/>
	/// number's prefix (0x for hexadecimal, 0 for octal, decimal<br/>
	/// otherwise).<br/>
	/// @returns The parsed `unsigned long`, or 0 if no number could be parsed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atoi<br/>
	/// @sa SDL_atof<br/>
	/// @sa SDL_strtol<br/>
	/// @sa SDL_strtoll<br/>
	/// @sa SDL_strtoull<br/>
	/// @sa SDL_strtod<br/>
	/// @sa SDL_ultoa
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strtoul")]
	public static partial global::System.Runtime.InteropServices.CULong SDL_strtoul(byte* str, byte** endp, int @base);

	[LibraryImport(LibName, EntryPoint = "SDL_strtoul")]
	public static partial global::System.Runtime.InteropServices.CULong SDL_strtoul(ReadOnlySpan<byte> str, byte** endp, int @base);

	[LibraryImport(LibName, EntryPoint = "SDL_strtoul")]
	public static partial global::System.Runtime.InteropServices.CULong SDL_strtoul([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, byte** endp, int @base);

	/// <summary>
	/// Parse a `long long` from a string.<br/>
	/// If `str` starts with whitespace, then those whitespace characters are<br/>
	/// skipped before attempting to parse the number.<br/>
	/// If the parsed number does not fit inside a `long long`, the result is<br/>
	/// clamped to the minimum and maximum representable `long long` values.<br/>
	/// <br/>
	/// @param str The null-terminated string to read. Must not be NULL.<br/>
	/// @param endp If not NULL, the address of the first invalid character (i.e.<br/>
	/// the next character after the parsed number) will be written to<br/>
	/// this pointer.<br/>
	/// @param base The base of the integer to read. Supported values are 0 and 2<br/>
	/// to 36 inclusive. If 0, the base will be inferred from the<br/>
	/// number's prefix (0x for hexadecimal, 0 for octal, decimal<br/>
	/// otherwise).<br/>
	/// @returns The parsed `long long`, or 0 if no number could be parsed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atoi<br/>
	/// @sa SDL_atof<br/>
	/// @sa SDL_strtol<br/>
	/// @sa SDL_strtoul<br/>
	/// @sa SDL_strtoull<br/>
	/// @sa SDL_strtod<br/>
	/// @sa SDL_lltoa
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strtoll")]
	public static partial long SDL_strtoll(byte* str, byte** endp, int @base);

	[LibraryImport(LibName, EntryPoint = "SDL_strtoll")]
	public static partial long SDL_strtoll(ReadOnlySpan<byte> str, byte** endp, int @base);

	[LibraryImport(LibName, EntryPoint = "SDL_strtoll")]
	public static partial long SDL_strtoll([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, byte** endp, int @base);

	/// <summary>
	/// Parse an `unsigned long long` from a string.<br/>
	/// If `str` starts with whitespace, then those whitespace characters are<br/>
	/// skipped before attempting to parse the number.<br/>
	/// If the parsed number does not fit inside an `unsigned long long`, the<br/>
	/// result is clamped to the maximum representable `unsigned long long` value.<br/>
	/// <br/>
	/// @param str The null-terminated string to read. Must not be NULL.<br/>
	/// @param endp If not NULL, the address of the first invalid character (i.e.<br/>
	/// the next character after the parsed number) will be written to<br/>
	/// this pointer.<br/>
	/// @param base The base of the integer to read. Supported values are 0 and 2<br/>
	/// to 36 inclusive. If 0, the base will be inferred from the<br/>
	/// number's prefix (0x for hexadecimal, 0 for octal, decimal<br/>
	/// otherwise).<br/>
	/// @returns The parsed `unsigned long long`, or 0 if no number could be<br/>
	/// parsed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atoi<br/>
	/// @sa SDL_atof<br/>
	/// @sa SDL_strtol<br/>
	/// @sa SDL_strtoll<br/>
	/// @sa SDL_strtoul<br/>
	/// @sa SDL_strtod<br/>
	/// @sa SDL_ulltoa
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strtoull")]
	public static partial ulong SDL_strtoull(byte* str, byte** endp, int @base);

	[LibraryImport(LibName, EntryPoint = "SDL_strtoull")]
	public static partial ulong SDL_strtoull(ReadOnlySpan<byte> str, byte** endp, int @base);

	[LibraryImport(LibName, EntryPoint = "SDL_strtoull")]
	public static partial ulong SDL_strtoull([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, byte** endp, int @base);

	/// <summary>
	/// Parse a `double` from a string.<br/>
	/// This function makes fewer guarantees than the C runtime `strtod`:<br/>
	/// - Only decimal notation is guaranteed to be supported. The handling of<br/>
	/// scientific and hexadecimal notation is unspecified.<br/>
	/// - Whether or not INF and NAN can be parsed is unspecified.<br/>
	/// - The precision of the result is unspecified.<br/>
	/// <br/>
	/// @param str The null-terminated string to read. Must not be NULL.<br/>
	/// @param endp If not NULL, the address of the first invalid character (i.e.<br/>
	/// the next character after the parsed number) will be written to<br/>
	/// this pointer.<br/>
	/// @returns The parsed `double`, or 0 if no number could be parsed.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atoi<br/>
	/// @sa SDL_atof<br/>
	/// @sa SDL_strtol<br/>
	/// @sa SDL_strtoll<br/>
	/// @sa SDL_strtoul<br/>
	/// @sa SDL_strtoull
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strtod")]
	public static partial double SDL_strtod(byte* str, byte** endp);

	[LibraryImport(LibName, EntryPoint = "SDL_strtod")]
	public static partial double SDL_strtod(ReadOnlySpan<byte> str, byte** endp);

	[LibraryImport(LibName, EntryPoint = "SDL_strtod")]
	public static partial double SDL_strtod([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, byte** endp);

	/// <summary>
	/// Compare two null-terminated UTF-8 strings.<br/>
	/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
	/// since effectively this function just compares bytes until it hits a<br/>
	/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
	/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
	/// <br/>
	/// @param str1 the first string to compare. NULL is not permitted!<br/>
	/// @param str2 the second string to compare. NULL is not permitted!<br/>
	/// @returns less than zero if str1 is "less than" str2, greater than zero if<br/>
	/// str1 is "greater than" str2, and zero if the strings match<br/>
	/// exactly.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strcmp")]
	public static partial int SDL_strcmp(byte* str1, byte* str2);

	[LibraryImport(LibName, EntryPoint = "SDL_strcmp")]
	public static partial int SDL_strcmp(ReadOnlySpan<byte> str1, ReadOnlySpan<byte> str2);

	[LibraryImport(LibName, EntryPoint = "SDL_strcmp")]
	public static partial int SDL_strcmp([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str1, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str2);

	/// <summary>
	/// Compare two UTF-8 strings up to a number of bytes.<br/>
	/// Due to the nature of UTF-8 encoding, this will work with Unicode strings,<br/>
	/// since effectively this function just compares bytes until it hits a<br/>
	/// null-terminating character. Also due to the nature of UTF-8, this can be<br/>
	/// used with SDL_qsort() to put strings in (roughly) alphabetical order.<br/>
	/// Note that while this function is intended to be used with UTF-8, it is<br/>
	/// doing a bytewise comparison, and `maxlen` specifies a _byte_ limit! If the<br/>
	/// limit lands in the middle of a multi-byte UTF-8 sequence, it will only<br/>
	/// compare a portion of the final character.<br/>
	/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
	/// match to this number of bytes (or both have matched to a null-terminator<br/>
	/// character before this number of bytes), they will be considered equal.<br/>
	/// <br/>
	/// @param str1 the first string to compare. NULL is not permitted!<br/>
	/// @param str2 the second string to compare. NULL is not permitted!<br/>
	/// @param maxlen the maximum number of _bytes_ to compare.<br/>
	/// @returns less than zero if str1 is "less than" str2, greater than zero if<br/>
	/// str1 is "greater than" str2, and zero if the strings match<br/>
	/// exactly.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strncmp")]
	public static partial int SDL_strncmp(byte* str1, byte* str2, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strncmp")]
	public static partial int SDL_strncmp(ReadOnlySpan<byte> str1, ReadOnlySpan<byte> str2, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strncmp")]
	public static partial int SDL_strncmp([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str1, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str2, nuint maxlen);

	/// <summary>
	/// Compare two null-terminated UTF-8 strings, case-insensitively.<br/>
	/// This will work with Unicode strings, using a technique called<br/>
	/// "case-folding" to handle the vast majority of case-sensitive human<br/>
	/// languages regardless of system locale. It can deal with expanding values: a<br/>
	/// German Eszett character can compare against two ASCII 's' chars and be<br/>
	/// considered a match, for example. A notable exception: it does not handle<br/>
	/// the Turkish 'i' character; human language is complicated!<br/>
	/// Since this handles Unicode, it expects the string to be well-formed UTF-8<br/>
	/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
	/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
	/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
	/// match if they convert to the same amount of replacement characters.<br/>
	/// <br/>
	/// @param str1 the first string to compare. NULL is not permitted!<br/>
	/// @param str2 the second string to compare. NULL is not permitted!<br/>
	/// @returns less than zero if str1 is "less than" str2, greater than zero if<br/>
	/// str1 is "greater than" str2, and zero if the strings match<br/>
	/// exactly.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strcasecmp")]
	public static partial int SDL_strcasecmp(byte* str1, byte* str2);

	[LibraryImport(LibName, EntryPoint = "SDL_strcasecmp")]
	public static partial int SDL_strcasecmp(ReadOnlySpan<byte> str1, ReadOnlySpan<byte> str2);

	[LibraryImport(LibName, EntryPoint = "SDL_strcasecmp")]
	public static partial int SDL_strcasecmp([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str1, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str2);

	/// <summary>
	/// Compare two UTF-8 strings, case-insensitively, up to a number of bytes.<br/>
	/// This will work with Unicode strings, using a technique called<br/>
	/// "case-folding" to handle the vast majority of case-sensitive human<br/>
	/// languages regardless of system locale. It can deal with expanding values: a<br/>
	/// German Eszett character can compare against two ASCII 's' chars and be<br/>
	/// considered a match, for example. A notable exception: it does not handle<br/>
	/// the Turkish 'i' character; human language is complicated!<br/>
	/// Since this handles Unicode, it expects the string to be well-formed UTF-8<br/>
	/// and not a null-terminated string of arbitrary bytes. Bytes that are not<br/>
	/// valid UTF-8 are treated as Unicode character U+FFFD (REPLACEMENT<br/>
	/// CHARACTER), which is to say two strings of random bits may turn out to<br/>
	/// match if they convert to the same amount of replacement characters.<br/>
	/// Note that while this function is intended to be used with UTF-8, `maxlen`<br/>
	/// specifies a _byte_ limit! If the limit lands in the middle of a multi-byte<br/>
	/// UTF-8 sequence, it may convert a portion of the final character to one or<br/>
	/// more Unicode character U+FFFD (REPLACEMENT CHARACTER) so as not to overflow<br/>
	/// a buffer.<br/>
	/// `maxlen` specifies a maximum number of bytes to compare; if the strings<br/>
	/// match to this number of bytes (or both have matched to a null-terminator<br/>
	/// character before this number of bytes), they will be considered equal.<br/>
	/// <br/>
	/// @param str1 the first string to compare. NULL is not permitted!<br/>
	/// @param str2 the second string to compare. NULL is not permitted!<br/>
	/// @param maxlen the maximum number of bytes to compare.<br/>
	/// @returns less than zero if str1 is "less than" str2, greater than zero if<br/>
	/// str1 is "greater than" str2, and zero if the strings match<br/>
	/// exactly.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strncasecmp")]
	public static partial int SDL_strncasecmp(byte* str1, byte* str2, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strncasecmp")]
	public static partial int SDL_strncasecmp(ReadOnlySpan<byte> str1, ReadOnlySpan<byte> str2, nuint maxlen);

	[LibraryImport(LibName, EntryPoint = "SDL_strncasecmp")]
	public static partial int SDL_strncasecmp([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str1, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str2, nuint maxlen);

	/// <summary>
	/// Searches a string for the first occurence of any character contained in a<br/>
	/// breakset, and returns a pointer from the string to that character.<br/>
	/// <br/>
	/// @param str The null-terminated string to be searched. Must not be NULL, and<br/>
	/// must not overlap with `breakset`.<br/>
	/// @param breakset A null-terminated string containing the list of characters<br/>
	/// to look for. Must not be NULL, and must not overlap with<br/>
	/// `str`.<br/>
	/// @returns A pointer to the location, in str, of the first occurence of a<br/>
	/// character present in the breakset, or NULL if none is found.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_strpbrk")]
	public static partial byte* SDL_strpbrkPtr(byte* str, byte* breakset);

	public static string? SDL_strpbrk(byte* str, byte* breakset)
	{
		byte* resultPtr = SDL_strpbrkPtr(str, breakset);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_strpbrk")]
	public static partial byte* SDL_strpbrkPtr(ReadOnlySpan<byte> str, ReadOnlySpan<byte> breakset);

	[LibraryImport(LibName, EntryPoint = "SDL_strpbrk")]
	public static partial byte* SDL_strpbrkPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> str, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> breakset);

	/// <summary>
	/// Decode a UTF-8 string, one Unicode codepoint at a time.<br/>
	/// This will return the first Unicode codepoint in the UTF-8 encoded string in<br/>
	/// `*pstr`, and then advance `*pstr` past any consumed bytes before returning.<br/>
	/// It will not access more than `*pslen` bytes from the string. `*pslen` will<br/>
	/// be adjusted, as well, subtracting the number of bytes consumed.<br/>
	/// `pslen` is allowed to be NULL, in which case the string _must_ be<br/>
	/// NULL-terminated, as the function will blindly read until it sees the NULL<br/>
	/// char.<br/>
	/// if `*pslen` is zero, it assumes the end of string is reached and returns a<br/>
	/// zero codepoint regardless of the contents of the string buffer.<br/>
	/// If the resulting codepoint is zero (a NULL terminator), or `*pslen` is<br/>
	/// zero, it will not advance `*pstr` or `*pslen` at all.<br/>
	/// Generally this function is called in a loop until it returns zero,<br/>
	/// adjusting its parameters each iteration.<br/>
	/// If an invalid UTF-8 sequence is encountered, this function returns<br/>
	/// SDL_INVALID_UNICODE_CODEPOINT and advances the string/length by one byte<br/>
	/// (which is to say, a multibyte sequence might produce several<br/>
	/// SDL_INVALID_UNICODE_CODEPOINT returns before it syncs to the next valid<br/>
	/// UTF-8 sequence).<br/>
	/// Several things can generate invalid UTF-8 sequences, including overlong<br/>
	/// encodings, the use of UTF-16 surrogate values, and truncated data. Please<br/>
	/// refer to<br/>
	/// [RFC3629](https://www.ietf.org/rfc/rfc3629.txt)<br/>
	/// for details.<br/>
	/// <br/>
	/// @param pstr a pointer to a UTF-8 string pointer to be read and adjusted.<br/>
	/// @param pslen a pointer to the number of bytes in the string, to be read and<br/>
	/// adjusted. NULL is allowed.<br/>
	/// @returns the first Unicode codepoint in the string.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_StepUTF8")]
	public static partial uint SDL_StepUTF8(byte** pstr, nuint* pslen);

	/// <summary>
	/// Convert a single Unicode codepoint to UTF-8.<br/>
	/// The buffer pointed to by `dst` must be at least 4 bytes long, as this<br/>
	/// function may generate between 1 and 4 bytes of output.<br/>
	/// This function returns the first byte _after_ the newly-written UTF-8<br/>
	/// sequence, which is useful for encoding multiple codepoints in a loop, or<br/>
	/// knowing where to write a NULL-terminator character to end the string (in<br/>
	/// either case, plan to have a buffer of _more_ than 4 bytes!).<br/>
	/// If `codepoint` is an invalid value (outside the Unicode range, or a UTF-16<br/>
	/// surrogate value, etc), this will use U+FFFD (REPLACEMENT CHARACTER) for the<br/>
	/// codepoint instead, and not set an error.<br/>
	/// If `dst` is NULL, this returns NULL immediately without writing to the<br/>
	/// pointer and without setting an error.<br/>
	/// <br/>
	/// @param codepoint a Unicode codepoint to convert to UTF-8.<br/>
	/// @param dst the location to write the encoded UTF-8. Must point to at least<br/>
	/// 4 bytes!<br/>
	/// @returns the first byte past the newly-written UTF-8 sequence.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UCS4ToUTF8")]
	public static partial byte* SDL_UCS4ToUTF8Ptr(uint codepoint, byte* dst);

	public static string? SDL_UCS4ToUTF8(uint codepoint, byte* dst)
	{
		byte* resultPtr = SDL_UCS4ToUTF8Ptr(codepoint, dst);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_UCS4ToUTF8")]
	public static partial byte* SDL_UCS4ToUTF8Ptr(uint codepoint, ReadOnlySpan<byte> dst);

	[LibraryImport(LibName, EntryPoint = "SDL_UCS4ToUTF8")]
	public static partial byte* SDL_UCS4ToUTF8Ptr(uint codepoint, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> dst);

	[LibraryImport(LibName, EntryPoint = "SDL_sscanf")]
	public static partial int SDL_sscanf(byte* text, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_sscanf")]
	public static partial int SDL_sscanf(ReadOnlySpan<byte> text, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_sscanf")]
	public static partial int SDL_sscanf([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> text, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_vsscanf")]
	public static partial int SDL_vsscanf(byte* text, byte* fmt, byte* ap);

	[LibraryImport(LibName, EntryPoint = "SDL_vsscanf")]
	public static partial int SDL_vsscanf(ReadOnlySpan<byte> text, ReadOnlySpan<byte> fmt, byte* ap);

	[LibraryImport(LibName, EntryPoint = "SDL_vsscanf")]
	public static partial int SDL_vsscanf([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> text, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt, byte* ap);

	[LibraryImport(LibName, EntryPoint = "SDL_snprintf")]
	public static partial int SDL_snprintf(byte* text, nuint maxlen, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_snprintf")]
	public static partial int SDL_snprintf(ReadOnlySpan<byte> text, nuint maxlen, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_snprintf")]
	public static partial int SDL_snprintf([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> text, nuint maxlen, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_swprintf")]
	public static partial int SDL_swprintf(char* text, nuint maxlen, char* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_vsnprintf")]
	public static partial int SDL_vsnprintf(byte* text, nuint maxlen, byte* fmt, byte* ap);

	[LibraryImport(LibName, EntryPoint = "SDL_vsnprintf")]
	public static partial int SDL_vsnprintf(ReadOnlySpan<byte> text, nuint maxlen, ReadOnlySpan<byte> fmt, byte* ap);

	[LibraryImport(LibName, EntryPoint = "SDL_vsnprintf")]
	public static partial int SDL_vsnprintf([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> text, nuint maxlen, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt, byte* ap);

	[LibraryImport(LibName, EntryPoint = "SDL_vswprintf")]
	public static partial int SDL_vswprintf(char* text, nuint maxlen, char* fmt, byte* ap);

	[LibraryImport(LibName, EntryPoint = "SDL_asprintf")]
	public static partial int SDL_asprintf(byte** strp, byte* fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_asprintf")]
	public static partial int SDL_asprintf(byte** strp, ReadOnlySpan<byte> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_asprintf")]
	public static partial int SDL_asprintf(byte** strp, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt);

	[LibraryImport(LibName, EntryPoint = "SDL_vasprintf")]
	public static partial int SDL_vasprintf(byte** strp, byte* fmt, byte* ap);

	[LibraryImport(LibName, EntryPoint = "SDL_vasprintf")]
	public static partial int SDL_vasprintf(byte** strp, ReadOnlySpan<byte> fmt, byte* ap);

	[LibraryImport(LibName, EntryPoint = "SDL_vasprintf")]
	public static partial int SDL_vasprintf(byte** strp, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fmt, byte* ap);

	/// <summary>
	/// Seeds the pseudo-random number generator.<br/>
	/// Reusing the seed number will cause SDL_rand_*() to repeat the same stream<br/>
	/// of 'random' numbers.<br/>
	/// <br/>
	/// @param seed the value to use as a random number seed, or 0 to use<br/>
	/// SDL_GetPerformanceCounter().<br/>
	/// @threadsafety This should be called on the same thread that calls<br/>
	/// SDL_rand*()<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_rand<br/>
	/// @sa SDL_rand_bits<br/>
	/// @sa SDL_randf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_srand")]
	public static partial void SDL_srand(ulong seed);

	/// <summary>
	/// Generate a pseudo-random number less than n for positive n<br/>
	/// The method used is faster and of better quality than `rand() % n`. Odds are<br/>
	/// roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and<br/>
	/// much worse as n gets bigger.<br/>
	/// Example: to simulate a d6 use `SDL_rand(6) + 1` The +1 converts 0..5 to<br/>
	/// 1..6<br/>
	/// If you want to generate a pseudo-random number in the full range of Sint32,<br/>
	/// you should use: (Sint32)SDL_rand_bits()<br/>
	/// If you want reproducible output, be sure to initialize with SDL_srand()<br/>
	/// first.<br/>
	/// There are no guarantees as to the quality of the random sequence produced,<br/>
	/// and this should not be used for security (cryptography, passwords) or where<br/>
	/// money is on the line (loot-boxes, casinos). There are many random number<br/>
	/// libraries available with different characteristics and you should pick one<br/>
	/// of those to meet any serious needs.<br/>
	/// <br/>
	/// @param n the number of possible outcomes. n must be positive.<br/>
	/// @returns a random value in the range of [0 .. n-1].<br/>
	/// @threadsafety All calls should be made from a single thread<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_srand<br/>
	/// @sa SDL_randf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_rand")]
	public static partial int SDL_rand(int n);

	/// <summary>
	/// Generate a uniform pseudo-random floating point number less than 1.0<br/>
	/// If you want reproducible output, be sure to initialize with SDL_srand()<br/>
	/// first.<br/>
	/// There are no guarantees as to the quality of the random sequence produced,<br/>
	/// and this should not be used for security (cryptography, passwords) or where<br/>
	/// money is on the line (loot-boxes, casinos). There are many random number<br/>
	/// libraries available with different characteristics and you should pick one<br/>
	/// of those to meet any serious needs.<br/>
	/// <br/>
	/// @returns a random value in the range of [0.0, 1.0).<br/>
	/// @threadsafety All calls should be made from a single thread<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_srand<br/>
	/// @sa SDL_rand
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_randf")]
	public static partial float SDL_randf();

	/// <summary>
	/// Generate 32 pseudo-random bits.<br/>
	/// You likely want to use SDL_rand() to get a psuedo-random number instead.<br/>
	/// There are no guarantees as to the quality of the random sequence produced,<br/>
	/// and this should not be used for security (cryptography, passwords) or where<br/>
	/// money is on the line (loot-boxes, casinos). There are many random number<br/>
	/// libraries available with different characteristics and you should pick one<br/>
	/// of those to meet any serious needs.<br/>
	/// <br/>
	/// @returns a random value in the range of [0-SDL_MAX_UINT32].<br/>
	/// @threadsafety All calls should be made from a single thread<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_rand<br/>
	/// @sa SDL_randf<br/>
	/// @sa SDL_srand
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_rand_bits")]
	public static partial uint SDL_rand_bits();

	/// <summary>
	/// Generate a pseudo-random number less than n for positive n<br/>
	/// The method used is faster and of better quality than `rand() % n`. Odds are<br/>
	/// roughly 99.9% even for n = 1 million. Evenness is better for smaller n, and<br/>
	/// much worse as n gets bigger.<br/>
	/// Example: to simulate a d6 use `SDL_rand_r(state, 6) + 1` The +1 converts<br/>
	/// 0..5 to 1..6<br/>
	/// If you want to generate a pseudo-random number in the full range of Sint32,<br/>
	/// you should use: (Sint32)SDL_rand_bits_r(state)<br/>
	/// There are no guarantees as to the quality of the random sequence produced,<br/>
	/// and this should not be used for security (cryptography, passwords) or where<br/>
	/// money is on the line (loot-boxes, casinos). There are many random number<br/>
	/// libraries available with different characteristics and you should pick one<br/>
	/// of those to meet any serious needs.<br/>
	/// <br/>
	/// @param state a pointer to the current random number state, this may not be<br/>
	/// NULL.<br/>
	/// @param n the number of possible outcomes. n must be positive.<br/>
	/// @returns a random value in the range of [0 .. n-1].<br/>
	/// @threadsafety This function is thread-safe, as long as the state pointer<br/>
	/// isn't shared between threads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_rand<br/>
	/// @sa SDL_rand_bits_r<br/>
	/// @sa SDL_randf_r
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_rand_r")]
	public static partial int SDL_rand_r(ulong* state, int n);

	/// <summary>
	/// Generate a uniform pseudo-random floating point number less than 1.0<br/>
	/// If you want reproducible output, be sure to initialize with SDL_srand()<br/>
	/// first.<br/>
	/// There are no guarantees as to the quality of the random sequence produced,<br/>
	/// and this should not be used for security (cryptography, passwords) or where<br/>
	/// money is on the line (loot-boxes, casinos). There are many random number<br/>
	/// libraries available with different characteristics and you should pick one<br/>
	/// of those to meet any serious needs.<br/>
	/// <br/>
	/// @param state a pointer to the current random number state, this may not be<br/>
	/// NULL.<br/>
	/// @returns a random value in the range of [0.0, 1.0).<br/>
	/// @threadsafety This function is thread-safe, as long as the state pointer<br/>
	/// isn't shared between threads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_rand_bits_r<br/>
	/// @sa SDL_rand_r<br/>
	/// @sa SDL_randf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_randf_r")]
	public static partial float SDL_randf_r(ulong* state);

	/// <summary>
	/// Generate 32 pseudo-random bits.<br/>
	/// You likely want to use SDL_rand_r() to get a psuedo-random number instead.<br/>
	/// There are no guarantees as to the quality of the random sequence produced,<br/>
	/// and this should not be used for security (cryptography, passwords) or where<br/>
	/// money is on the line (loot-boxes, casinos). There are many random number<br/>
	/// libraries available with different characteristics and you should pick one<br/>
	/// of those to meet any serious needs.<br/>
	/// <br/>
	/// @param state a pointer to the current random number state, this may not be<br/>
	/// NULL.<br/>
	/// @returns a random value in the range of [0-SDL_MAX_UINT32].<br/>
	/// @threadsafety This function is thread-safe, as long as the state pointer<br/>
	/// isn't shared between threads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_rand_r<br/>
	/// @sa SDL_randf_r
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_rand_bits_r")]
	public static partial uint SDL_rand_bits_r(ulong* state);

	/// <summary>
	/// Compute the arc cosine of `x`.<br/>
	/// The definition of `y = acos(x)` is `x = cos(y)`.<br/>
	/// Domain: `-1<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = 1`<br/>
	/// Range: `0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = Pi`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_acosf for single-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns arc cosine of `x`, in radians.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_acosf<br/>
	/// @sa SDL_asin<br/>
	/// @sa SDL_cos
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_acos")]
	public static partial double SDL_acos(double x);

	/// <summary>
	/// Compute the arc cosine of `x`.<br/>
	/// The definition of `y = acos(x)` is `x = cos(y)`.<br/>
	/// Domain: `-1<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = 1`<br/>
	/// Range: `0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = Pi`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_acos for double-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns arc cosine of `x`, in radians.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_acos<br/>
	/// @sa SDL_asinf<br/>
	/// @sa SDL_cosf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_acosf")]
	public static partial float SDL_acosf(float x);

	/// <summary>
	/// Compute the arc sine of `x`.<br/>
	/// The definition of `y = asin(x)` is `x = sin(y)`.<br/>
	/// Domain: `-1<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = 1`<br/>
	/// Range: `-Pi/2<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = Pi/2`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_asinf for single-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns arc sine of `x`, in radians.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_asinf<br/>
	/// @sa SDL_acos<br/>
	/// @sa SDL_sin
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_asin")]
	public static partial double SDL_asin(double x);

	/// <summary>
	/// Compute the arc sine of `x`.<br/>
	/// The definition of `y = asin(x)` is `x = sin(y)`.<br/>
	/// Domain: `-1<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = 1`<br/>
	/// Range: `-Pi/2<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = Pi/2`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_asin for double-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns arc sine of `x`, in radians.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_asin<br/>
	/// @sa SDL_acosf<br/>
	/// @sa SDL_sinf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_asinf")]
	public static partial float SDL_asinf(float x);

	/// <summary>
	/// Compute the arc tangent of `x`.<br/>
	/// The definition of `y = atan(x)` is `x = tan(y)`.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-Pi/2<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = Pi/2`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_atanf for single-precision floats.<br/>
	/// To calculate the arc tangent of y / x, use SDL_atan2.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns arc tangent of of `x` in radians, or 0 if `x = 0`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atanf<br/>
	/// @sa SDL_atan2<br/>
	/// @sa SDL_tan
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_atan")]
	public static partial double SDL_atan(double x);

	/// <summary>
	/// Compute the arc tangent of `x`.<br/>
	/// The definition of `y = atan(x)` is `x = tan(y)`.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-Pi/2<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = Pi/2`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_atan for dboule-precision floats.<br/>
	/// To calculate the arc tangent of y / x, use SDL_atan2f.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns arc tangent of of `x` in radians, or 0 if `x = 0`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atan<br/>
	/// @sa SDL_atan2f<br/>
	/// @sa SDL_tanf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_atanf")]
	public static partial float SDL_atanf(float x);

	/// <summary>
	/// Compute the arc tangent of `y / x`, using the signs of x and y to adjust<br/>
	/// the result's quadrant.<br/>
	/// The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant<br/>
	/// of z is determined based on the signs of x and y.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`, `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-Pi/2<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = Pi/2`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_atan2f for single-precision floats.<br/>
	/// To calculate the arc tangent of a single value, use SDL_atan.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param y floating point value of the numerator (y coordinate).<br/>
	/// @param x floating point value of the denominator (x coordinate).<br/>
	/// @returns arc tangent of of `y / x` in radians, or, if `x = 0`, either<br/>
	/// `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atan2f<br/>
	/// @sa SDL_atan<br/>
	/// @sa SDL_tan
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_atan2")]
	public static partial double SDL_atan2(double y, double x);

	/// <summary>
	/// Compute the arc tangent of `y / x`, using the signs of x and y to adjust<br/>
	/// the result's quadrant.<br/>
	/// The definition of `z = atan2(x, y)` is `y = x tan(z)`, where the quadrant<br/>
	/// of z is determined based on the signs of x and y.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`, `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-Pi/2<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = Pi/2`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_atan2 for double-precision floats.<br/>
	/// To calculate the arc tangent of a single value, use SDL_atanf.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param y floating point value of the numerator (y coordinate).<br/>
	/// @param x floating point value of the denominator (x coordinate).<br/>
	/// @returns arc tangent of of `y / x` in radians, or, if `x = 0`, either<br/>
	/// `-Pi/2`, `0`, or `Pi/2`, depending on the value of `y`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_atan2f<br/>
	/// @sa SDL_atan<br/>
	/// @sa SDL_tan
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_atan2f")]
	public static partial float SDL_atan2f(float y, float x);

	/// <summary>
	/// Compute the ceiling of `x`.<br/>
	/// The ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`<br/>
	/// rounded up to the nearest integer.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`, y integer<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_ceilf for single-precision floats.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns the ceiling of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ceilf<br/>
	/// @sa SDL_floor<br/>
	/// @sa SDL_trunc<br/>
	/// @sa SDL_round<br/>
	/// @sa SDL_lround
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ceil")]
	public static partial double SDL_ceil(double x);

	/// <summary>
	/// Compute the ceiling of `x`.<br/>
	/// The ceiling of `x` is the smallest integer `y` such that `y > x`, i.e `x`<br/>
	/// rounded up to the nearest integer.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`, y integer<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_ceil for double-precision floats.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns the ceiling of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ceil<br/>
	/// @sa SDL_floorf<br/>
	/// @sa SDL_truncf<br/>
	/// @sa SDL_roundf<br/>
	/// @sa SDL_lroundf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ceilf")]
	public static partial float SDL_ceilf(float x);

	/// <summary>
	/// Copy the sign of one floating-point value to another.<br/>
	/// The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`, ``-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = f``<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = z<br/>
	/// <<br/>
	/// = INF`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_copysignf for single-precision floats.<br/>
	/// <br/>
	/// @param x floating point value to use as the magnitude.<br/>
	/// @param y floating point value to use as the sign.<br/>
	/// @returns the floating point value with the sign of y and the magnitude of<br/>
	/// x.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_copysignf<br/>
	/// @sa SDL_fabs
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_copysign")]
	public static partial double SDL_copysign(double x, double y);

	/// <summary>
	/// Copy the sign of one floating-point value to another.<br/>
	/// The definition of copysign is that ``copysign(x, y) = abs(x) * sign(y)``.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`, ``-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = f``<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = z<br/>
	/// <<br/>
	/// = INF`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_copysign for double-precision floats.<br/>
	/// <br/>
	/// @param x floating point value to use as the magnitude.<br/>
	/// @param y floating point value to use as the sign.<br/>
	/// @returns the floating point value with the sign of y and the magnitude of<br/>
	/// x.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_copysignf<br/>
	/// @sa SDL_fabsf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_copysignf")]
	public static partial float SDL_copysignf(float x, float y);

	/// <summary>
	/// Compute the cosine of `x`.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-1<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = 1`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_cosf for single-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value, in radians.<br/>
	/// @returns cosine of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_cosf<br/>
	/// @sa SDL_acos<br/>
	/// @sa SDL_sin
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_cos")]
	public static partial double SDL_cos(double x);

	/// <summary>
	/// Compute the cosine of `x`.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-1<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = 1`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_cos for double-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value, in radians.<br/>
	/// @returns cosine of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_cos<br/>
	/// @sa SDL_acosf<br/>
	/// @sa SDL_sinf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_cosf")]
	public static partial float SDL_cosf(float x);

	/// <summary>
	/// Compute the exponential of `x`.<br/>
	/// The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the<br/>
	/// natural logarithm. The inverse is the natural logarithm, SDL_log.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// The output will overflow if `exp(x)` is too large to be represented.<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_expf for single-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns value of `e^x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_expf<br/>
	/// @sa SDL_log
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_exp")]
	public static partial double SDL_exp(double x);

	/// <summary>
	/// Compute the exponential of `x`.<br/>
	/// The definition of `y = exp(x)` is `y = e^x`, where `e` is the base of the<br/>
	/// natural logarithm. The inverse is the natural logarithm, SDL_logf.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// The output will overflow if `exp(x)` is too large to be represented.<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_exp for double-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns value of `e^x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_exp<br/>
	/// @sa SDL_logf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_expf")]
	public static partial float SDL_expf(float x);

	/// <summary>
	/// Compute the absolute value of `x`<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_copysignf for single-precision floats.<br/>
	/// <br/>
	/// @param x floating point value to use as the magnitude.<br/>
	/// @returns the absolute value of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_fabsf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_fabs")]
	public static partial double SDL_fabs(double x);

	/// <summary>
	/// Compute the absolute value of `x`<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_copysignf for double-precision floats.<br/>
	/// <br/>
	/// @param x floating point value to use as the magnitude.<br/>
	/// @returns the absolute value of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_fabs
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_fabsf")]
	public static partial float SDL_fabsf(float x);

	/// <summary>
	/// Compute the floor of `x`.<br/>
	/// The floor of `x` is the largest integer `y` such that `y > x`, i.e `x`<br/>
	/// rounded down to the nearest integer.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`, y integer<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_floorf for single-precision floats.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns the floor of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_floorf<br/>
	/// @sa SDL_ceil<br/>
	/// @sa SDL_trunc<br/>
	/// @sa SDL_round<br/>
	/// @sa SDL_lround
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_floor")]
	public static partial double SDL_floor(double x);

	/// <summary>
	/// Compute the floor of `x`.<br/>
	/// The floor of `x` is the largest integer `y` such that `y > x`, i.e `x`<br/>
	/// rounded down to the nearest integer.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`, y integer<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_floorf for double-precision floats.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns the floor of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_floor<br/>
	/// @sa SDL_ceilf<br/>
	/// @sa SDL_truncf<br/>
	/// @sa SDL_roundf<br/>
	/// @sa SDL_lroundf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_floorf")]
	public static partial float SDL_floorf(float x);

	/// <summary>
	/// Truncate `x` to an integer.<br/>
	/// Rounds `x` to the next closest integer to 0. This is equivalent to removing<br/>
	/// the fractional part of `x`, leaving only the integer part.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`, y integer<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_truncf for single-precision floats.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns `x` truncated to an integer.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_truncf<br/>
	/// @sa SDL_fmod<br/>
	/// @sa SDL_ceil<br/>
	/// @sa SDL_floor<br/>
	/// @sa SDL_round<br/>
	/// @sa SDL_lround
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_trunc")]
	public static partial double SDL_trunc(double x);

	/// <summary>
	/// Truncate `x` to an integer.<br/>
	/// Rounds `x` to the next closest integer to 0. This is equivalent to removing<br/>
	/// the fractional part of `x`, leaving only the integer part.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`, y integer<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_truncf for double-precision floats.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns `x` truncated to an integer.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_trunc<br/>
	/// @sa SDL_fmodf<br/>
	/// @sa SDL_ceilf<br/>
	/// @sa SDL_floorf<br/>
	/// @sa SDL_roundf<br/>
	/// @sa SDL_lroundf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_truncf")]
	public static partial float SDL_truncf(float x);

	/// <summary>
	/// Return the floating-point remainder of `x / y`<br/>
	/// Divides `x` by `y`, and returns the remainder.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`, `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`, `y != 0`<br/>
	/// Range: `-y<br/>
	/// <<br/>
	/// = z<br/>
	/// <<br/>
	/// = y`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_fmodf for single-precision floats.<br/>
	/// <br/>
	/// @param x the numerator.<br/>
	/// @param y the denominator. Must not be 0.<br/>
	/// @returns the remainder of `x / y`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_fmodf<br/>
	/// @sa SDL_modf<br/>
	/// @sa SDL_trunc<br/>
	/// @sa SDL_ceil<br/>
	/// @sa SDL_floor<br/>
	/// @sa SDL_round<br/>
	/// @sa SDL_lround
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_fmod")]
	public static partial double SDL_fmod(double x, double y);

	/// <summary>
	/// Return the floating-point remainder of `x / y`<br/>
	/// Divides `x` by `y`, and returns the remainder.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`, `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`, `y != 0`<br/>
	/// Range: `-y<br/>
	/// <<br/>
	/// = z<br/>
	/// <<br/>
	/// = y`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_fmod for single-precision floats.<br/>
	/// <br/>
	/// @param x the numerator.<br/>
	/// @param y the denominator. Must not be 0.<br/>
	/// @returns the remainder of `x / y`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_fmod<br/>
	/// @sa SDL_truncf<br/>
	/// @sa SDL_modff<br/>
	/// @sa SDL_ceilf<br/>
	/// @sa SDL_floorf<br/>
	/// @sa SDL_roundf<br/>
	/// @sa SDL_lroundf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_fmodf")]
	public static partial float SDL_fmodf(float x, float y);

	/// <summary>
	/// Return whether the value is infinity.<br/>
	/// <br/>
	/// @param x double-precision floating point value.<br/>
	/// @returns non-zero if the value is infinity, 0 otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_isinff
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isinf")]
	public static partial int SDL_isinf(double x);

	/// <summary>
	/// Return whether the value is infinity.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns non-zero if the value is infinity, 0 otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_isinf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isinff")]
	public static partial int SDL_isinff(float x);

	/// <summary>
	/// Return whether the value is NaN.<br/>
	/// <br/>
	/// @param x double-precision floating point value.<br/>
	/// @returns non-zero if the value is NaN, 0 otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_isnanf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isnan")]
	public static partial int SDL_isnan(double x);

	/// <summary>
	/// Return whether the value is NaN.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns non-zero if the value is NaN, 0 otherwise.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_isnan
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_isnanf")]
	public static partial int SDL_isnanf(float x);

	/// <summary>
	/// Compute the natural logarithm of `x`.<br/>
	/// Domain: `0<br/>
	/// <<br/>
	/// x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// It is an error for `x` to be less than or equal to 0.<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_logf for single-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value. Must be greater than 0.<br/>
	/// @returns the natural logarithm of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_logf<br/>
	/// @sa SDL_log10<br/>
	/// @sa SDL_exp
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_log")]
	public static partial double SDL_log(double x);

	/// <summary>
	/// Compute the natural logarithm of `x`.<br/>
	/// Domain: `0<br/>
	/// <<br/>
	/// x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// It is an error for `x` to be less than or equal to 0.<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_log for double-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value. Must be greater than 0.<br/>
	/// @returns the natural logarithm of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_log<br/>
	/// @sa SDL_expf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_logf")]
	public static partial float SDL_logf(float x);

	/// <summary>
	/// Compute the base-10 logarithm of `x`.<br/>
	/// Domain: `0<br/>
	/// <<br/>
	/// x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// It is an error for `x` to be less than or equal to 0.<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_log10f for single-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value. Must be greater than 0.<br/>
	/// @returns the logarithm of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_log10f<br/>
	/// @sa SDL_log<br/>
	/// @sa SDL_pow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_log10")]
	public static partial double SDL_log10(double x);

	/// <summary>
	/// Compute the base-10 logarithm of `x`.<br/>
	/// Domain: `0<br/>
	/// <<br/>
	/// x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// It is an error for `x` to be less than or equal to 0.<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_log10 for double-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value. Must be greater than 0.<br/>
	/// @returns the logarithm of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_log10<br/>
	/// @sa SDL_logf<br/>
	/// @sa SDL_powf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_log10f")]
	public static partial float SDL_log10f(float x);

	/// <summary>
	/// Split `x` into integer and fractional parts<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_modff for single-precision floats.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @param y output pointer to store the integer part of `x`.<br/>
	/// @returns the fractional part of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_modff<br/>
	/// @sa SDL_trunc<br/>
	/// @sa SDL_fmod
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_modf")]
	public static partial double SDL_modf(double x, double* y);

	/// <summary>
	/// Split `x` into integer and fractional parts<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_modf for double-precision floats.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @param y output pointer to store the integer part of `x`.<br/>
	/// @returns the fractional part of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_modf<br/>
	/// @sa SDL_truncf<br/>
	/// @sa SDL_fmodf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_modff")]
	public static partial float SDL_modff(float x, float* y);

	/// <summary>
	/// Raise `x` to the power `y`<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`, `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = z<br/>
	/// <<br/>
	/// = INF`<br/>
	/// If `y` is the base of the natural logarithm (e), consider using SDL_exp<br/>
	/// instead.<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_powf for single-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x the base.<br/>
	/// @param y the exponent.<br/>
	/// @returns `x` raised to the power `y`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_powf<br/>
	/// @sa SDL_exp<br/>
	/// @sa SDL_log
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_pow")]
	public static partial double SDL_pow(double x, double y);

	/// <summary>
	/// Raise `x` to the power `y`<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`, `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = z<br/>
	/// <<br/>
	/// = INF`<br/>
	/// If `y` is the base of the natural logarithm (e), consider using SDL_exp<br/>
	/// instead.<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_powf for double-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x the base.<br/>
	/// @param y the exponent.<br/>
	/// @returns `x` raised to the power `y`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_pow<br/>
	/// @sa SDL_expf<br/>
	/// @sa SDL_logf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_powf")]
	public static partial float SDL_powf(float x, float y);

	/// <summary>
	/// Round `x` to the nearest integer.<br/>
	/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
	/// rounded away from zero.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`, y integer<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_roundf for single-precision floats. To get the result as an integer<br/>
	/// type, use SDL_lround.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns the nearest integer to `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_roundf<br/>
	/// @sa SDL_lround<br/>
	/// @sa SDL_floor<br/>
	/// @sa SDL_ceil<br/>
	/// @sa SDL_trunc
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_round")]
	public static partial double SDL_round(double x);

	/// <summary>
	/// Round `x` to the nearest integer.<br/>
	/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
	/// rounded away from zero.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`, y integer<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_roundf for single-precision floats. To get the result as an integer<br/>
	/// type, use SDL_lroundf.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns the nearest integer to `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_round<br/>
	/// @sa SDL_lroundf<br/>
	/// @sa SDL_floorf<br/>
	/// @sa SDL_ceilf<br/>
	/// @sa SDL_truncf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_roundf")]
	public static partial float SDL_roundf(float x);

	/// <summary>
	/// Round `x` to the nearest integer representable as a long<br/>
	/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
	/// rounded away from zero.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `MIN_LONG<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = MAX_LONG`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_lround for single-precision floats. To get the result as a<br/>
	/// floating-point type, use SDL_round.<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns the nearest integer to `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_lroundf<br/>
	/// @sa SDL_round<br/>
	/// @sa SDL_floor<br/>
	/// @sa SDL_ceil<br/>
	/// @sa SDL_trunc
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_lround")]
	public static partial global::System.Runtime.InteropServices.CLong SDL_lround(double x);

	/// <summary>
	/// Round `x` to the nearest integer representable as a long<br/>
	/// Rounds `x` to the nearest integer. Values halfway between integers will be<br/>
	/// rounded away from zero.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `MIN_LONG<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = MAX_LONG`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_lroundf for double-precision floats. To get the result as a<br/>
	/// floating-point type, use SDL_roundf,<br/>
	/// <br/>
	/// @param x floating point value.<br/>
	/// @returns the nearest integer to `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_lround<br/>
	/// @sa SDL_roundf<br/>
	/// @sa SDL_floorf<br/>
	/// @sa SDL_ceilf<br/>
	/// @sa SDL_truncf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_lroundf")]
	public static partial global::System.Runtime.InteropServices.CLong SDL_lroundf(float x);

	/// <summary>
	/// Scale `x` by an integer power of two.<br/>
	/// Multiplies `x` by the `n`th power of the floating point radix (always 2).<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`, `n` integer<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_scalbnf for single-precision floats.<br/>
	/// <br/>
	/// @param x floating point value to be scaled.<br/>
	/// @param n integer exponent.<br/>
	/// @returns `x * 2^n`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_scalbnf<br/>
	/// @sa SDL_pow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_scalbn")]
	public static partial double SDL_scalbn(double x, int n);

	/// <summary>
	/// Scale `x` by an integer power of two.<br/>
	/// Multiplies `x` by the `n`th power of the floating point radix (always 2).<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`, `n` integer<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_scalbn for double-precision floats.<br/>
	/// <br/>
	/// @param x floating point value to be scaled.<br/>
	/// @param n integer exponent.<br/>
	/// @returns `x * 2^n`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_scalbn<br/>
	/// @sa SDL_powf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_scalbnf")]
	public static partial float SDL_scalbnf(float x, int n);

	/// <summary>
	/// Compute the sine of `x`.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-1<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = 1`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_sinf for single-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value, in radians.<br/>
	/// @returns sine of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_sinf<br/>
	/// @sa SDL_asin<br/>
	/// @sa SDL_cos
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_sin")]
	public static partial double SDL_sin(double x);

	/// <summary>
	/// Compute the sine of `x`.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-1<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = 1`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_sinf for double-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value, in radians.<br/>
	/// @returns sine of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_sin<br/>
	/// @sa SDL_asinf<br/>
	/// @sa SDL_cosf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_sinf")]
	public static partial float SDL_sinf(float x);

	/// <summary>
	/// Compute the square root of `x`.<br/>
	/// Domain: `0<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_sqrtf for single-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value. Must be greater than or equal to 0.<br/>
	/// @returns square root of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_sqrtf
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_sqrt")]
	public static partial double SDL_sqrt(double x);

	/// <summary>
	/// Compute the square root of `x`.<br/>
	/// Domain: `0<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_sqrt for double-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value. Must be greater than or equal to 0.<br/>
	/// @returns square root of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_sqrt
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_sqrtf")]
	public static partial float SDL_sqrtf(float x);

	/// <summary>
	/// Compute the tangent of `x`.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// This function operates on double-precision floating point values, use<br/>
	/// SDL_tanf for single-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value, in radians.<br/>
	/// @returns tangent of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_tanf<br/>
	/// @sa SDL_sin<br/>
	/// @sa SDL_cos<br/>
	/// @sa SDL_atan<br/>
	/// @sa SDL_atan2
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_tan")]
	public static partial double SDL_tan(double x);

	/// <summary>
	/// Compute the tangent of `x`.<br/>
	/// Domain: `-INF<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// = INF`<br/>
	/// Range: `-INF<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// = INF`<br/>
	/// This function operates on single-precision floating point values, use<br/>
	/// SDL_tanf for double-precision floats.<br/>
	/// This function may use a different approximation across different versions,<br/>
	/// platforms and configurations. i.e, it can return a different value given<br/>
	/// the same input on different machines or operating systems, or if SDL is<br/>
	/// updated.<br/>
	/// <br/>
	/// @param x floating point value, in radians.<br/>
	/// @returns tangent of `x`.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_tan<br/>
	/// @sa SDL_sinf<br/>
	/// @sa SDL_cosf<br/>
	/// @sa SDL_atanf<br/>
	/// @sa SDL_atan2f
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_tanf")]
	public static partial float SDL_tanf(float x);

	/// <summary>
	/// This function allocates a context for the specified character set<br/>
	/// conversion.<br/>
	/// <br/>
	/// @param tocode The target character encoding, must not be NULL.<br/>
	/// @param fromcode The source character encoding, must not be NULL.<br/>
	/// @returns a handle that must be freed with SDL_iconv_close, or<br/>
	/// SDL_ICONV_ERROR on failure.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_iconv<br/>
	/// @sa SDL_iconv_close<br/>
	/// @sa SDL_iconv_string
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_iconv_open")]
	public static partial SDL_iconv_data_t SDL_iconv_open(byte* tocode, byte* fromcode);

	[LibraryImport(LibName, EntryPoint = "SDL_iconv_open")]
	public static partial SDL_iconv_data_t SDL_iconv_open(ReadOnlySpan<byte> tocode, ReadOnlySpan<byte> fromcode);

	[LibraryImport(LibName, EntryPoint = "SDL_iconv_open")]
	public static partial SDL_iconv_data_t SDL_iconv_open([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> tocode, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fromcode);

	/// <summary>
	/// This function frees a context used for character set conversion.<br/>
	/// <br/>
	/// @param cd The character set conversion handle.<br/>
	/// @returns 0 on success, or -1 on failure.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_iconv<br/>
	/// @sa SDL_iconv_open<br/>
	/// @sa SDL_iconv_string
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_iconv_close")]
	public static partial int SDL_iconv_close(SDL_iconv_data_t cd);

	/// <summary>
	/// This function converts text between encodings, reading from and writing to<br/>
	/// a buffer.<br/>
	/// It returns the number of succesful conversions.<br/>
	/// <br/>
	/// @param cd The character set conversion context, created in<br/>
	/// SDL_iconv_open().<br/>
	/// @param inbuf Address of variable that points to the first character of the<br/>
	/// input sequence.<br/>
	/// @param inbytesleft The number of bytes in the input buffer.<br/>
	/// @param outbuf Address of variable that points to the output buffer.<br/>
	/// @param outbytesleft The number of bytes in the output buffer.<br/>
	/// @returns the number of conversions on success, else SDL_ICONV_E2BIG is<br/>
	/// returned when the output buffer is too small, or SDL_ICONV_EILSEQ<br/>
	/// is returned when an invalid input sequence is encountered, or<br/>
	/// SDL_ICONV_EINVAL is returned when an incomplete input sequence is<br/>
	/// encountered.<br/>
	/// On exit:<br/>
	/// - inbuf will point to the beginning of the next multibyte<br/>
	/// sequence. On error, this is the location of the problematic<br/>
	/// input sequence. On success, this is the end of the input<br/>
	/// sequence. - inbytesleft will be set to the number of bytes left<br/>
	/// to convert, which will be 0 on success. - outbuf will point to<br/>
	/// the location where to store the next output byte. - outbytesleft<br/>
	/// will be set to the number of bytes left in the output buffer.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_iconv_open<br/>
	/// @sa SDL_iconv_close<br/>
	/// @sa SDL_iconv_string
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_iconv")]
	public static partial nuint SDL_iconv(SDL_iconv_data_t cd, byte** inbuf, nuint* inbytesleft, byte** outbuf, nuint* outbytesleft);

	/// <summary>
	/// Helper function to convert a string's encoding in one call.<br/>
	/// This function converts a buffer or string between encodings in one pass.<br/>
	/// The string does not need to be NULL-terminated; this function operates on<br/>
	/// the number of bytes specified in `inbytesleft` whether there is a NULL<br/>
	/// character anywhere in the buffer.<br/>
	/// The returned string is owned by the caller, and should be passed to<br/>
	/// SDL_free when no longer needed.<br/>
	/// <br/>
	/// @param tocode the character encoding of the output string. Examples are<br/>
	/// "UTF-8", "UCS-4", etc.<br/>
	/// @param fromcode the character encoding of data in `inbuf`.<br/>
	/// @param inbuf the string to convert to a different encoding.<br/>
	/// @param inbytesleft the size of the input string _in bytes_.<br/>
	/// @returns a new string, converted to the new encoding, or NULL on error.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_iconv_open<br/>
	/// @sa SDL_iconv_close<br/>
	/// @sa SDL_iconv
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_iconv_string")]
	public static partial byte* SDL_iconv_stringPtr(byte* tocode, byte* fromcode, byte* inbuf, nuint inbytesleft);

	public static string? SDL_iconv_string(byte* tocode, byte* fromcode, byte* inbuf, nuint inbytesleft)
	{
		byte* resultPtr = SDL_iconv_stringPtr(tocode, fromcode, inbuf, inbytesleft);
		string? result = ConvertToManaged(resultPtr);
		SDL_free(resultPtr);
		return result;
	}

	[LibraryImport(LibName, EntryPoint = "SDL_iconv_string")]
	public static partial byte* SDL_iconv_stringPtr(ReadOnlySpan<byte> tocode, ReadOnlySpan<byte> fromcode, ReadOnlySpan<byte> inbuf, nuint inbytesleft);

	[LibraryImport(LibName, EntryPoint = "SDL_iconv_string")]
	public static partial byte* SDL_iconv_stringPtr([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> tocode, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> fromcode, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> inbuf, nuint inbytesleft);

	/// <summary>
	/// Multiply two integers, checking for overflow.<br/>
	/// If `a * b` would overflow, return false.<br/>
	/// Otherwise store `a * b` via ret and return true.<br/>
	/// <br/>
	/// @param a the multiplicand.<br/>
	/// @param b the multiplier.<br/>
	/// @param ret on non-overflow output, stores the multiplication result, may<br/>
	/// not be NULL.<br/>
	/// @returns false on overflow, true if result is multiplied without overflow.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_size_mul_check_overflow")]
	public static partial SDLBool SDL_size_mul_check_overflow(nuint a, nuint b, nuint* ret);

	/// <summary>
	/// This needs to be wrapped in an inline rather than being a direct #define,<br/>
	/// because __builtin_mul_overflow() is type-generic, but we want to be<br/>
	/// consistent about interpreting a and b as size_t.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_size_mul_check_overflow_builtin")]
	public static partial SDLBool SDL_size_mul_check_overflow_builtin(nuint a, nuint b, nuint* ret);

	/// <summary>
	/// Add two integers, checking for overflow.<br/>
	/// If `a + b` would overflow, return -1.<br/>
	/// Otherwise store `a + b` via ret and return 0.<br/>
	/// <br/>
	/// @param a the first addend.<br/>
	/// @param b the second addend.<br/>
	/// @param ret on non-overflow output, stores the addition result, may not be<br/>
	/// NULL.<br/>
	/// @returns false on overflow, true if result is added without overflow.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_size_add_check_overflow")]
	public static partial SDLBool SDL_size_add_check_overflow(nuint a, nuint b, nuint* ret);

	/// <summary>
	/// This needs to be wrapped in an inline rather than being a direct #define,<br/>
	/// the same as the call to __builtin_mul_overflow() above.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_size_add_check_overflow_builtin")]
	public static partial SDLBool SDL_size_add_check_overflow_builtin(nuint a, nuint b, nuint* ret);

	/// <summary>
	/// Opens up a read-only container for the application's filesystem.<br/>
	/// <br/>
	/// @param override a path to override the backend's default title root.<br/>
	/// @param props a property list that may contain backend-specific information.<br/>
	/// @returns a title storage container on success or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseStorage<br/>
	/// @sa SDL_GetStorageFileSize<br/>
	/// @sa SDL_OpenUserStorage<br/>
	/// @sa SDL_ReadStorageFile
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenTitleStorage")]
	public static partial SDL_Storage SDL_OpenTitleStorage(byte* @override, SDL_PropertiesID props);

	[LibraryImport(LibName, EntryPoint = "SDL_OpenTitleStorage")]
	public static partial SDL_Storage SDL_OpenTitleStorage(ReadOnlySpan<byte> @override, SDL_PropertiesID props);

	[LibraryImport(LibName, EntryPoint = "SDL_OpenTitleStorage")]
	public static partial SDL_Storage SDL_OpenTitleStorage([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> @override, SDL_PropertiesID props);

	/// <summary>
	/// Opens up a container for a user's unique read/write filesystem.<br/>
	/// While title storage can generally be kept open throughout runtime, user<br/>
	/// storage should only be opened when the client is ready to read/write files.<br/>
	/// This allows the backend to properly batch file operations and flush them<br/>
	/// when the container has been closed; ensuring safe and optimal save I/O.<br/>
	/// <br/>
	/// @param org the name of your organization.<br/>
	/// @param app the name of your application.<br/>
	/// @param props a property list that may contain backend-specific information.<br/>
	/// @returns a user storage container on success or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseStorage<br/>
	/// @sa SDL_GetStorageFileSize<br/>
	/// @sa SDL_GetStorageSpaceRemaining<br/>
	/// @sa SDL_OpenTitleStorage<br/>
	/// @sa SDL_ReadStorageFile<br/>
	/// @sa SDL_StorageReady<br/>
	/// @sa SDL_WriteStorageFile
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenUserStorage")]
	public static partial SDL_Storage SDL_OpenUserStorage(byte* org, byte* app, SDL_PropertiesID props);

	[LibraryImport(LibName, EntryPoint = "SDL_OpenUserStorage")]
	public static partial SDL_Storage SDL_OpenUserStorage(ReadOnlySpan<byte> org, ReadOnlySpan<byte> app, SDL_PropertiesID props);

	[LibraryImport(LibName, EntryPoint = "SDL_OpenUserStorage")]
	public static partial SDL_Storage SDL_OpenUserStorage([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> org, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> app, SDL_PropertiesID props);

	/// <summary>
	/// Opens up a container for local filesystem storage.<br/>
	/// This is provided for development and tools. Portable applications should<br/>
	/// use SDL_OpenTitleStorage() for access to game data and<br/>
	/// SDL_OpenUserStorage() for access to user data.<br/>
	/// <br/>
	/// @param path the base path prepended to all storage paths, or NULL for no<br/>
	/// base path.<br/>
	/// @returns a filesystem storage container on success or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseStorage<br/>
	/// @sa SDL_GetStorageFileSize<br/>
	/// @sa SDL_GetStorageSpaceRemaining<br/>
	/// @sa SDL_OpenTitleStorage<br/>
	/// @sa SDL_OpenUserStorage<br/>
	/// @sa SDL_ReadStorageFile<br/>
	/// @sa SDL_WriteStorageFile
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenFileStorage")]
	public static partial SDL_Storage SDL_OpenFileStorage(byte* path);

	[LibraryImport(LibName, EntryPoint = "SDL_OpenFileStorage")]
	public static partial SDL_Storage SDL_OpenFileStorage(ReadOnlySpan<byte> path);

	[LibraryImport(LibName, EntryPoint = "SDL_OpenFileStorage")]
	public static partial SDL_Storage SDL_OpenFileStorage([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);

	/// <summary>
	/// Opens up a container using a client-provided storage interface.<br/>
	/// Applications do not need to use this function unless they are providing<br/>
	/// their own SDL_Storage implementation. If you just need an SDL_Storage, you<br/>
	/// should use the built-in implementations in SDL, like SDL_OpenTitleStorage()<br/>
	/// or SDL_OpenUserStorage().<br/>
	/// This function makes a copy of `iface` and the caller does not need to keep<br/>
	/// it around after this call.<br/>
	/// <br/>
	/// @param iface the interface that implements this storage, initialized using<br/>
	/// SDL_INIT_INTERFACE().<br/>
	/// @param userdata the pointer that will be passed to the interface functions.<br/>
	/// @returns a storage container on success or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CloseStorage<br/>
	/// @sa SDL_GetStorageFileSize<br/>
	/// @sa SDL_GetStorageSpaceRemaining<br/>
	/// @sa SDL_INIT_INTERFACE<br/>
	/// @sa SDL_ReadStorageFile<br/>
	/// @sa SDL_StorageReady<br/>
	/// @sa SDL_WriteStorageFile
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OpenStorage")]
	public static partial SDL_Storage SDL_OpenStorage(SDL_StorageInterface* iface, nint userdata);

	/// <summary>
	/// Closes and frees a storage container.<br/>
	/// <br/>
	/// @param storage a storage container to close.<br/>
	/// @returns true if the container was freed with no errors, false otherwise;<br/>
	/// call SDL_GetError() for more information. Even if the function<br/>
	/// returns an error, the container data will be freed; the error is<br/>
	/// only for informational purposes.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_OpenFileStorage<br/>
	/// @sa SDL_OpenStorage<br/>
	/// @sa SDL_OpenTitleStorage<br/>
	/// @sa SDL_OpenUserStorage
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CloseStorage")]
	public static partial SDLBool SDL_CloseStorage(SDL_Storage storage);

	/// <summary>
	/// Checks if the storage container is ready to use.<br/>
	/// This function should be called in regular intervals until it returns true -<br/>
	/// however, it is not recommended to spinwait on this call, as the backend may<br/>
	/// depend on a synchronous message loop.<br/>
	/// <br/>
	/// @param storage a storage container to query.<br/>
	/// @returns true if the container is ready, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_StorageReady")]
	public static partial SDLBool SDL_StorageReady(SDL_Storage storage);

	/// <summary>
	/// Query the size of a file within a storage container.<br/>
	/// <br/>
	/// @param storage a storage container to query.<br/>
	/// @param path the relative path of the file to query.<br/>
	/// @param length a pointer to be filled with the file's length.<br/>
	/// @returns true if the file could be queried or false on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ReadStorageFile<br/>
	/// @sa SDL_StorageReady
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetStorageFileSize")]
	public static partial SDLBool SDL_GetStorageFileSize(SDL_Storage storage, byte* path, ulong* length);

	[LibraryImport(LibName, EntryPoint = "SDL_GetStorageFileSize")]
	public static partial SDLBool SDL_GetStorageFileSize(SDL_Storage storage, ReadOnlySpan<byte> path, ulong* length);

	[LibraryImport(LibName, EntryPoint = "SDL_GetStorageFileSize")]
	public static partial SDLBool SDL_GetStorageFileSize(SDL_Storage storage, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, ulong* length);

	/// <summary>
	/// Synchronously read a file from a storage container into a client-provided<br/>
	/// buffer.<br/>
	/// <br/>
	/// @param storage a storage container to read from.<br/>
	/// @param path the relative path of the file to read.<br/>
	/// @param destination a client-provided buffer to read the file into.<br/>
	/// @param length the length of the destination buffer.<br/>
	/// @returns true if the file was read or false on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetStorageFileSize<br/>
	/// @sa SDL_StorageReady<br/>
	/// @sa SDL_WriteStorageFile
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadStorageFile")]
	public static partial SDLBool SDL_ReadStorageFile(SDL_Storage storage, byte* path, nint destination, ulong length);

	[LibraryImport(LibName, EntryPoint = "SDL_ReadStorageFile")]
	public static partial SDLBool SDL_ReadStorageFile(SDL_Storage storage, ReadOnlySpan<byte> path, nint destination, ulong length);

	[LibraryImport(LibName, EntryPoint = "SDL_ReadStorageFile")]
	public static partial SDLBool SDL_ReadStorageFile(SDL_Storage storage, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, nint destination, ulong length);

	/// <summary>
	/// Synchronously write a file from client memory into a storage container.<br/>
	/// <br/>
	/// @param storage a storage container to write to.<br/>
	/// @param path the relative path of the file to write.<br/>
	/// @param source a client-provided buffer to write from.<br/>
	/// @param length the length of the source buffer.<br/>
	/// @returns true if the file was written or false on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetStorageSpaceRemaining<br/>
	/// @sa SDL_ReadStorageFile<br/>
	/// @sa SDL_StorageReady
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteStorageFile")]
	public static partial SDLBool SDL_WriteStorageFile(SDL_Storage storage, byte* path, nint source, ulong length);

	[LibraryImport(LibName, EntryPoint = "SDL_WriteStorageFile")]
	public static partial SDLBool SDL_WriteStorageFile(SDL_Storage storage, ReadOnlySpan<byte> path, nint source, ulong length);

	[LibraryImport(LibName, EntryPoint = "SDL_WriteStorageFile")]
	public static partial SDLBool SDL_WriteStorageFile(SDL_Storage storage, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, nint source, ulong length);

	/// <summary>
	/// Create a directory in a writable storage container.<br/>
	/// <br/>
	/// @param storage a storage container.<br/>
	/// @param path the path of the directory to create.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StorageReady
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateStorageDirectory")]
	public static partial SDLBool SDL_CreateStorageDirectory(SDL_Storage storage, byte* path);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateStorageDirectory")]
	public static partial SDLBool SDL_CreateStorageDirectory(SDL_Storage storage, ReadOnlySpan<byte> path);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateStorageDirectory")]
	public static partial SDLBool SDL_CreateStorageDirectory(SDL_Storage storage, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);

	/// <summary>
	/// Enumerate a directory in a storage container through a callback function.<br/>
	/// This function provides every directory entry through an app-provided<br/>
	/// callback, called once for each directory entry, until all results have been<br/>
	/// provided or the callback returns<br/>
	/// <<br/>
	/// = 0.<br/>
	/// This will return false if there was a system problem in general, or if a<br/>
	/// callback returns -1. A successful return means a callback returned 1 to<br/>
	/// halt enumeration, or all directory entries were enumerated.<br/>
	/// <br/>
	/// @param storage a storage container.<br/>
	/// @param path the path of the directory to enumerate.<br/>
	/// @param callback a function that is called for each entry in the directory.<br/>
	/// @param userdata a pointer that is passed to `callback`.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StorageReady
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EnumerateStorageDirectory")]
	public static partial SDLBool SDL_EnumerateStorageDirectory(SDL_Storage storage, byte* path, delegate* unmanaged[Cdecl]<nint, byte*, byte*, SDL_EnumerationResult> callback, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_EnumerateStorageDirectory")]
	public static partial SDLBool SDL_EnumerateStorageDirectory(SDL_Storage storage, ReadOnlySpan<byte> path, delegate* unmanaged[Cdecl]<nint, byte*, byte*, SDL_EnumerationResult> callback, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_EnumerateStorageDirectory")]
	public static partial SDLBool SDL_EnumerateStorageDirectory(SDL_Storage storage, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, delegate* unmanaged[Cdecl]<nint, byte*, byte*, SDL_EnumerationResult> callback, nint userdata);

	/// <summary>
	/// Remove a file or an empty directory in a writable storage container.<br/>
	/// <br/>
	/// @param storage a storage container.<br/>
	/// @param path the path of the directory to enumerate.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StorageReady
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RemoveStoragePath")]
	public static partial SDLBool SDL_RemoveStoragePath(SDL_Storage storage, byte* path);

	[LibraryImport(LibName, EntryPoint = "SDL_RemoveStoragePath")]
	public static partial SDLBool SDL_RemoveStoragePath(SDL_Storage storage, ReadOnlySpan<byte> path);

	[LibraryImport(LibName, EntryPoint = "SDL_RemoveStoragePath")]
	public static partial SDLBool SDL_RemoveStoragePath(SDL_Storage storage, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);

	/// <summary>
	/// Rename a file or directory in a writable storage container.<br/>
	/// <br/>
	/// @param storage a storage container.<br/>
	/// @param oldpath the old path.<br/>
	/// @param newpath the new path.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StorageReady
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RenameStoragePath")]
	public static partial SDLBool SDL_RenameStoragePath(SDL_Storage storage, byte* oldpath, byte* newpath);

	[LibraryImport(LibName, EntryPoint = "SDL_RenameStoragePath")]
	public static partial SDLBool SDL_RenameStoragePath(SDL_Storage storage, ReadOnlySpan<byte> oldpath, ReadOnlySpan<byte> newpath);

	[LibraryImport(LibName, EntryPoint = "SDL_RenameStoragePath")]
	public static partial SDLBool SDL_RenameStoragePath(SDL_Storage storage, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> oldpath, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> newpath);

	/// <summary>
	/// Copy a file in a writable storage container.<br/>
	/// <br/>
	/// @param storage a storage container.<br/>
	/// @param oldpath the old path.<br/>
	/// @param newpath the new path.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StorageReady
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CopyStorageFile")]
	public static partial SDLBool SDL_CopyStorageFile(SDL_Storage storage, byte* oldpath, byte* newpath);

	[LibraryImport(LibName, EntryPoint = "SDL_CopyStorageFile")]
	public static partial SDLBool SDL_CopyStorageFile(SDL_Storage storage, ReadOnlySpan<byte> oldpath, ReadOnlySpan<byte> newpath);

	[LibraryImport(LibName, EntryPoint = "SDL_CopyStorageFile")]
	public static partial SDLBool SDL_CopyStorageFile(SDL_Storage storage, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> oldpath, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> newpath);

	/// <summary>
	/// Get information about a filesystem path in a storage container.<br/>
	/// <br/>
	/// @param storage a storage container.<br/>
	/// @param path the path to query.<br/>
	/// @param info a pointer filled in with information about the path, or NULL to<br/>
	/// check for the existence of a file.<br/>
	/// @returns true on success or false if the file doesn't exist, or another<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StorageReady
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetStoragePathInfo")]
	public static partial SDLBool SDL_GetStoragePathInfo(SDL_Storage storage, byte* path, SDL_PathInfo* info);

	[LibraryImport(LibName, EntryPoint = "SDL_GetStoragePathInfo")]
	public static partial SDLBool SDL_GetStoragePathInfo(SDL_Storage storage, ReadOnlySpan<byte> path, SDL_PathInfo* info);

	[LibraryImport(LibName, EntryPoint = "SDL_GetStoragePathInfo")]
	public static partial SDLBool SDL_GetStoragePathInfo(SDL_Storage storage, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, SDL_PathInfo* info);

	/// <summary>
	/// Queries the remaining space in a storage container.<br/>
	/// <br/>
	/// @param storage a storage container to query.<br/>
	/// @returns the amount of remaining space, in bytes.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_StorageReady<br/>
	/// @sa SDL_WriteStorageFile
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetStorageSpaceRemaining")]
	public static partial ulong SDL_GetStorageSpaceRemaining(SDL_Storage storage);

	/// <summary>
	/// Enumerate a directory tree, filtered by pattern, and return a list.<br/>
	/// Files are filtered out if they don't match the string in `pattern`, which<br/>
	/// may contain wildcard characters '*' (match everything) and '?' (match one<br/>
	/// character). If pattern is NULL, no filtering is done and all results are<br/>
	/// returned. Subdirectories are permitted, and are specified with a path<br/>
	/// separator of '/'. Wildcard characters '*' and '?' never match a path<br/>
	/// separator.<br/>
	/// `flags` may be set to SDL_GLOB_CASEINSENSITIVE to make the pattern matching<br/>
	/// case-insensitive.<br/>
	/// The returned array is always NULL-terminated, for your iterating<br/>
	/// convenience, but if `count` is non-NULL, on return it will contain the<br/>
	/// number of items in the array, not counting the NULL terminator.<br/>
	/// <br/>
	/// @param storage a storage container.<br/>
	/// @param path the path of the directory to enumerate.<br/>
	/// @param pattern the pattern that files in the directory must match. Can be<br/>
	/// NULL.<br/>
	/// @param flags `SDL_GLOB_*` bitflags that affect this search.<br/>
	/// @param count on return, will be set to the number of items in the returned<br/>
	/// array. Can be NULL.<br/>
	/// @returns an array of strings on success or NULL on failure; call<br/>
	/// SDL_GetError() for more information. The caller should pass the<br/>
	/// returned pointer to SDL_free when done with it. This is a single<br/>
	/// allocation that should be freed with SDL_free() when it is no<br/>
	/// longer needed.<br/>
	/// @threadsafety It is safe to call this function from any thread, assuming<br/>
	/// the `storage` object is thread-safe.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GlobStorageDirectory")]
	public static partial byte** SDL_GlobStorageDirectory(SDL_Storage storage, byte* path, byte* pattern, SDL_GlobFlags flags, int* count);

	[LibraryImport(LibName, EntryPoint = "SDL_GlobStorageDirectory")]
	public static partial byte** SDL_GlobStorageDirectory(SDL_Storage storage, ReadOnlySpan<byte> path, ReadOnlySpan<byte> pattern, SDL_GlobFlags flags, int* count);

	[LibraryImport(LibName, EntryPoint = "SDL_GlobStorageDirectory")]
	public static partial byte** SDL_GlobStorageDirectory(SDL_Storage storage, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> pattern, SDL_GlobFlags flags, int* count);

	/// <summary>
	/// Allocate a new surface with a specific pixel format.<br/>
	/// The pixels of the new surface are initialized to zero.<br/>
	/// <br/>
	/// @param width the width of the surface.<br/>
	/// @param height the height of the surface.<br/>
	/// @param format the SDL_PixelFormat for the new surface's pixel format.<br/>
	/// @returns the new SDL_Surface structure that is created or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateSurfaceFrom<br/>
	/// @sa SDL_DestroySurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateSurface")]
	public static partial SDL_Surface* SDL_CreateSurface(int width, int height, SDL_PixelFormat format);

	/// <summary>
	/// Allocate a new surface with a specific pixel format and existing pixel<br/>
	/// data.<br/>
	/// No copy is made of the pixel data. Pixel data is not managed automatically;<br/>
	/// you must free the surface before you free the pixel data.<br/>
	/// Pitch is the offset in bytes from one row of pixels to the next, e.g.<br/>
	/// `width*4` for `SDL_PIXELFORMAT_RGBA8888`.<br/>
	/// You may pass NULL for pixels and 0 for pitch to create a surface that you<br/>
	/// will fill in with valid values later.<br/>
	/// <br/>
	/// @param width the width of the surface.<br/>
	/// @param height the height of the surface.<br/>
	/// @param format the SDL_PixelFormat for the new surface's pixel format.<br/>
	/// @param pixels a pointer to existing pixel data.<br/>
	/// @param pitch the number of bytes between each row, including padding.<br/>
	/// @returns the new SDL_Surface structure that is created or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateSurface<br/>
	/// @sa SDL_DestroySurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateSurfaceFrom")]
	public static partial SDL_Surface* SDL_CreateSurfaceFrom(int width, int height, SDL_PixelFormat format, nint pixels, int pitch);

	/// <summary>
	/// Free a surface.<br/>
	/// It is safe to pass NULL to this function.<br/>
	/// <br/>
	/// @param surface the SDL_Surface to free.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateStackSurface<br/>
	/// @sa SDL_CreateSurface<br/>
	/// @sa SDL_CreateSurfaceFrom
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroySurface")]
	public static partial void SDL_DestroySurface(SDL_Surface* surface);

	/// <summary>
	/// Get the properties associated with a surface.<br/>
	/// The following properties are understood by SDL:<br/>
	/// - `SDL_PROP_SURFACE_SDR_WHITE_POINT_FLOAT`: for HDR10 and floating point<br/>
	/// surfaces, this defines the value of 100% diffuse white, with higher<br/>
	/// values being displayed in the High Dynamic Range headroom. This defaults<br/>
	/// to 203 for HDR10 surfaces and 1.0 for floating point surfaces.<br/>
	/// - `SDL_PROP_SURFACE_HDR_HEADROOM_FLOAT`: for HDR10 and floating point<br/>
	/// surfaces, this defines the maximum dynamic range used by the content, in<br/>
	/// terms of the SDR white point. This defaults to 0.0, which disables tone<br/>
	/// mapping.<br/>
	/// - `SDL_PROP_SURFACE_TONEMAP_OPERATOR_STRING`: the tone mapping operator<br/>
	/// used when compressing from a surface with high dynamic range to another<br/>
	/// with lower dynamic range. Currently this supports "chrome", which uses<br/>
	/// the same tone mapping that Chrome uses for HDR content, the form "*=N",<br/>
	/// where N is a floating point scale factor applied in linear space, and<br/>
	/// "none", which disables tone mapping. This defaults to "chrome".<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceProperties")]
	public static partial SDL_PropertiesID SDL_GetSurfaceProperties(SDL_Surface* surface);

	/// <summary>
	/// Set the colorspace used by a surface.<br/>
	/// Setting the colorspace doesn't change the pixels, only how they are<br/>
	/// interpreted in color operations.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to update.<br/>
	/// @param colorspace an SDL_ColorSpace value describing the surface<br/>
	/// colorspace.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetSurfaceColorspace
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceColorspace")]
	public static partial SDLBool SDL_SetSurfaceColorspace(SDL_Surface* surface, SDL_Colorspace colorspace);

	/// <summary>
	/// Get the colorspace used by a surface.<br/>
	/// The colorspace defaults to SDL_COLORSPACE_SRGB_LINEAR for floating point<br/>
	/// formats, SDL_COLORSPACE_HDR10 for 10-bit formats, SDL_COLORSPACE_SRGB for<br/>
	/// other RGB surfaces and SDL_COLORSPACE_BT709_FULL for YUV textures.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @returns the colorspace used by the surface, or SDL_COLORSPACE_UNKNOWN if<br/>
	/// the surface is NULL.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetSurfaceColorspace
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceColorspace")]
	public static partial SDL_Colorspace SDL_GetSurfaceColorspace(SDL_Surface* surface);

	/// <summary>
	/// Create a palette and associate it with a surface.<br/>
	/// This function creates a palette compatible with the provided surface. The<br/>
	/// palette is then returned for you to modify, and the surface will<br/>
	/// automatically use the new palette in future operations. You do not need to<br/>
	/// destroy the returned palette, it will be freed when the reference count<br/>
	/// reaches 0, usually when the surface is destroyed.<br/>
	/// Bitmap surfaces (with format SDL_PIXELFORMAT_INDEX1LSB or<br/>
	/// SDL_PIXELFORMAT_INDEX1MSB) will have the palette initialized with 0 as<br/>
	/// white and 1 as black. Other surfaces will get a palette initialized with<br/>
	/// white in every entry.<br/>
	/// If this function is called for a surface that already has a palette, a new<br/>
	/// palette will be created to replace it.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to update.<br/>
	/// @returns a new SDL_Palette structure on success or NULL on failure (e.g. if<br/>
	/// the surface didn't have an index format); call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetPaletteColors
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateSurfacePalette")]
	public static partial SDL_Palette* SDL_CreateSurfacePalette(SDL_Surface* surface);

	/// <summary>
	/// Set the palette used by a surface.<br/>
	/// A single palette can be shared with many surfaces.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to update.<br/>
	/// @param palette the SDL_Palette structure to use.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreatePalette<br/>
	/// @sa SDL_GetSurfacePalette
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetSurfacePalette")]
	public static partial SDLBool SDL_SetSurfacePalette(SDL_Surface* surface, SDL_Palette* palette);

	/// <summary>
	/// Get the palette used by a surface.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @returns a pointer to the palette used by the surface, or NULL if there is<br/>
	/// no palette used.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetSurfacePalette
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSurfacePalette")]
	public static partial SDL_Palette* SDL_GetSurfacePalette(SDL_Surface* surface);

	/// <summary>
	/// Add an alternate version of a surface.<br/>
	/// This function adds an alternate version of this surface, usually used for<br/>
	/// content with high DPI representations like cursors or icons. The size,<br/>
	/// format, and content do not need to match the original surface, and these<br/>
	/// alternate versions will not be updated when the original surface changes.<br/>
	/// This function adds a reference to the alternate version, so you should call<br/>
	/// SDL_DestroySurface() on the image after this call.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to update.<br/>
	/// @param image a pointer to an alternate SDL_Surface to associate with this<br/>
	/// surface.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_RemoveSurfaceAlternateImages<br/>
	/// @sa SDL_GetSurfaceImages<br/>
	/// @sa SDL_SurfaceHasAlternateImages
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AddSurfaceAlternateImage")]
	public static partial SDLBool SDL_AddSurfaceAlternateImage(SDL_Surface* surface, SDL_Surface* image);

	/// <summary>
	/// Return whether a surface has alternate versions available.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @returns true if alternate versions are available or true otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddSurfaceAlternateImage<br/>
	/// @sa SDL_RemoveSurfaceAlternateImages<br/>
	/// @sa SDL_GetSurfaceImages
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SurfaceHasAlternateImages")]
	public static partial SDLBool SDL_SurfaceHasAlternateImages(SDL_Surface* surface);

	/// <summary>
	/// Get an array including all versions of a surface.<br/>
	/// This returns all versions of a surface, with the surface being queried as<br/>
	/// the first element in the returned array.<br/>
	/// Freeing the array of surfaces does not affect the surfaces in the array.<br/>
	/// They are still referenced by the surface being queried and will be cleaned<br/>
	/// up normally.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @param count a pointer filled in with the number of surface pointers<br/>
	/// returned, may be NULL.<br/>
	/// @returns a NULL terminated array of SDL_Surface pointers or NULL on<br/>
	/// failure; call SDL_GetError() for more information. This should be<br/>
	/// freed with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddSurfaceAlternateImage<br/>
	/// @sa SDL_RemoveSurfaceAlternateImages<br/>
	/// @sa SDL_SurfaceHasAlternateImages
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceImages")]
	public static partial SDL_Surface** SDL_GetSurfaceImages(SDL_Surface* surface, out int count);

	/// <summary>
	/// Remove all alternate versions of a surface.<br/>
	/// This function removes a reference from all the alternative versions,<br/>
	/// destroying them if this is the last reference to them.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to update.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddSurfaceAlternateImage<br/>
	/// @sa SDL_GetSurfaceImages<br/>
	/// @sa SDL_SurfaceHasAlternateImages
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RemoveSurfaceAlternateImages")]
	public static partial void SDL_RemoveSurfaceAlternateImages(SDL_Surface* surface);

	/// <summary>
	/// Set up a surface for directly accessing the pixels.<br/>
	/// Between calls to SDL_LockSurface() / SDL_UnlockSurface(), you can write to<br/>
	/// and read from `surface->pixels`, using the pixel format stored in<br/>
	/// `surface->format`. Once you are done accessing the surface, you should use<br/>
	/// SDL_UnlockSurface() to release it.<br/>
	/// Not all surfaces require locking. If `SDL_MUSTLOCK(surface)` evaluates to<br/>
	/// 0, then you can read and write to the surface at any time, and the pixel<br/>
	/// format of the surface will not change.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to be locked.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_MUSTLOCK<br/>
	/// @sa SDL_UnlockSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LockSurface")]
	public static partial SDLBool SDL_LockSurface(SDL_Surface* surface);

	/// <summary>
	/// Release a surface after directly accessing the pixels.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to be unlocked.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LockSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnlockSurface")]
	public static partial void SDL_UnlockSurface(SDL_Surface* surface);

	/// <summary>
	/// Load a BMP image from a seekable SDL data stream.<br/>
	/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
	/// will result in a memory leak.<br/>
	/// <br/>
	/// @param src the data stream for the surface.<br/>
	/// @param closeio if true, calls SDL_CloseIO() on `src` before returning, even<br/>
	/// in the case of an error.<br/>
	/// @returns a pointer to a new SDL_Surface structure or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroySurface<br/>
	/// @sa SDL_LoadBMP<br/>
	/// @sa SDL_SaveBMP_IO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LoadBMP_IO")]
	public static partial SDL_Surface* SDL_LoadBMP_IO(SDL_IOStream src, SDLBool closeio);

	/// <summary>
	/// Load a BMP image from a file.<br/>
	/// The new surface should be freed with SDL_DestroySurface(). Not doing so<br/>
	/// will result in a memory leak.<br/>
	/// <br/>
	/// @param file the BMP file to load.<br/>
	/// @returns a pointer to a new SDL_Surface structure or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroySurface<br/>
	/// @sa SDL_LoadBMP_IO<br/>
	/// @sa SDL_SaveBMP
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_LoadBMP")]
	public static partial SDL_Surface* SDL_LoadBMP(byte* file);

	[LibraryImport(LibName, EntryPoint = "SDL_LoadBMP")]
	public static partial SDL_Surface* SDL_LoadBMP(ReadOnlySpan<byte> file);

	[LibraryImport(LibName, EntryPoint = "SDL_LoadBMP")]
	public static partial SDL_Surface* SDL_LoadBMP([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> file);

	/// <summary>
	/// Save a surface to a seekable SDL data stream in BMP format.<br/>
	/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
	/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
	/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
	/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
	/// not supported.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure containing the image to be saved.<br/>
	/// @param dst a data stream to save to.<br/>
	/// @param closeio if true, calls SDL_CloseIO() on `dst` before returning, even<br/>
	/// in the case of an error.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LoadBMP_IO<br/>
	/// @sa SDL_SaveBMP
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SaveBMP_IO")]
	public static partial SDLBool SDL_SaveBMP_IO(SDL_Surface* surface, SDL_IOStream dst, SDLBool closeio);

	/// <summary>
	/// Save a surface to a file.<br/>
	/// Surfaces with a 24-bit, 32-bit and paletted 8-bit format get saved in the<br/>
	/// BMP directly. Other RGB formats with 8-bit or higher get converted to a<br/>
	/// 24-bit surface or, if they have an alpha mask or a colorkey, to a 32-bit<br/>
	/// surface before they are saved. YUV and paletted 1-bit and 4-bit formats are<br/>
	/// not supported.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure containing the image to be saved.<br/>
	/// @param file a file to save to.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_LoadBMP<br/>
	/// @sa SDL_SaveBMP_IO
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SaveBMP")]
	public static partial SDLBool SDL_SaveBMP(SDL_Surface* surface, byte* file);

	[LibraryImport(LibName, EntryPoint = "SDL_SaveBMP")]
	public static partial SDLBool SDL_SaveBMP(SDL_Surface* surface, ReadOnlySpan<byte> file);

	[LibraryImport(LibName, EntryPoint = "SDL_SaveBMP")]
	public static partial SDLBool SDL_SaveBMP(SDL_Surface* surface, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> file);

	/// <summary>
	/// Set the RLE acceleration hint for a surface.<br/>
	/// If RLE is enabled, color key and alpha blending blits are much faster, but<br/>
	/// the surface must be locked before directly accessing the pixels.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to optimize.<br/>
	/// @param enabled true to enable RLE acceleration, false to disable it.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BlitSurface<br/>
	/// @sa SDL_LockSurface<br/>
	/// @sa SDL_UnlockSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceRLE")]
	public static partial SDLBool SDL_SetSurfaceRLE(SDL_Surface* surface, SDLBool enabled);

	/// <summary>
	/// Returns whether the surface is RLE enabled.<br/>
	/// It is safe to pass a NULL `surface` here; it will return false.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @returns true if the surface is RLE enabled, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetSurfaceRLE
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SurfaceHasRLE")]
	public static partial SDLBool SDL_SurfaceHasRLE(SDL_Surface* surface);

	/// <summary>
	/// Set the color key (transparent pixel) in a surface.<br/>
	/// The color key defines a pixel value that will be treated as transparent in<br/>
	/// a blit. For example, one can use this to specify that cyan pixels should be<br/>
	/// considered transparent, and therefore not rendered.<br/>
	/// It is a pixel of the format used by the surface, as generated by<br/>
	/// SDL_MapRGB().<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to update.<br/>
	/// @param enabled true to enable color key, false to disable color key.<br/>
	/// @param key the transparent pixel.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetSurfaceColorKey<br/>
	/// @sa SDL_SetSurfaceRLE<br/>
	/// @sa SDL_SurfaceHasColorKey
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceColorKey")]
	public static partial SDLBool SDL_SetSurfaceColorKey(SDL_Surface* surface, SDLBool enabled, uint key);

	/// <summary>
	/// Returns whether the surface has a color key.<br/>
	/// It is safe to pass a NULL `surface` here; it will return false.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @returns true if the surface has a color key, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetSurfaceColorKey<br/>
	/// @sa SDL_GetSurfaceColorKey
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SurfaceHasColorKey")]
	public static partial SDLBool SDL_SurfaceHasColorKey(SDL_Surface* surface);

	/// <summary>
	/// Get the color key (transparent pixel) for a surface.<br/>
	/// The color key is a pixel of the format used by the surface, as generated by<br/>
	/// SDL_MapRGB().<br/>
	/// If the surface doesn't have color key enabled this function returns false.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @param key a pointer filled in with the transparent pixel.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetSurfaceColorKey<br/>
	/// @sa SDL_SurfaceHasColorKey
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceColorKey")]
	public static partial SDLBool SDL_GetSurfaceColorKey(SDL_Surface* surface, uint* key);

	/// <summary>
	/// Set an additional color value multiplied into blit operations.<br/>
	/// When this surface is blitted, during the blit operation each source color<br/>
	/// channel is modulated by the appropriate color value according to the<br/>
	/// following formula:<br/>
	/// `srcC = srcC * (color / 255)`<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to update.<br/>
	/// @param r the red color value multiplied into blit operations.<br/>
	/// @param g the green color value multiplied into blit operations.<br/>
	/// @param b the blue color value multiplied into blit operations.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetSurfaceColorMod<br/>
	/// @sa SDL_SetSurfaceAlphaMod
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceColorMod")]
	public static partial SDLBool SDL_SetSurfaceColorMod(SDL_Surface* surface, byte r, byte g, byte b);

	/// <summary>
	/// Get the additional color value multiplied into blit operations.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @param r a pointer filled in with the current red color value.<br/>
	/// @param g a pointer filled in with the current green color value.<br/>
	/// @param b a pointer filled in with the current blue color value.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetSurfaceAlphaMod<br/>
	/// @sa SDL_SetSurfaceColorMod
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceColorMod")]
	public static partial SDLBool SDL_GetSurfaceColorMod(SDL_Surface* surface, byte* r, byte* g, byte* b);

	/// <summary>
	/// Set an additional alpha value used in blit operations.<br/>
	/// When this surface is blitted, during the blit operation the source alpha<br/>
	/// value is modulated by this alpha value according to the following formula:<br/>
	/// `srcA = srcA * (alpha / 255)`<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to update.<br/>
	/// @param alpha the alpha value multiplied into blit operations.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetSurfaceAlphaMod<br/>
	/// @sa SDL_SetSurfaceColorMod
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceAlphaMod")]
	public static partial SDLBool SDL_SetSurfaceAlphaMod(SDL_Surface* surface, byte alpha);

	/// <summary>
	/// Get the additional alpha value used in blit operations.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @param alpha a pointer filled in with the current alpha value.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetSurfaceColorMod<br/>
	/// @sa SDL_SetSurfaceAlphaMod
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceAlphaMod")]
	public static partial SDLBool SDL_GetSurfaceAlphaMod(SDL_Surface* surface, byte* alpha);

	/// <summary>
	/// Set the blend mode used for blit operations.<br/>
	/// To copy a surface to another surface (or texture) without blending with the<br/>
	/// existing data, the blendmode of the SOURCE surface should be set to<br/>
	/// `SDL_BLENDMODE_NONE`.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to update.<br/>
	/// @param blendMode the SDL_BlendMode to use for blit blending.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetSurfaceBlendMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceBlendMode")]
	public static partial SDLBool SDL_SetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode blendMode);

	/// <summary>
	/// Get the blend mode used for blit operations.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to query.<br/>
	/// @param blendMode a pointer filled in with the current SDL_BlendMode.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetSurfaceBlendMode
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceBlendMode")]
	public static partial SDLBool SDL_GetSurfaceBlendMode(SDL_Surface* surface, SDL_BlendMode* blendMode);

	/// <summary>
	/// Set the clipping rectangle for a surface.<br/>
	/// When `surface` is the destination of a blit, only the area within the clip<br/>
	/// rectangle is drawn into.<br/>
	/// Note that blits are automatically clipped to the edges of the source and<br/>
	/// destination surfaces.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure to be clipped.<br/>
	/// @param rect the SDL_Rect structure representing the clipping rectangle, or<br/>
	/// NULL to disable clipping.<br/>
	/// @returns true if the rectangle intersects the surface, otherwise false and<br/>
	/// blits will be completely clipped.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetSurfaceClipRect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetSurfaceClipRect")]
	public static partial SDLBool SDL_SetSurfaceClipRect(SDL_Surface* surface, Rectangle* rect);

	/// <summary>
	/// Get the clipping rectangle for a surface.<br/>
	/// When `surface` is the destination of a blit, only the area within the clip<br/>
	/// rectangle is drawn into.<br/>
	/// <br/>
	/// @param surface the SDL_Surface structure representing the surface to be<br/>
	/// clipped.<br/>
	/// @param rect an SDL_Rect structure filled in with the clipping rectangle for<br/>
	/// the surface.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetSurfaceClipRect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSurfaceClipRect")]
	public static partial SDLBool SDL_GetSurfaceClipRect(SDL_Surface* surface, Rectangle* rect);

	/// <summary>
	/// Flip a surface vertically or horizontally.<br/>
	/// <br/>
	/// @param surface the surface to flip.<br/>
	/// @param flip the direction to flip.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_FlipSurface")]
	public static partial SDLBool SDL_FlipSurface(SDL_Surface* surface, SDL_FlipMode flip);

	/// <summary>
	/// Creates a new surface identical to the existing surface.<br/>
	/// If the original surface has alternate images, the new surface will have a<br/>
	/// reference to them as well.<br/>
	/// The returned surface should be freed with SDL_DestroySurface().<br/>
	/// <br/>
	/// @param surface the surface to duplicate.<br/>
	/// @returns a copy of the surface or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroySurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DuplicateSurface")]
	public static partial SDL_Surface* SDL_DuplicateSurface(SDL_Surface* surface);

	/// <summary>
	/// Creates a new surface identical to the existing surface, scaled to the<br/>
	/// desired size.<br/>
	/// The returned surface should be freed with SDL_DestroySurface().<br/>
	/// <br/>
	/// @param surface the surface to duplicate and scale.<br/>
	/// @param width the width of the new surface.<br/>
	/// @param height the height of the new surface.<br/>
	/// @param scaleMode the SDL_ScaleMode to be used.<br/>
	/// @returns a copy of the surface or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroySurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ScaleSurface")]
	public static partial SDL_Surface* SDL_ScaleSurface(SDL_Surface* surface, int width, int height, SDL_ScaleMode scaleMode);

	/// <summary>
	/// Copy an existing surface to a new surface of the specified format.<br/>
	/// This function is used to optimize images for faster *repeat* blitting. This<br/>
	/// is accomplished by converting the original and storing the result as a new<br/>
	/// surface. The new, optimized surface can then be used as the source for<br/>
	/// future blits, making them faster.<br/>
	/// If you are converting to an indexed surface and want to map colors to a<br/>
	/// palette, you can use SDL_ConvertSurfaceAndColorspace() instead.<br/>
	/// If the original surface has alternate images, the new surface will have a<br/>
	/// reference to them as well.<br/>
	/// <br/>
	/// @param surface the existing SDL_Surface structure to convert.<br/>
	/// @param format the new pixel format.<br/>
	/// @returns the new SDL_Surface structure that is created or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ConvertSurfaceAndColorspace<br/>
	/// @sa SDL_DestroySurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ConvertSurface")]
	public static partial SDL_Surface* SDL_ConvertSurface(SDL_Surface* surface, SDL_PixelFormat format);

	/// <summary>
	/// Copy an existing surface to a new surface of the specified format and<br/>
	/// colorspace.<br/>
	/// This function converts an existing surface to a new format and colorspace<br/>
	/// and returns the new surface. This will perform any pixel format and<br/>
	/// colorspace conversion needed.<br/>
	/// If the original surface has alternate images, the new surface will have a<br/>
	/// reference to them as well.<br/>
	/// <br/>
	/// @param surface the existing SDL_Surface structure to convert.<br/>
	/// @param format the new pixel format.<br/>
	/// @param palette an optional palette to use for indexed formats, may be NULL.<br/>
	/// @param colorspace the new colorspace.<br/>
	/// @param props an SDL_PropertiesID with additional color properties, or 0.<br/>
	/// @returns the new SDL_Surface structure that is created or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ConvertSurface<br/>
	/// @sa SDL_ConvertSurface<br/>
	/// @sa SDL_DestroySurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ConvertSurfaceAndColorspace")]
	public static partial SDL_Surface* SDL_ConvertSurfaceAndColorspace(SDL_Surface* surface, SDL_PixelFormat format, SDL_Palette* palette, SDL_Colorspace colorspace, SDL_PropertiesID props);

	/// <summary>
	/// Copy a block of pixels of one format to another format.<br/>
	/// <br/>
	/// @param width the width of the block to copy, in pixels.<br/>
	/// @param height the height of the block to copy, in pixels.<br/>
	/// @param src_format an SDL_PixelFormat value of the `src` pixels format.<br/>
	/// @param src a pointer to the source pixels.<br/>
	/// @param src_pitch the pitch of the source pixels, in bytes.<br/>
	/// @param dst_format an SDL_PixelFormat value of the `dst` pixels format.<br/>
	/// @param dst a pointer to be filled in with new pixel data.<br/>
	/// @param dst_pitch the pitch of the destination pixels, in bytes.<br/>
	/// @returns false on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ConvertPixelsAndColorspace
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ConvertPixels")]
	public static partial SDLBool SDL_ConvertPixels(int width, int height, SDL_PixelFormat src_format, nint src, int src_pitch, SDL_PixelFormat dst_format, nint dst, int dst_pitch);

	/// <summary>
	/// Copy a block of pixels of one format and colorspace to another format and<br/>
	/// colorspace.<br/>
	/// <br/>
	/// @param width the width of the block to copy, in pixels.<br/>
	/// @param height the height of the block to copy, in pixels.<br/>
	/// @param src_format an SDL_PixelFormat value of the `src` pixels format.<br/>
	/// @param src_colorspace an SDL_ColorSpace value describing the colorspace of<br/>
	/// the `src` pixels.<br/>
	/// @param src_properties an SDL_PropertiesID with additional source color<br/>
	/// properties, or 0.<br/>
	/// @param src a pointer to the source pixels.<br/>
	/// @param src_pitch the pitch of the source pixels, in bytes.<br/>
	/// @param dst_format an SDL_PixelFormat value of the `dst` pixels format.<br/>
	/// @param dst_colorspace an SDL_ColorSpace value describing the colorspace of<br/>
	/// the `dst` pixels.<br/>
	/// @param dst_properties an SDL_PropertiesID with additional destination color<br/>
	/// properties, or 0.<br/>
	/// @param dst a pointer to be filled in with new pixel data.<br/>
	/// @param dst_pitch the pitch of the destination pixels, in bytes.<br/>
	/// @returns false on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ConvertPixels
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ConvertPixelsAndColorspace")]
	public static partial SDLBool SDL_ConvertPixelsAndColorspace(int width, int height, SDL_PixelFormat src_format, SDL_Colorspace src_colorspace, SDL_PropertiesID src_properties, nint src, int src_pitch, SDL_PixelFormat dst_format, SDL_Colorspace dst_colorspace, SDL_PropertiesID dst_properties, nint dst, int dst_pitch);

	/// <summary>
	/// Premultiply the alpha on a block of pixels.<br/>
	/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
	/// <br/>
	/// @param width the width of the block to convert, in pixels.<br/>
	/// @param height the height of the block to convert, in pixels.<br/>
	/// @param src_format an SDL_PixelFormat value of the `src` pixels format.<br/>
	/// @param src a pointer to the source pixels.<br/>
	/// @param src_pitch the pitch of the source pixels, in bytes.<br/>
	/// @param dst_format an SDL_PixelFormat value of the `dst` pixels format.<br/>
	/// @param dst a pointer to be filled in with premultiplied pixel data.<br/>
	/// @param dst_pitch the pitch of the destination pixels, in bytes.<br/>
	/// @param linear true to convert from sRGB to linear space for the alpha<br/>
	/// multiplication, false to do multiplication in sRGB space.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PremultiplyAlpha")]
	public static partial SDLBool SDL_PremultiplyAlpha(int width, int height, SDL_PixelFormat src_format, nint src, int src_pitch, SDL_PixelFormat dst_format, nint dst, int dst_pitch, SDLBool linear);

	/// <summary>
	/// Premultiply the alpha in a surface.<br/>
	/// This is safe to use with src == dst, but not for other overlapping areas.<br/>
	/// <br/>
	/// @param surface the surface to modify.<br/>
	/// @param linear true to convert from sRGB to linear space for the alpha<br/>
	/// multiplication, false to do multiplication in sRGB space.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PremultiplySurfaceAlpha")]
	public static partial SDLBool SDL_PremultiplySurfaceAlpha(SDL_Surface* surface, SDLBool linear);

	/// <summary>
	/// Clear a surface with a specific color, with floating point precision.<br/>
	/// This function handles all surface formats, and ignores any clip rectangle.<br/>
	/// If the surface is YUV, the color is assumed to be in the sRGB colorspace,<br/>
	/// otherwise the color is assumed to be in the colorspace of the suface.<br/>
	/// <br/>
	/// @param surface the SDL_Surface to clear.<br/>
	/// @param r the red component of the pixel, normally in the range 0-1.<br/>
	/// @param g the green component of the pixel, normally in the range 0-1.<br/>
	/// @param b the blue component of the pixel, normally in the range 0-1.<br/>
	/// @param a the alpha component of the pixel, normally in the range 0-1.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ClearSurface")]
	public static partial SDLBool SDL_ClearSurface(SDL_Surface* surface, float r, float g, float b, float a);

	/// <summary>
	/// Perform a fast fill of a rectangle with a specific color.<br/>
	/// `color` should be a pixel of the format used by the surface, and can be<br/>
	/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
	/// alpha component then the destination is simply filled with that alpha<br/>
	/// information, no blending takes place.<br/>
	/// If there is a clip rectangle set on the destination (set via<br/>
	/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
	/// intersection of the clip rectangle and `rect`.<br/>
	/// <br/>
	/// @param dst the SDL_Surface structure that is the drawing target.<br/>
	/// @param rect the SDL_Rect structure representing the rectangle to fill, or<br/>
	/// NULL to fill the entire surface.<br/>
	/// @param color the color to fill with.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_FillSurfaceRects
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_FillSurfaceRect")]
	public static partial SDLBool SDL_FillSurfaceRect(SDL_Surface* dst, Rectangle* rect, uint color);

	/// <summary>
	/// Perform a fast fill of a set of rectangles with a specific color.<br/>
	/// `color` should be a pixel of the format used by the surface, and can be<br/>
	/// generated by SDL_MapRGB() or SDL_MapRGBA(). If the color value contains an<br/>
	/// alpha component then the destination is simply filled with that alpha<br/>
	/// information, no blending takes place.<br/>
	/// If there is a clip rectangle set on the destination (set via<br/>
	/// SDL_SetSurfaceClipRect()), then this function will fill based on the<br/>
	/// intersection of the clip rectangle and `rect`.<br/>
	/// <br/>
	/// @param dst the SDL_Surface structure that is the drawing target.<br/>
	/// @param rects an array of SDL_Rects representing the rectangles to fill.<br/>
	/// @param count the number of rectangles in the array.<br/>
	/// @param color the color to fill with.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_FillSurfaceRect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_FillSurfaceRects")]
	public static partial SDLBool SDL_FillSurfaceRects(SDL_Surface* dst, Rectangle* rects, int count, uint color);

	/// <summary>
	/// Performs a fast blit from the source surface to the destination surface.<br/>
	/// This assumes that the source and destination rectangles are the same size.<br/>
	/// If either `srcrect` or `dstrect` are NULL, the entire surface (`src` or<br/>
	/// `dst`) is copied. The final blit rectangles are saved in `srcrect` and<br/>
	/// `dstrect` after all clipping is performed.<br/>
	/// The blit function should not be called on a locked surface.<br/>
	/// The blit semantics for surfaces with and without blending and colorkey are<br/>
	/// defined as follows:<br/>
	/// ```<br/>
	/// RGBA->RGB:<br/>
	/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
	/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
	/// SDL_SRCCOLORKEY ignored.<br/>
	/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
	/// copy RGB.<br/>
	/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
	/// RGB values of the source color key, ignoring alpha in the<br/>
	/// comparison.<br/>
	/// RGB->RGBA:<br/>
	/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
	/// alpha-blend (using the source per-surface alpha)<br/>
	/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
	/// copy RGB, set destination alpha to source per-surface alpha value.<br/>
	/// both:<br/>
	/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
	/// source color key.<br/>
	/// RGBA->RGBA:<br/>
	/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
	/// alpha-blend (using the source alpha-channel and per-surface alpha)<br/>
	/// SDL_SRCCOLORKEY ignored.<br/>
	/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
	/// copy all of RGBA to the destination.<br/>
	/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
	/// RGB values of the source color key, ignoring alpha in the<br/>
	/// comparison.<br/>
	/// RGB->RGB:<br/>
	/// Source surface blend mode set to SDL_BLENDMODE_BLEND:<br/>
	/// alpha-blend (using the source per-surface alpha)<br/>
	/// Source surface blend mode set to SDL_BLENDMODE_NONE:<br/>
	/// copy RGB.<br/>
	/// both:<br/>
	/// if SDL_SRCCOLORKEY set, only copy the pixels that do not match the<br/>
	/// source color key.<br/>
	/// ```<br/>
	/// <br/>
	/// @param src the SDL_Surface structure to be copied from.<br/>
	/// @param srcrect the SDL_Rect structure representing the rectangle to be<br/>
	/// copied, or NULL to copy the entire surface.<br/>
	/// @param dst the SDL_Surface structure that is the blit target.<br/>
	/// @param dstrect the SDL_Rect structure representing the x and y position in<br/>
	/// the destination surface, or NULL for (0,0). The width and<br/>
	/// height are ignored, and are copied from `srcrect`. If you<br/>
	/// want a specific width and height, you should use<br/>
	/// SDL_BlitSurfaceScaled().<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety The same destination surface should not be used from two<br/>
	/// threads at once. It is safe to use the same source surface<br/>
	/// from multiple threads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BlitSurfaceScaled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BlitSurface")]
	public static partial SDLBool SDL_BlitSurface(SDL_Surface* src, Rectangle* srcrect, SDL_Surface* dst, Rectangle* dstrect);

	/// <summary>
	/// Perform low-level surface blitting only.<br/>
	/// This is a semi-private blit function and it performs low-level surface<br/>
	/// blitting, assuming the input rectangles have already been clipped.<br/>
	/// <br/>
	/// @param src the SDL_Surface structure to be copied from.<br/>
	/// @param srcrect the SDL_Rect structure representing the rectangle to be<br/>
	/// copied, may not be NULL.<br/>
	/// @param dst the SDL_Surface structure that is the blit target.<br/>
	/// @param dstrect the SDL_Rect structure representing the target rectangle in<br/>
	/// the destination surface, may not be NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety The same destination surface should not be used from two<br/>
	/// threads at once. It is safe to use the same source surface<br/>
	/// from multiple threads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BlitSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BlitSurfaceUnchecked")]
	public static partial SDLBool SDL_BlitSurfaceUnchecked(SDL_Surface* src, Rectangle* srcrect, SDL_Surface* dst, Rectangle* dstrect);

	/// <summary>
	/// Perform a scaled blit to a destination surface, which may be of a different<br/>
	/// format.<br/>
	/// <br/>
	/// @param src the SDL_Surface structure to be copied from.<br/>
	/// @param srcrect the SDL_Rect structure representing the rectangle to be<br/>
	/// copied, or NULL to copy the entire surface.<br/>
	/// @param dst the SDL_Surface structure that is the blit target.<br/>
	/// @param dstrect the SDL_Rect structure representing the target rectangle in<br/>
	/// the destination surface, or NULL to fill the entire<br/>
	/// destination surface.<br/>
	/// @param scaleMode the SDL_ScaleMode to be used.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety The same destination surface should not be used from two<br/>
	/// threads at once. It is safe to use the same source surface<br/>
	/// from multiple threads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BlitSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BlitSurfaceScaled")]
	public static partial SDLBool SDL_BlitSurfaceScaled(SDL_Surface* src, Rectangle* srcrect, SDL_Surface* dst, Rectangle* dstrect, SDL_ScaleMode scaleMode);

	/// <summary>
	/// Perform low-level surface scaled blitting only.<br/>
	/// This is a semi-private function and it performs low-level surface blitting,<br/>
	/// assuming the input rectangles have already been clipped.<br/>
	/// <br/>
	/// @param src the SDL_Surface structure to be copied from.<br/>
	/// @param srcrect the SDL_Rect structure representing the rectangle to be<br/>
	/// copied, may not be NULL.<br/>
	/// @param dst the SDL_Surface structure that is the blit target.<br/>
	/// @param dstrect the SDL_Rect structure representing the target rectangle in<br/>
	/// the destination surface, may not be NULL.<br/>
	/// @param scaleMode the SDL_ScaleMode to be used.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety The same destination surface should not be used from two<br/>
	/// threads at once. It is safe to use the same source surface<br/>
	/// from multiple threads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BlitSurfaceScaled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BlitSurfaceUncheckedScaled")]
	public static partial SDLBool SDL_BlitSurfaceUncheckedScaled(SDL_Surface* src, Rectangle* srcrect, SDL_Surface* dst, Rectangle* dstrect, SDL_ScaleMode scaleMode);

	/// <summary>
	/// Perform a tiled blit to a destination surface, which may be of a different<br/>
	/// format.<br/>
	/// The pixels in `srcrect` will be repeated as many times as needed to<br/>
	/// completely fill `dstrect`.<br/>
	/// <br/>
	/// @param src the SDL_Surface structure to be copied from.<br/>
	/// @param srcrect the SDL_Rect structure representing the rectangle to be<br/>
	/// copied, or NULL to copy the entire surface.<br/>
	/// @param dst the SDL_Surface structure that is the blit target.<br/>
	/// @param dstrect the SDL_Rect structure representing the target rectangle in<br/>
	/// the destination surface, or NULL to fill the entire surface.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety The same destination surface should not be used from two<br/>
	/// threads at once. It is safe to use the same source surface<br/>
	/// from multiple threads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BlitSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BlitSurfaceTiled")]
	public static partial SDLBool SDL_BlitSurfaceTiled(SDL_Surface* src, Rectangle* srcrect, SDL_Surface* dst, Rectangle* dstrect);

	/// <summary>
	/// Perform a scaled and tiled blit to a destination surface, which may be of a<br/>
	/// different format.<br/>
	/// The pixels in `srcrect` will be scaled and repeated as many times as needed<br/>
	/// to completely fill `dstrect`.<br/>
	/// <br/>
	/// @param src the SDL_Surface structure to be copied from.<br/>
	/// @param srcrect the SDL_Rect structure representing the rectangle to be<br/>
	/// copied, or NULL to copy the entire surface.<br/>
	/// @param scale the scale used to transform srcrect into the destination<br/>
	/// rectangle, e.g. a 32x32 texture with a scale of 2 would fill<br/>
	/// 64x64 tiles.<br/>
	/// @param scaleMode scale algorithm to be used.<br/>
	/// @param dst the SDL_Surface structure that is the blit target.<br/>
	/// @param dstrect the SDL_Rect structure representing the target rectangle in<br/>
	/// the destination surface, or NULL to fill the entire surface.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety The same destination surface should not be used from two<br/>
	/// threads at once. It is safe to use the same source surface<br/>
	/// from multiple threads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BlitSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BlitSurfaceTiledWithScale")]
	public static partial SDLBool SDL_BlitSurfaceTiledWithScale(SDL_Surface* src, Rectangle* srcrect, float scale, SDL_ScaleMode scaleMode, SDL_Surface* dst, Rectangle* dstrect);

	/// <summary>
	/// Perform a scaled blit using the 9-grid algorithm to a destination surface,<br/>
	/// which may be of a different format.<br/>
	/// The pixels in the source surface are split into a 3x3 grid, using the<br/>
	/// different corner sizes for each corner, and the sides and center making up<br/>
	/// the remaining pixels. The corners are then scaled using `scale` and fit<br/>
	/// into the corners of the destination rectangle. The sides and center are<br/>
	/// then stretched into place to cover the remaining destination rectangle.<br/>
	/// <br/>
	/// @param src the SDL_Surface structure to be copied from.<br/>
	/// @param srcrect the SDL_Rect structure representing the rectangle to be used<br/>
	/// for the 9-grid, or NULL to use the entire surface.<br/>
	/// @param left_width the width, in pixels, of the left corners in `srcrect`.<br/>
	/// @param right_width the width, in pixels, of the right corners in `srcrect`.<br/>
	/// @param top_height the height, in pixels, of the top corners in `srcrect`.<br/>
	/// @param bottom_height the height, in pixels, of the bottom corners in<br/>
	/// `srcrect`.<br/>
	/// @param scale the scale used to transform the corner of `srcrect` into the<br/>
	/// corner of `dstrect`, or 0.0f for an unscaled blit.<br/>
	/// @param scaleMode scale algorithm to be used.<br/>
	/// @param dst the SDL_Surface structure that is the blit target.<br/>
	/// @param dstrect the SDL_Rect structure representing the target rectangle in<br/>
	/// the destination surface, or NULL to fill the entire surface.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety The same destination surface should not be used from two<br/>
	/// threads at once. It is safe to use the same source surface<br/>
	/// from multiple threads.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BlitSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BlitSurface9Grid")]
	public static partial SDLBool SDL_BlitSurface9Grid(SDL_Surface* src, Rectangle* srcrect, int left_width, int right_width, int top_height, int bottom_height, float scale, SDL_ScaleMode scaleMode, SDL_Surface* dst, Rectangle* dstrect);

	/// <summary>
	/// Map an RGB triple to an opaque pixel value for a surface.<br/>
	/// This function maps the RGB color value to the specified pixel format and<br/>
	/// returns the pixel value best approximating the given RGB color value for<br/>
	/// the given pixel format.<br/>
	/// If the surface has a palette, the index of the closest matching color in<br/>
	/// the palette will be returned.<br/>
	/// If the surface pixel format has an alpha component it will be returned as<br/>
	/// all 1 bits (fully opaque).<br/>
	/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
	/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
	/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
	/// for an 8-bpp format).<br/>
	/// <br/>
	/// @param surface the surface to use for the pixel format and palette.<br/>
	/// @param r the red component of the pixel in the range 0-255.<br/>
	/// @param g the green component of the pixel in the range 0-255.<br/>
	/// @param b the blue component of the pixel in the range 0-255.<br/>
	/// @returns a pixel value.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_MapSurfaceRGBA
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_MapSurfaceRGB")]
	public static partial uint SDL_MapSurfaceRGB(SDL_Surface* surface, byte r, byte g, byte b);

	/// <summary>
	/// Map an RGBA quadruple to a pixel value for a surface.<br/>
	/// This function maps the RGBA color value to the specified pixel format and<br/>
	/// returns the pixel value best approximating the given RGBA color value for<br/>
	/// the given pixel format.<br/>
	/// If the surface pixel format has no alpha component the alpha value will be<br/>
	/// ignored (as it will be in formats with a palette).<br/>
	/// If the surface has a palette, the index of the closest matching color in<br/>
	/// the palette will be returned.<br/>
	/// If the pixel format bpp (color depth) is less than 32-bpp then the unused<br/>
	/// upper bits of the return value can safely be ignored (e.g., with a 16-bpp<br/>
	/// format the return value can be assigned to a Uint16, and similarly a Uint8<br/>
	/// for an 8-bpp format).<br/>
	/// <br/>
	/// @param surface the surface to use for the pixel format and palette.<br/>
	/// @param r the red component of the pixel in the range 0-255.<br/>
	/// @param g the green component of the pixel in the range 0-255.<br/>
	/// @param b the blue component of the pixel in the range 0-255.<br/>
	/// @param a the alpha component of the pixel in the range 0-255.<br/>
	/// @returns a pixel value.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_MapSurfaceRGB
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_MapSurfaceRGBA")]
	public static partial uint SDL_MapSurfaceRGBA(SDL_Surface* surface, byte r, byte g, byte b, byte a);

	/// <summary>
	/// Retrieves a single pixel from a surface.<br/>
	/// This function prioritizes correctness over speed: it is suitable for unit<br/>
	/// tests, but is not intended for use in a game engine.<br/>
	/// Like SDL_GetRGBA, this uses the entire 0..255 range when converting color<br/>
	/// components from pixel formats with less than 8 bits per RGB component.<br/>
	/// <br/>
	/// @param surface the surface to read.<br/>
	/// @param x the horizontal coordinate, 0<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// width.<br/>
	/// @param y the vertical coordinate, 0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// height.<br/>
	/// @param r a pointer filled in with the red channel, 0-255, or NULL to ignore<br/>
	/// this channel.<br/>
	/// @param g a pointer filled in with the green channel, 0-255, or NULL to<br/>
	/// ignore this channel.<br/>
	/// @param b a pointer filled in with the blue channel, 0-255, or NULL to<br/>
	/// ignore this channel.<br/>
	/// @param a a pointer filled in with the alpha channel, 0-255, or NULL to<br/>
	/// ignore this channel.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadSurfacePixel")]
	public static partial SDLBool SDL_ReadSurfacePixel(SDL_Surface* surface, int x, int y, byte* r, byte* g, byte* b, byte* a);

	/// <summary>
	/// Retrieves a single pixel from a surface.<br/>
	/// This function prioritizes correctness over speed: it is suitable for unit<br/>
	/// tests, but is not intended for use in a game engine.<br/>
	/// <br/>
	/// @param surface the surface to read.<br/>
	/// @param x the horizontal coordinate, 0<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// width.<br/>
	/// @param y the vertical coordinate, 0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// height.<br/>
	/// @param r a pointer filled in with the red channel, normally in the range<br/>
	/// 0-1, or NULL to ignore this channel.<br/>
	/// @param g a pointer filled in with the green channel, normally in the range<br/>
	/// 0-1, or NULL to ignore this channel.<br/>
	/// @param b a pointer filled in with the blue channel, normally in the range<br/>
	/// 0-1, or NULL to ignore this channel.<br/>
	/// @param a a pointer filled in with the alpha channel, normally in the range<br/>
	/// 0-1, or NULL to ignore this channel.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadSurfacePixelFloat")]
	public static partial SDLBool SDL_ReadSurfacePixelFloat(SDL_Surface* surface, int x, int y, float* r, float* g, float* b, float* a);

	/// <summary>
	/// Writes a single pixel to a surface.<br/>
	/// This function prioritizes correctness over speed: it is suitable for unit<br/>
	/// tests, but is not intended for use in a game engine.<br/>
	/// Like SDL_MapRGBA, this uses the entire 0..255 range when converting color<br/>
	/// components from pixel formats with less than 8 bits per RGB component.<br/>
	/// <br/>
	/// @param surface the surface to write.<br/>
	/// @param x the horizontal coordinate, 0<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// width.<br/>
	/// @param y the vertical coordinate, 0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// height.<br/>
	/// @param r the red channel value, 0-255.<br/>
	/// @param g the green channel value, 0-255.<br/>
	/// @param b the blue channel value, 0-255.<br/>
	/// @param a the alpha channel value, 0-255.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteSurfacePixel")]
	public static partial SDLBool SDL_WriteSurfacePixel(SDL_Surface* surface, int x, int y, byte r, byte g, byte b, byte a);

	/// <summary>
	/// Writes a single pixel to a surface.<br/>
	/// This function prioritizes correctness over speed: it is suitable for unit<br/>
	/// tests, but is not intended for use in a game engine.<br/>
	/// <br/>
	/// @param surface the surface to write.<br/>
	/// @param x the horizontal coordinate, 0<br/>
	/// <<br/>
	/// = x<br/>
	/// <<br/>
	/// width.<br/>
	/// @param y the vertical coordinate, 0<br/>
	/// <<br/>
	/// = y<br/>
	/// <<br/>
	/// height.<br/>
	/// @param r the red channel value, normally in the range 0-1.<br/>
	/// @param g the green channel value, normally in the range 0-1.<br/>
	/// @param b the blue channel value, normally in the range 0-1.<br/>
	/// @param a the alpha channel value, normally in the range 0-1.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WriteSurfacePixelFloat")]
	public static partial SDLBool SDL_WriteSurfacePixelFloat(SDL_Surface* surface, int x, int y, float r, float g, float b, float a);

	/// <summary>
	/// These are the actual functions exported from SDL! Don't use them directly! Use the SDL_CreateThread and SDL_CreateThreadWithProperties macros!<br/>
	/// The actual entry point for SDL_CreateThread.<br/>
	/// <br/>
	/// @param fn the SDL_ThreadFunction function to call in the new thread<br/>
	/// @param name the name of the thread<br/>
	/// @param data a pointer that is passed to `fn`<br/>
	/// @param pfnBeginThread the C runtime's _beginthreadex (or whatnot). Can be NULL.<br/>
	/// @param pfnEndThread the C runtime's _endthreadex (or whatnot). Can be NULL.<br/>
	/// @returns an opaque pointer to the new thread object on success, NULL if the<br/>
	/// new thread could not be created; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateThreadRuntime")]
	public static partial SDL_Thread SDL_CreateThreadRuntime(delegate* unmanaged[Cdecl]<nint, int> fn, byte* name, nint data, delegate* unmanaged[Cdecl]<void> pfnBeginThread, delegate* unmanaged[Cdecl]<void> pfnEndThread);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateThreadRuntime")]
	public static partial SDL_Thread SDL_CreateThreadRuntime(delegate* unmanaged[Cdecl]<nint, int> fn, ReadOnlySpan<byte> name, nint data, delegate* unmanaged[Cdecl]<void> pfnBeginThread, delegate* unmanaged[Cdecl]<void> pfnEndThread);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateThreadRuntime")]
	public static partial SDL_Thread SDL_CreateThreadRuntime(delegate* unmanaged[Cdecl]<nint, int> fn, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, nint data, delegate* unmanaged[Cdecl]<void> pfnBeginThread, delegate* unmanaged[Cdecl]<void> pfnEndThread);

	/// <summary>
	/// The actual entry point for SDL_CreateThreadWithProperties.<br/>
	/// <br/>
	/// @param props the properties to use<br/>
	/// @param pfnBeginThread the C runtime's _beginthreadex (or whatnot). Can be NULL.<br/>
	/// @param pfnEndThread the C runtime's _endthreadex (or whatnot). Can be NULL.<br/>
	/// @returns an opaque pointer to the new thread object on success, NULL if the<br/>
	/// new thread could not be created; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateThreadWithPropertiesRuntime")]
	public static partial SDL_Thread SDL_CreateThreadWithPropertiesRuntime(SDL_PropertiesID props, delegate* unmanaged[Cdecl]<void> pfnBeginThread, delegate* unmanaged[Cdecl]<void> pfnEndThread);

	/// <summary>
	/// Get the thread name as it was specified in SDL_CreateThread().<br/>
	/// <br/>
	/// @param thread the thread to query.<br/>
	/// @returns a pointer to a UTF-8 string that names the specified thread, or<br/>
	/// NULL if it doesn't have a name.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetThreadName")]
	public static partial byte* SDL_GetThreadNamePtr(SDL_Thread thread);

	public static string? SDL_GetThreadName(SDL_Thread thread)
	{
		return ConvertToManaged(SDL_GetThreadNamePtr(thread));
	}

	/// <summary>
	/// Get the thread identifier for the current thread.<br/>
	/// This thread identifier is as reported by the underlying operating system.<br/>
	/// If SDL is running on a platform that does not support threads the return<br/>
	/// value will always be zero.<br/>
	/// This function also returns a valid thread ID when called from the main<br/>
	/// thread.<br/>
	/// <br/>
	/// @returns the ID of the current thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetThreadID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentThreadID")]
	public static partial SDL_ThreadID SDL_GetCurrentThreadID();

	/// <summary>
	/// Get the thread identifier for the specified thread.<br/>
	/// This thread identifier is as reported by the underlying operating system.<br/>
	/// If SDL is running on a platform that does not support threads the return<br/>
	/// value will always be zero.<br/>
	/// <br/>
	/// @param thread the thread to query.<br/>
	/// @returns the ID of the specified thread, or the ID of the current thread if<br/>
	/// `thread` is NULL.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetCurrentThreadID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetThreadID")]
	public static partial SDL_ThreadID SDL_GetThreadID(SDL_Thread thread);

	/// <summary>
	/// Set the priority for the current thread.<br/>
	/// Note that some platforms will not let you alter the priority (or at least,<br/>
	/// promote the thread to a higher priority) at all, and some require you to be<br/>
	/// an administrator account. Be prepared for this to fail.<br/>
	/// <br/>
	/// @param priority the SDL_ThreadPriority to set.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetCurrentThreadPriority")]
	public static partial SDLBool SDL_SetCurrentThreadPriority(SDL_ThreadPriority priority);

	/// <summary>
	/// Wait for a thread to finish.<br/>
	/// Threads that haven't been detached will remain (as a "zombie") until this<br/>
	/// function cleans them up. Not doing so is a resource leak.<br/>
	/// Once a thread has been cleaned up through this function, the SDL_Thread<br/>
	/// that references it becomes invalid and should not be referenced again. As<br/>
	/// such, only one thread may call SDL_WaitThread() on another.<br/>
	/// The return code for the thread function is placed in the area pointed to by<br/>
	/// `status`, if `status` is not NULL.<br/>
	/// You may not wait on a thread that has been used in a call to<br/>
	/// SDL_DetachThread(). Use either that function or this one, but not both, or<br/>
	/// behavior is undefined.<br/>
	/// It is safe to pass a NULL thread to this function; it is a no-op.<br/>
	/// Note that the thread pointer is freed by this function and is not valid<br/>
	/// afterward.<br/>
	/// <br/>
	/// @param thread the SDL_Thread pointer that was returned from the<br/>
	/// SDL_CreateThread() call that started this thread.<br/>
	/// @param status pointer to an integer that will receive the value returned<br/>
	/// from the thread function by its 'return', or NULL to not<br/>
	/// receive such value back.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateThread<br/>
	/// @sa SDL_DetachThread
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WaitThread")]
	public static partial void SDL_WaitThread(SDL_Thread thread, int* status);

	/// <summary>
	/// Let a thread clean up on exit without intervention.<br/>
	/// A thread may be "detached" to signify that it should not remain until<br/>
	/// another thread has called SDL_WaitThread() on it. Detaching a thread is<br/>
	/// useful for long-running threads that nothing needs to synchronize with or<br/>
	/// further manage. When a detached thread is done, it simply goes away.<br/>
	/// There is no way to recover the return code of a detached thread. If you<br/>
	/// need this, don't detach the thread and instead use SDL_WaitThread().<br/>
	/// Once a thread is detached, you should usually assume the SDL_Thread isn't<br/>
	/// safe to reference again, as it will become invalid immediately upon the<br/>
	/// detached thread's exit, instead of remaining until someone has called<br/>
	/// SDL_WaitThread() to finally clean it up. As such, don't detach the same<br/>
	/// thread more than once.<br/>
	/// If a thread has already exited when passed to SDL_DetachThread(), it will<br/>
	/// stop waiting for a call to SDL_WaitThread() and clean up immediately. It is<br/>
	/// not safe to detach a thread that might be used with SDL_WaitThread().<br/>
	/// You may not call SDL_WaitThread() on a thread that has been detached. Use<br/>
	/// either that function or this one, but not both, or behavior is undefined.<br/>
	/// It is safe to pass NULL to this function; it is a no-op.<br/>
	/// <br/>
	/// @param thread the SDL_Thread pointer that was returned from the<br/>
	/// SDL_CreateThread() call that started this thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateThread<br/>
	/// @sa SDL_WaitThread
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DetachThread")]
	public static partial void SDL_DetachThread(SDL_Thread thread);

	/// <summary>
	/// Get the current thread's value associated with a thread local storage ID.<br/>
	/// <br/>
	/// @param id a pointer to the thread local storage ID, may not be NULL.<br/>
	/// @returns the value associated with the ID for the current thread or NULL if<br/>
	/// no value has been set; call SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetTLS
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTLS")]
	public static partial nint SDL_GetTLS(SDL_AtomicInt* id);

	/// <summary>
	/// Set the current thread's value associated with a thread local storage ID.<br/>
	/// If the thread local storage ID is not initialized (the value is 0), a new<br/>
	/// ID will be created in a thread-safe way, so all calls using a pointer to<br/>
	/// the same ID will refer to the same local storage.<br/>
	/// Note that replacing a value from a previous call to this function on the<br/>
	/// same thread does _not_ call the previous value's destructor!<br/>
	/// `destructor` can be NULL; it is assumed that `value` does not need to be<br/>
	/// cleaned up if so.<br/>
	/// <br/>
	/// @param id a pointer to the thread local storage ID, may not be NULL.<br/>
	/// @param value the value to associate with the ID for the current thread.<br/>
	/// @param destructor a function called when the thread exits, to free the<br/>
	/// value, may be NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetTLS
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetTLS")]
	public static partial SDLBool SDL_SetTLS(SDL_AtomicInt* id, nint value, delegate* unmanaged[Cdecl]<nint, void> destructor);

	/// <summary>
	/// Cleanup all TLS data for this thread.<br/>
	/// If you are creating your threads outside of SDL and then calling SDL<br/>
	/// functions, you should call this function before your thread exits, to<br/>
	/// properly clean up SDL memory.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CleanupTLS")]
	public static partial void SDL_CleanupTLS();

	/// <summary>
	/// Gets the current preferred date and time format for the system locale.<br/>
	/// This might be a "slow" call that has to query the operating system. It's<br/>
	/// best to ask for this once and save the results. However, the preferred<br/>
	/// formats can change, usually because the user has changed a system<br/>
	/// preference outside of your program.<br/>
	/// <br/>
	/// @param dateFormat a pointer to the SDL_DateFormat to hold the returned date<br/>
	/// format, may be NULL.<br/>
	/// @param timeFormat a pointer to the SDL_TimeFormat to hold the returned time<br/>
	/// format, may be NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDateTimeLocalePreferences")]
	public static partial SDLBool SDL_GetDateTimeLocalePreferences(SDL_DateFormat* dateFormat, SDL_TimeFormat* timeFormat);

	/// <summary>
	/// Gets the current value of the system realtime clock in nanoseconds since<br/>
	/// Jan 1, 1970 in Universal Coordinated Time (UTC).<br/>
	/// <br/>
	/// @param ticks the SDL_Time to hold the returned tick count.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentTime")]
	public static partial SDLBool SDL_GetCurrentTime(long* ticks);

	/// <summary>
	/// Converts an SDL_Time in nanoseconds since the epoch to a calendar time in<br/>
	/// the SDL_DateTime format.<br/>
	/// <br/>
	/// @param ticks the SDL_Time to be converted.<br/>
	/// @param dt the resulting SDL_DateTime.<br/>
	/// @param localTime the resulting SDL_DateTime will be expressed in local time<br/>
	/// if true, otherwise it will be in Universal Coordinated<br/>
	/// Time (UTC).<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_TimeToDateTime")]
	public static partial SDLBool SDL_TimeToDateTime(long ticks, SDL_DateTime* dt, SDLBool localTime);

	/// <summary>
	/// Converts a calendar time to an SDL_Time in nanoseconds since the epoch.<br/>
	/// This function ignores the day_of_week member of the SDL_DateTime struct, so<br/>
	/// it may remain unset.<br/>
	/// <br/>
	/// @param dt the source SDL_DateTime.<br/>
	/// @param ticks the resulting SDL_Time.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DateTimeToTime")]
	public static partial SDLBool SDL_DateTimeToTime(SDL_DateTime* dt, long* ticks);

	/// <summary>
	/// Converts an SDL time into a Windows FILETIME (100-nanosecond intervals<br/>
	/// since January 1, 1601).<br/>
	/// This function fills in the two 32-bit values of the FILETIME structure.<br/>
	/// <br/>
	/// @param ticks the time to convert.<br/>
	/// @param dwLowDateTime a pointer filled in with the low portion of the<br/>
	/// Windows FILETIME value.<br/>
	/// @param dwHighDateTime a pointer filled in with the high portion of the<br/>
	/// Windows FILETIME value.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_TimeToWindows")]
	public static partial void SDL_TimeToWindows(long ticks, uint* dwLowDateTime, uint* dwHighDateTime);

	/// <summary>
	/// Converts a Windows FILETIME (100-nanosecond intervals since January 1,<br/>
	/// 1601) to an SDL time.<br/>
	/// This function takes the two 32-bit values of the FILETIME structure as<br/>
	/// parameters.<br/>
	/// <br/>
	/// @param dwLowDateTime the low portion of the Windows FILETIME value.<br/>
	/// @param dwHighDateTime the high portion of the Windows FILETIME value.<br/>
	/// @returns the converted SDL time.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_TimeFromWindows")]
	public static partial long SDL_TimeFromWindows(uint dwLowDateTime, uint dwHighDateTime);

	/// <summary>
	/// Get the number of days in a month for a given year.<br/>
	/// <br/>
	/// @param year the year.<br/>
	/// @param month the month [1-12].<br/>
	/// @returns the number of days in the requested month or -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDaysInMonth")]
	public static partial int SDL_GetDaysInMonth(int year, int month);

	/// <summary>
	/// Get the day of year for a calendar date.<br/>
	/// <br/>
	/// @param year the year component of the date.<br/>
	/// @param month the month component of the date.<br/>
	/// @param day the day component of the date.<br/>
	/// @returns the day of year [0-365] if the date is valid or -1 on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDayOfYear")]
	public static partial int SDL_GetDayOfYear(int year, int month, int day);

	/// <summary>
	/// Get the day of week for a calendar date.<br/>
	/// <br/>
	/// @param year the year component of the date.<br/>
	/// @param month the month component of the date.<br/>
	/// @param day the day component of the date.<br/>
	/// @returns a value between 0 and 6 (0 being Sunday) if the date is valid or<br/>
	/// -1 on failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDayOfWeek")]
	public static partial int SDL_GetDayOfWeek(int year, int month, int day);

	/// <summary>
	/// Get the number of milliseconds since SDL library initialization.<br/>
	/// <br/>
	/// @returns an unsigned 64-bit value representing the number of milliseconds<br/>
	/// since the SDL library initialized.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTicks")]
	public static partial ulong SDL_GetTicks();

	/// <summary>
	/// Get the number of nanoseconds since SDL library initialization.<br/>
	/// <br/>
	/// @returns an unsigned 64-bit value representing the number of nanoseconds<br/>
	/// since the SDL library initialized.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTicksNS")]
	public static partial ulong SDL_GetTicksNS();

	/// <summary>
	/// Get the current value of the high resolution counter.<br/>
	/// This function is typically used for profiling.<br/>
	/// The counter values are only meaningful relative to each other. Differences<br/>
	/// between values can be converted to times by using<br/>
	/// SDL_GetPerformanceFrequency().<br/>
	/// <br/>
	/// @returns the current counter value.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPerformanceFrequency
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPerformanceCounter")]
	public static partial ulong SDL_GetPerformanceCounter();

	/// <summary>
	/// Get the count per second of the high resolution counter.<br/>
	/// <br/>
	/// @returns a platform-specific count per second.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetPerformanceCounter
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPerformanceFrequency")]
	public static partial ulong SDL_GetPerformanceFrequency();

	/// <summary>
	/// Wait a specified number of milliseconds before returning.<br/>
	/// This function waits a specified number of milliseconds before returning. It<br/>
	/// waits at least the specified time, but possibly longer due to OS<br/>
	/// scheduling.<br/>
	/// <br/>
	/// @param ms the number of milliseconds to delay.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Delay")]
	public static partial void SDL_Delay(uint ms);

	/// <summary>
	/// Wait a specified number of nanoseconds before returning.<br/>
	/// This function waits a specified number of nanoseconds before returning. It<br/>
	/// will attempt to wait as close to the requested time as possible, busy<br/>
	/// waiting if necessary, but could return later due to OS scheduling.<br/>
	/// <br/>
	/// @param ns the number of nanoseconds to delay.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DelayNS")]
	public static partial void SDL_DelayNS(ulong ns);

	/// <summary>
	/// Call a callback function at a future time.<br/>
	/// The callback function is passed the current timer interval and the user<br/>
	/// supplied parameter from the SDL_AddTimer() call and should return the next<br/>
	/// timer interval. If the value returned from the callback is 0, the timer is<br/>
	/// canceled and will be removed.<br/>
	/// The callback is run on a separate thread, and for short timeouts can<br/>
	/// potentially be called before this function returns.<br/>
	/// Timers take into account the amount of time it took to execute the<br/>
	/// callback. For example, if the callback took 250 ms to execute and returned<br/>
	/// 1000 (ms), the timer would only wait another 750 ms before its next<br/>
	/// iteration.<br/>
	/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
	/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
	/// callback needs to adjust for variances.<br/>
	/// <br/>
	/// @param interval the timer delay, in milliseconds, passed to `callback`.<br/>
	/// @param callback the SDL_TimerCallback function to call when the specified<br/>
	/// `interval` elapses.<br/>
	/// @param userdata a pointer that is passed to `callback`.<br/>
	/// @returns a timer ID or 0 on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddTimerNS<br/>
	/// @sa SDL_RemoveTimer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AddTimer")]
	public static partial SDL_TimerID SDL_AddTimer(uint interval, delegate* unmanaged[Cdecl]<nint, SDL_TimerID, uint, uint> callback, nint userdata);

	/// <summary>
	/// Call a callback function at a future time.<br/>
	/// The callback function is passed the current timer interval and the user<br/>
	/// supplied parameter from the SDL_AddTimerNS() call and should return the<br/>
	/// next timer interval. If the value returned from the callback is 0, the<br/>
	/// timer is canceled and will be removed.<br/>
	/// The callback is run on a separate thread, and for short timeouts can<br/>
	/// potentially be called before this function returns.<br/>
	/// Timers take into account the amount of time it took to execute the<br/>
	/// callback. For example, if the callback took 250 ns to execute and returned<br/>
	/// 1000 (ns), the timer would only wait another 750 ns before its next<br/>
	/// iteration.<br/>
	/// Timing may be inexact due to OS scheduling. Be sure to note the current<br/>
	/// time with SDL_GetTicksNS() or SDL_GetPerformanceCounter() in case your<br/>
	/// callback needs to adjust for variances.<br/>
	/// <br/>
	/// @param interval the timer delay, in nanoseconds, passed to `callback`.<br/>
	/// @param callback the SDL_TimerCallback function to call when the specified<br/>
	/// `interval` elapses.<br/>
	/// @param userdata a pointer that is passed to `callback`.<br/>
	/// @returns a timer ID or 0 on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddTimer<br/>
	/// @sa SDL_RemoveTimer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AddTimerNS")]
	public static partial SDL_TimerID SDL_AddTimerNS(ulong interval, delegate* unmanaged[Cdecl]<nint, SDL_TimerID, ulong, ulong> callback, nint userdata);

	/// <summary>
	/// Remove a timer created with SDL_AddTimer().<br/>
	/// <br/>
	/// @param id the ID of the timer to remove.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AddTimer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RemoveTimer")]
	public static partial SDLBool SDL_RemoveTimer(SDL_TimerID id);

	/// <summary>
	/// Get a list of registered touch devices.<br/>
	/// On some platforms SDL first sees the touch device if it was actually used.<br/>
	/// Therefore the returned list might be empty, although devices are available.<br/>
	/// After using all devices at least once the number will be correct.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of devices returned, may<br/>
	/// be NULL.<br/>
	/// @returns a 0 terminated array of touch device IDs or NULL on failure; call<br/>
	/// SDL_GetError() for more information. This should be freed with<br/>
	/// SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTouchDevices")]
	public static partial SDL_TouchID* SDL_GetTouchDevices(out int count);

	/// <summary>
	/// Get the touch device name as reported from the driver.<br/>
	/// <br/>
	/// @param touchID the touch device instance ID.<br/>
	/// @returns touch device name, or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTouchDeviceName")]
	public static partial byte* SDL_GetTouchDeviceNamePtr(SDL_TouchID touchID);

	public static string? SDL_GetTouchDeviceName(SDL_TouchID touchID)
	{
		return ConvertToManaged(SDL_GetTouchDeviceNamePtr(touchID));
	}

	/// <summary>
	/// Get the type of the given touch device.<br/>
	/// <br/>
	/// @param touchID the ID of a touch device.<br/>
	/// @returns touch device type.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTouchDeviceType")]
	public static partial SDL_TouchDeviceType SDL_GetTouchDeviceType(SDL_TouchID touchID);

	/// <summary>
	/// Get a list of active fingers for a given touch device.<br/>
	/// <br/>
	/// @param touchID the ID of a touch device.<br/>
	/// @param count a pointer filled in with the number of fingers returned, can<br/>
	/// be NULL.<br/>
	/// @returns a NULL terminated array of SDL_Finger pointers or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This is a single<br/>
	/// allocation that should be freed with SDL_free() when it is no<br/>
	/// longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetTouchFingers")]
	public static partial SDL_Finger** SDL_GetTouchFingers(SDL_TouchID touchID, out int count);

	/// <summary>
	/// Get the version of SDL that is linked against your program.<br/>
	/// If you are linking to SDL dynamically, then it is possible that the current<br/>
	/// version will be different than the version you compiled against. This<br/>
	/// function returns the current version, while SDL_VERSION is the version you<br/>
	/// compiled with.<br/>
	/// This function may be called safely at any time, even before SDL_Init().<br/>
	/// <br/>
	/// @returns the version of the linked library.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRevision
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetVersion")]
	public static partial int SDL_GetVersion();

	/// <summary>
	/// Get the code revision of SDL that is linked against your program.<br/>
	/// This value is the revision of the code you are linked with and may be<br/>
	/// different from the code you are compiling with, which is found in the<br/>
	/// constant SDL_REVISION.<br/>
	/// The revision is arbitrary string (a hash value) uniquely identifying the<br/>
	/// exact revision of the SDL library in use, and is only useful in comparing<br/>
	/// against other revisions. It is NOT an incrementing number.<br/>
	/// If SDL wasn't built from a git repository with the appropriate tools, this<br/>
	/// will return an empty string.<br/>
	/// You shouldn't use this function for anything but logging it for debugging<br/>
	/// purposes. The string is not intended to be reliable in any way.<br/>
	/// <br/>
	/// @returns an arbitrary string, uniquely identifying the exact revision of<br/>
	/// the SDL library in use.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetVersion
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetRevision")]
	public static partial byte* SDL_GetRevisionPtr();

	public static string? SDL_GetRevision()
	{
		return ConvertToManaged(SDL_GetRevisionPtr());
	}

	/// <summary>
	/// Get the number of video drivers compiled into SDL.<br/>
	/// <br/>
	/// @returns the number of built in video drivers.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetVideoDriver
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumVideoDrivers")]
	public static partial int SDL_GetNumVideoDrivers();

	/// <summary>
	/// Get the name of a built in video driver.<br/>
	/// The video drivers are presented in the order in which they are normally<br/>
	/// checked during initialization.<br/>
	/// The names of drivers are all simple, low-ASCII identifiers, like "cocoa",<br/>
	/// "x11" or "windows". These never have Unicode characters, and are not meant<br/>
	/// to be proper names.<br/>
	/// <br/>
	/// @param index the index of a video driver.<br/>
	/// @returns the name of the video driver with the given **index**.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumVideoDrivers
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetVideoDriver")]
	public static partial byte* SDL_GetVideoDriverPtr(int index);

	public static string? SDL_GetVideoDriver(int index)
	{
		return ConvertToManaged(SDL_GetVideoDriverPtr(index));
	}

	/// <summary>
	/// Get the name of the currently initialized video driver.<br/>
	/// The names of drivers are all simple, low-ASCII identifiers, like "cocoa",<br/>
	/// "x11" or "windows". These never have Unicode characters, and are not meant<br/>
	/// to be proper names.<br/>
	/// <br/>
	/// @returns the name of the current video driver or NULL if no driver has been<br/>
	/// initialized.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumVideoDrivers<br/>
	/// @sa SDL_GetVideoDriver
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentVideoDriver")]
	public static partial byte* SDL_GetCurrentVideoDriverPtr();

	public static string? SDL_GetCurrentVideoDriver()
	{
		return ConvertToManaged(SDL_GetCurrentVideoDriverPtr());
	}

	/// <summary>
	/// Get the current system theme.<br/>
	/// <br/>
	/// @returns the current system theme, light, dark, or unknown.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetSystemTheme")]
	public static partial SDL_SystemTheme SDL_GetSystemTheme();

	/// <summary>
	/// Get a list of currently connected displays.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of displays returned, may<br/>
	/// be NULL.<br/>
	/// @returns a 0 terminated array of display instance IDs or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This should be freed<br/>
	/// with SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDisplays")]
	public static partial SDL_DisplayID* SDL_GetDisplays(out int count);

	/// <summary>
	/// Return the primary display.<br/>
	/// <br/>
	/// @returns the instance ID of the primary display on success or 0 on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetPrimaryDisplay")]
	public static partial SDL_DisplayID SDL_GetPrimaryDisplay();

	/// <summary>
	/// Get the properties associated with a display.<br/>
	/// The following read-only properties are provided by SDL:<br/>
	/// - `SDL_PROP_DISPLAY_HDR_ENABLED_BOOLEAN`: true if the display has HDR<br/>
	/// headroom above the SDR white point. This is for informational and<br/>
	/// diagnostic purposes only, as not all platforms provide this information<br/>
	/// at the display level.<br/>
	/// On KMS/DRM:<br/>
	/// - `SDL_PROP_DISPLAY_KMSDRM_PANEL_ORIENTATION_NUMBER`: the "panel<br/>
	/// orientation" property for the display in degrees of clockwise rotation.<br/>
	/// Note that this is provided only as a hint, and the application is<br/>
	/// responsible for any coordinate transformations needed to conform to the<br/>
	/// requested display orientation.<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayProperties")]
	public static partial SDL_PropertiesID SDL_GetDisplayProperties(SDL_DisplayID displayID);

	/// <summary>
	/// Get the name of a display in UTF-8 encoding.<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @returns the name of a display or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayName")]
	public static partial byte* SDL_GetDisplayNamePtr(SDL_DisplayID displayID);

	public static string? SDL_GetDisplayName(SDL_DisplayID displayID)
	{
		return ConvertToManaged(SDL_GetDisplayNamePtr(displayID));
	}

	/// <summary>
	/// Get the desktop area represented by a display.<br/>
	/// The primary display is always located at (0,0).<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @param rect the SDL_Rect structure filled in with the display bounds.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplayUsableBounds<br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayBounds")]
	public static partial SDLBool SDL_GetDisplayBounds(SDL_DisplayID displayID, Rectangle* rect);

	/// <summary>
	/// Get the usable desktop area represented by a display, in screen<br/>
	/// coordinates.<br/>
	/// This is the same area as SDL_GetDisplayBounds() reports, but with portions<br/>
	/// reserved by the system removed. For example, on Apple's macOS, this<br/>
	/// subtracts the area occupied by the menu bar and dock.<br/>
	/// Setting a window to be fullscreen generally bypasses these unusable areas,<br/>
	/// so these are good guidelines for the maximum space available to a<br/>
	/// non-fullscreen window.<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @param rect the SDL_Rect structure filled in with the display bounds.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplayBounds<br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayUsableBounds")]
	public static partial SDLBool SDL_GetDisplayUsableBounds(SDL_DisplayID displayID, Rectangle* rect);

	/// <summary>
	/// Get the orientation of a display when it is unrotated.<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @returns the SDL_DisplayOrientation enum value of the display, or<br/>
	/// `SDL_ORIENTATION_UNKNOWN` if it isn't available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNaturalDisplayOrientation")]
	public static partial SDL_DisplayOrientation SDL_GetNaturalDisplayOrientation(SDL_DisplayID displayID);

	/// <summary>
	/// Get the orientation of a display.<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @returns the SDL_DisplayOrientation enum value of the display, or<br/>
	/// `SDL_ORIENTATION_UNKNOWN` if it isn't available.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentDisplayOrientation")]
	public static partial SDL_DisplayOrientation SDL_GetCurrentDisplayOrientation(SDL_DisplayID displayID);

	/// <summary>
	/// Get the content scale of a display.<br/>
	/// The content scale is the expected scale for content based on the DPI<br/>
	/// settings of the display. For example, a 4K display might have a 2.0 (200%)<br/>
	/// display scale, which means that the user expects UI elements to be twice as<br/>
	/// big on this display, to aid in readability.<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @returns the content scale of the display, or 0.0f on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayContentScale")]
	public static partial float SDL_GetDisplayContentScale(SDL_DisplayID displayID);

	/// <summary>
	/// Get a list of fullscreen display modes available on a display.<br/>
	/// The display modes are sorted in this priority:<br/>
	/// - w -> largest to smallest<br/>
	/// - h -> largest to smallest<br/>
	/// - bits per pixel -> more colors to fewer colors<br/>
	/// - packed pixel layout -> largest to smallest<br/>
	/// - refresh rate -> highest to lowest<br/>
	/// - pixel density -> lowest to highest<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @param count a pointer filled in with the number of display modes returned,<br/>
	/// may be NULL.<br/>
	/// @returns a NULL terminated array of display mode pointers or NULL on<br/>
	/// failure; call SDL_GetError() for more information. This is a<br/>
	/// single allocation that should be freed with SDL_free() when it is<br/>
	/// no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetFullscreenDisplayModes")]
	public static partial SDL_DisplayMode** SDL_GetFullscreenDisplayModes(SDL_DisplayID displayID, out int count);

	/// <summary>
	/// Get the closest match to the requested display mode.<br/>
	/// The available display modes are scanned and `closest` is filled in with the<br/>
	/// closest mode matching the requested mode and returned. The mode format and<br/>
	/// refresh rate default to the desktop mode if they are set to 0. The modes<br/>
	/// are scanned with size being first priority, format being second priority,<br/>
	/// and finally checking the refresh rate. If all the available modes are too<br/>
	/// small, then NULL is returned.<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @param w the width in pixels of the desired display mode.<br/>
	/// @param h the height in pixels of the desired display mode.<br/>
	/// @param refresh_rate the refresh rate of the desired display mode, or 0.0f<br/>
	/// for the desktop refresh rate.<br/>
	/// @param include_high_density_modes boolean to include high density modes in<br/>
	/// the search.<br/>
	/// @param mode a pointer filled in with the closest display mode equal to or<br/>
	/// larger than the desired mode.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplays<br/>
	/// @sa SDL_GetFullscreenDisplayModes
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetClosestFullscreenDisplayMode")]
	public static partial SDLBool SDL_GetClosestFullscreenDisplayMode(SDL_DisplayID displayID, int w, int h, float refresh_rate, SDLBool include_high_density_modes, SDL_DisplayMode* mode);

	/// <summary>
	/// Get information about the desktop's display mode.<br/>
	/// There's a difference between this function and SDL_GetCurrentDisplayMode()<br/>
	/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
	/// function will return the previous native display mode, and not the current<br/>
	/// display mode.<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @returns a pointer to the desktop display mode or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetCurrentDisplayMode<br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDesktopDisplayMode")]
	public static partial SDL_DisplayMode* SDL_GetDesktopDisplayMode(SDL_DisplayID displayID);

	/// <summary>
	/// Get information about the current display mode.<br/>
	/// There's a difference between this function and SDL_GetDesktopDisplayMode()<br/>
	/// when SDL runs fullscreen and has changed the resolution. In that case this<br/>
	/// function will return the current display mode, and not the previous native<br/>
	/// display mode.<br/>
	/// <br/>
	/// @param displayID the instance ID of the display to query.<br/>
	/// @returns a pointer to the desktop display mode or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDesktopDisplayMode<br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetCurrentDisplayMode")]
	public static partial SDL_DisplayMode* SDL_GetCurrentDisplayMode(SDL_DisplayID displayID);

	/// <summary>
	/// Get the display containing a point.<br/>
	/// <br/>
	/// @param point the point to query.<br/>
	/// @returns the instance ID of the display containing the point or 0 on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplayBounds<br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayForPoint")]
	public static partial SDL_DisplayID SDL_GetDisplayForPoint(Point* point);

	/// <summary>
	/// Get the display primarily containing a rect.<br/>
	/// <br/>
	/// @param rect the rect to query.<br/>
	/// @returns the instance ID of the display entirely containing the rect or<br/>
	/// closest to the center of the rect on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplayBounds<br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayForRect")]
	public static partial SDL_DisplayID SDL_GetDisplayForRect(Rectangle* rect);

	/// <summary>
	/// Get the display associated with a window.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns the instance ID of the display containing the center of the window<br/>
	/// on success or 0 on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetDisplayBounds<br/>
	/// @sa SDL_GetDisplays
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDisplayForWindow")]
	public static partial SDL_DisplayID SDL_GetDisplayForWindow(SDL_Window window);

	/// <summary>
	/// Get the pixel density of a window.<br/>
	/// This is a ratio of pixel size to window size. For example, if the window is<br/>
	/// 1920x1080 and it has a high density back buffer of 3840x2160 pixels, it<br/>
	/// would have a pixel density of 2.0.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns the pixel density or 0.0f on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowDisplayScale
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowPixelDensity")]
	public static partial float SDL_GetWindowPixelDensity(SDL_Window window);

	/// <summary>
	/// Get the content display scale relative to a window's pixel size.<br/>
	/// This is a combination of the window pixel density and the display content<br/>
	/// scale, and is the expected scale for displaying content in this window. For<br/>
	/// example, if a 3840x2160 window had a display scale of 2.0, the user expects<br/>
	/// the content to take twice as many pixels and be the same physical size as<br/>
	/// if it were being displayed in a 1920x1080 window with a display scale of<br/>
	/// 1.0.<br/>
	/// Conceptually this value corresponds to the scale display setting, and is<br/>
	/// updated when that setting is changed, or the window moves to a display with<br/>
	/// a different scale setting.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns the display scale, or 0.0f on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowDisplayScale")]
	public static partial float SDL_GetWindowDisplayScale(SDL_Window window);

	/// <summary>
	/// Set the display mode to use when a window is visible and fullscreen.<br/>
	/// This only affects the display mode used when the window is fullscreen. To<br/>
	/// change the window size when the window is not fullscreen, use<br/>
	/// SDL_SetWindowSize().<br/>
	/// If the window is currently in the fullscreen state, this request is<br/>
	/// asynchronous on some windowing systems and the new mode dimensions may not<br/>
	/// be applied immediately upon the return of this function. If an immediate<br/>
	/// change is required, call SDL_SyncWindow() to block until the changes have<br/>
	/// taken effect.<br/>
	/// When the new mode takes effect, an SDL_EVENT_WINDOW_RESIZED and/or an<br/>
	/// SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event will be emitted with the new mode<br/>
	/// dimensions.<br/>
	/// <br/>
	/// @param window the window to affect.<br/>
	/// @param mode a pointer to the display mode to use, which can be NULL for<br/>
	/// borderless fullscreen desktop mode, or one of the fullscreen<br/>
	/// modes returned by SDL_GetFullscreenDisplayModes() to set an<br/>
	/// exclusive fullscreen mode.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowFullscreenMode<br/>
	/// @sa SDL_SetWindowFullscreen<br/>
	/// @sa SDL_SyncWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowFullscreenMode")]
	public static partial SDLBool SDL_SetWindowFullscreenMode(SDL_Window window, SDL_DisplayMode* mode);

	/// <summary>
	/// Query the display mode to use when a window is visible at fullscreen.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns a pointer to the exclusive fullscreen mode to use or NULL for<br/>
	/// borderless fullscreen desktop mode.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowFullscreenMode<br/>
	/// @sa SDL_SetWindowFullscreen
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowFullscreenMode")]
	public static partial SDL_DisplayMode* SDL_GetWindowFullscreenMode(SDL_Window window);

	/// <summary>
	/// Get the raw ICC profile data for the screen the window is currently on.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @param size the size of the ICC profile.<br/>
	/// @returns the raw ICC profile data on success or NULL on failure; call<br/>
	/// SDL_GetError() for more information. This should be freed with<br/>
	/// SDL_free() when it is no longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowICCProfile")]
	public static partial nint SDL_GetWindowICCProfile(SDL_Window window, nuint* size);

	/// <summary>
	/// Get the pixel format associated with the window.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns the pixel format of the window on success or<br/>
	/// SDL_PIXELFORMAT_UNKNOWN on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowPixelFormat")]
	public static partial SDL_PixelFormat SDL_GetWindowPixelFormat(SDL_Window window);

	/// <summary>
	/// Get a list of valid windows.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of windows returned, may<br/>
	/// be NULL.<br/>
	/// @returns a NULL terminated array of SDL_Window pointers or NULL on failure;<br/>
	/// call SDL_GetError() for more information. This is a single<br/>
	/// allocation that should be freed with SDL_free() when it is no<br/>
	/// longer needed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindows")]
	public static partial SDL_Window SDL_GetWindows(out int count);

	/// <summary>
	/// Create a window with the specified dimensions and flags.<br/>
	/// `flags` may be any of the following OR'd together:<br/>
	/// - `SDL_WINDOW_FULLSCREEN`: fullscreen window at desktop resolution<br/>
	/// - `SDL_WINDOW_OPENGL`: window usable with an OpenGL context<br/>
	/// - `SDL_WINDOW_OCCLUDED`: window partially or completely obscured by another<br/>
	/// window<br/>
	/// - `SDL_WINDOW_HIDDEN`: window is not visible<br/>
	/// - `SDL_WINDOW_BORDERLESS`: no window decoration<br/>
	/// - `SDL_WINDOW_RESIZABLE`: window can be resized<br/>
	/// - `SDL_WINDOW_MINIMIZED`: window is minimized<br/>
	/// - `SDL_WINDOW_MAXIMIZED`: window is maximized<br/>
	/// - `SDL_WINDOW_MOUSE_GRABBED`: window has grabbed mouse focus<br/>
	/// - `SDL_WINDOW_INPUT_FOCUS`: window has input focus<br/>
	/// - `SDL_WINDOW_MOUSE_FOCUS`: window has mouse focus<br/>
	/// - `SDL_WINDOW_EXTERNAL`: window not created by SDL<br/>
	/// - `SDL_WINDOW_MODAL`: window is modal<br/>
	/// - `SDL_WINDOW_HIGH_PIXEL_DENSITY`: window uses high pixel density back<br/>
	/// buffer if possible<br/>
	/// - `SDL_WINDOW_MOUSE_CAPTURE`: window has mouse captured (unrelated to<br/>
	/// MOUSE_GRABBED)<br/>
	/// - `SDL_WINDOW_ALWAYS_ON_TOP`: window should always be above others<br/>
	/// - `SDL_WINDOW_UTILITY`: window should be treated as a utility window, not<br/>
	/// showing in the task bar and window list<br/>
	/// - `SDL_WINDOW_TOOLTIP`: window should be treated as a tooltip and does not<br/>
	/// get mouse or keyboard focus, requires a parent window<br/>
	/// - `SDL_WINDOW_POPUP_MENU`: window should be treated as a popup menu,<br/>
	/// requires a parent window<br/>
	/// - `SDL_WINDOW_KEYBOARD_GRABBED`: window has grabbed keyboard input<br/>
	/// - `SDL_WINDOW_VULKAN`: window usable with a Vulkan instance<br/>
	/// - `SDL_WINDOW_METAL`: window usable with a Metal instance<br/>
	/// - `SDL_WINDOW_TRANSPARENT`: window with transparent buffer<br/>
	/// - `SDL_WINDOW_NOT_FOCUSABLE`: window should not be focusable<br/>
	/// The SDL_Window is implicitly shown if SDL_WINDOW_HIDDEN is not set.<br/>
	/// On Apple's macOS, you **must** set the NSHighResolutionCapable Info.plist<br/>
	/// property to YES, otherwise you will not receive a High-DPI OpenGL canvas.<br/>
	/// The window pixel size may differ from its window coordinate size if the<br/>
	/// window is on a high pixel density display. Use SDL_GetWindowSize() to query<br/>
	/// the client area's size in window coordinates, and<br/>
	/// SDL_GetWindowSizeInPixels() or SDL_GetRenderOutputSize() to query the<br/>
	/// drawable size in pixels. Note that the drawable size can vary after the<br/>
	/// window is created and should be queried again if you get an<br/>
	/// SDL_EVENT_WINDOW_PIXEL_SIZE_CHANGED event.<br/>
	/// If the window is created with any of the SDL_WINDOW_OPENGL or<br/>
	/// SDL_WINDOW_VULKAN flags, then the corresponding LoadLibrary function<br/>
	/// (SDL_GL_LoadLibrary or SDL_Vulkan_LoadLibrary) is called and the<br/>
	/// corresponding UnloadLibrary function is called by SDL_DestroyWindow().<br/>
	/// If SDL_WINDOW_VULKAN is specified and there isn't a working Vulkan driver,<br/>
	/// SDL_CreateWindow() will fail because SDL_Vulkan_LoadLibrary() will fail.<br/>
	/// If SDL_WINDOW_METAL is specified on an OS that does not support Metal,<br/>
	/// SDL_CreateWindow() will fail.<br/>
	/// If you intend to use this window with an SDL_Renderer, you should use<br/>
	/// SDL_CreateWindowAndRenderer() instead of this function, to avoid window<br/>
	/// flicker.<br/>
	/// On non-Apple devices, SDL requires you to either not link to the Vulkan<br/>
	/// loader or link to a dynamic library version. This limitation may be removed<br/>
	/// in a future version of SDL.<br/>
	/// <br/>
	/// @param title the title of the window, in UTF-8 encoding.<br/>
	/// @param w the width of the window.<br/>
	/// @param h the height of the window.<br/>
	/// @param flags 0, or one or more SDL_WindowFlags OR'd together.<br/>
	/// @returns the window that was created or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreatePopupWindow<br/>
	/// @sa SDL_CreateWindowWithProperties<br/>
	/// @sa SDL_DestroyWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateWindow")]
	public static partial SDL_Window SDL_CreateWindow(byte* title, int w, int h, SDL_WindowFlags flags);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateWindow")]
	public static partial SDL_Window SDL_CreateWindow(ReadOnlySpan<byte> title, int w, int h, SDL_WindowFlags flags);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateWindow")]
	public static partial SDL_Window SDL_CreateWindow([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> title, int w, int h, SDL_WindowFlags flags);

	/// <summary>
	/// Create a child popup window of the specified parent window.<br/>
	/// 'flags' **must** contain exactly one of the following: -<br/>
	/// 'SDL_WINDOW_TOOLTIP': The popup window is a tooltip and will not pass any<br/>
	/// input events. - 'SDL_WINDOW_POPUP_MENU': The popup window is a popup menu.<br/>
	/// The topmost popup menu will implicitly gain the keyboard focus.<br/>
	/// The following flags are not relevant to popup window creation and will be<br/>
	/// ignored:<br/>
	/// - 'SDL_WINDOW_MINIMIZED'<br/>
	/// - 'SDL_WINDOW_MAXIMIZED'<br/>
	/// - 'SDL_WINDOW_FULLSCREEN'<br/>
	/// - 'SDL_WINDOW_BORDERLESS'<br/>
	/// The parent parameter **must** be non-null and a valid window. The parent of<br/>
	/// a popup window can be either a regular, toplevel window, or another popup<br/>
	/// window.<br/>
	/// Popup windows cannot be minimized, maximized, made fullscreen, raised,<br/>
	/// flash, be made a modal window, be the parent of a modal window, or grab the<br/>
	/// mouse and/or keyboard. Attempts to do so will fail.<br/>
	/// Popup windows implicitly do not have a border/decorations and do not appear<br/>
	/// on the taskbar/dock or in lists of windows such as alt-tab menus.<br/>
	/// If a parent window is hidden, any child popup windows will be recursively<br/>
	/// hidden as well. Child popup windows not explicitly hidden will be restored<br/>
	/// when the parent is shown.<br/>
	/// If the parent window is destroyed, any child popup windows will be<br/>
	/// recursively destroyed as well.<br/>
	/// <br/>
	/// @param parent the parent of the window, must not be NULL.<br/>
	/// @param offset_x the x position of the popup window relative to the origin<br/>
	/// of the parent.<br/>
	/// @param offset_y the y position of the popup window relative to the origin<br/>
	/// of the parent window.<br/>
	/// @param w the width of the window.<br/>
	/// @param h the height of the window.<br/>
	/// @param flags SDL_WINDOW_TOOLTIP or SDL_WINDOW_POPUP_MENU, and zero or more<br/>
	/// additional SDL_WindowFlags OR'd together.<br/>
	/// @returns the window that was created or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateWindow<br/>
	/// @sa SDL_CreateWindowWithProperties<br/>
	/// @sa SDL_DestroyWindow<br/>
	/// @sa SDL_GetWindowParent
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreatePopupWindow")]
	public static partial SDL_Window SDL_CreatePopupWindow(SDL_Window parent, int offset_x, int offset_y, int w, int h, SDL_WindowFlags flags);

	/// <summary>
	/// Create a window with the specified properties.<br/>
	/// These are the supported properties:<br/>
	/// - `SDL_PROP_WINDOW_CREATE_ALWAYS_ON_TOP_BOOLEAN`: true if the window should<br/>
	/// be always on top<br/>
	/// - `SDL_PROP_WINDOW_CREATE_BORDERLESS_BOOLEAN`: true if the window has no<br/>
	/// window decoration<br/>
	/// - `SDL_PROP_WINDOW_CREATE_EXTERNAL_GRAPHICS_CONTEXT_BOOLEAN`: true if the<br/>
	/// window will be used with an externally managed graphics context.<br/>
	/// - `SDL_PROP_WINDOW_CREATE_FOCUSABLE_BOOLEAN`: true if the window should<br/>
	/// accept keyboard input (defaults true)<br/>
	/// - `SDL_PROP_WINDOW_CREATE_FULLSCREEN_BOOLEAN`: true if the window should<br/>
	/// start in fullscreen mode at desktop resolution<br/>
	/// - `SDL_PROP_WINDOW_CREATE_HEIGHT_NUMBER`: the height of the window<br/>
	/// - `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN`: true if the window should start<br/>
	/// hidden<br/>
	/// - `SDL_PROP_WINDOW_CREATE_HIGH_PIXEL_DENSITY_BOOLEAN`: true if the window<br/>
	/// uses a high pixel density buffer if possible<br/>
	/// - `SDL_PROP_WINDOW_CREATE_MAXIMIZED_BOOLEAN`: true if the window should<br/>
	/// start maximized<br/>
	/// - `SDL_PROP_WINDOW_CREATE_MENU_BOOLEAN`: true if the window is a popup menu<br/>
	/// - `SDL_PROP_WINDOW_CREATE_METAL_BOOLEAN`: true if the window will be used<br/>
	/// with Metal rendering<br/>
	/// - `SDL_PROP_WINDOW_CREATE_MINIMIZED_BOOLEAN`: true if the window should<br/>
	/// start minimized<br/>
	/// - `SDL_PROP_WINDOW_CREATE_MODAL_BOOLEAN`: true if the window is modal to<br/>
	/// its parent<br/>
	/// - `SDL_PROP_WINDOW_CREATE_MOUSE_GRABBED_BOOLEAN`: true if the window starts<br/>
	/// with grabbed mouse focus<br/>
	/// - `SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`: true if the window will be used<br/>
	/// with OpenGL rendering<br/>
	/// - `SDL_PROP_WINDOW_CREATE_PARENT_POINTER`: an SDL_Window that will be the<br/>
	/// parent of this window, required for windows with the "toolip", "menu",<br/>
	/// and "modal" properties<br/>
	/// - `SDL_PROP_WINDOW_CREATE_RESIZABLE_BOOLEAN`: true if the window should be<br/>
	/// resizable<br/>
	/// - `SDL_PROP_WINDOW_CREATE_TITLE_STRING`: the title of the window, in UTF-8<br/>
	/// encoding<br/>
	/// - `SDL_PROP_WINDOW_CREATE_TRANSPARENT_BOOLEAN`: true if the window show<br/>
	/// transparent in the areas with alpha of 0<br/>
	/// - `SDL_PROP_WINDOW_CREATE_TOOLTIP_BOOLEAN`: true if the window is a tooltip<br/>
	/// - `SDL_PROP_WINDOW_CREATE_UTILITY_BOOLEAN`: true if the window is a utility<br/>
	/// window, not showing in the task bar and window list<br/>
	/// - `SDL_PROP_WINDOW_CREATE_VULKAN_BOOLEAN`: true if the window will be used<br/>
	/// with Vulkan rendering<br/>
	/// - `SDL_PROP_WINDOW_CREATE_WIDTH_NUMBER`: the width of the window<br/>
	/// - `SDL_PROP_WINDOW_CREATE_X_NUMBER`: the x position of the window, or<br/>
	/// `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is<br/>
	/// relative to the parent for windows with the "parent" property set.<br/>
	/// - `SDL_PROP_WINDOW_CREATE_Y_NUMBER`: the y position of the window, or<br/>
	/// `SDL_WINDOWPOS_CENTERED`, defaults to `SDL_WINDOWPOS_UNDEFINED`. This is<br/>
	/// relative to the parent for windows with the "parent" property set.<br/>
	/// These are additional supported properties on macOS:<br/>
	/// - `SDL_PROP_WINDOW_CREATE_COCOA_WINDOW_POINTER`: the<br/>
	/// `(__unsafe_unretained)` NSWindow associated with the window, if you want<br/>
	/// to wrap an existing window.<br/>
	/// - `SDL_PROP_WINDOW_CREATE_COCOA_VIEW_POINTER`: the `(__unsafe_unretained)`<br/>
	/// NSView associated with the window, defaults to `[window contentView]`<br/>
	/// These are additional supported properties on Wayland:<br/>
	/// - `SDL_PROP_WINDOW_CREATE_WAYLAND_SURFACE_ROLE_CUSTOM_BOOLEAN` - true if<br/>
	/// the application wants to use the Wayland surface for a custom role and<br/>
	/// does not want it attached to an XDG toplevel window. See<br/>
	/// [README/wayland](README/wayland) for more information on using custom<br/>
	/// surfaces.<br/>
	/// - `SDL_PROP_WINDOW_CREATE_WAYLAND_CREATE_EGL_WINDOW_BOOLEAN` - true if the<br/>
	/// application wants an associated `wl_egl_window` object to be created,<br/>
	/// even if the window does not have the OpenGL property or flag set.<br/>
	/// - `SDL_PROP_WINDOW_CREATE_WAYLAND_WL_SURFACE_POINTER` - the wl_surface<br/>
	/// associated with the window, if you want to wrap an existing window. See<br/>
	/// [README/wayland](README/wayland) for more information.<br/>
	/// These are additional supported properties on Windows:<br/>
	/// - `SDL_PROP_WINDOW_CREATE_WIN32_HWND_POINTER`: the HWND associated with the<br/>
	/// window, if you want to wrap an existing window.<br/>
	/// - `SDL_PROP_WINDOW_CREATE_WIN32_PIXEL_FORMAT_HWND_POINTER`: optional,<br/>
	/// another window to share pixel format with, useful for OpenGL windows<br/>
	/// These are additional supported properties with X11:<br/>
	/// - `SDL_PROP_WINDOW_CREATE_X11_WINDOW_NUMBER`: the X11 Window associated<br/>
	/// with the window, if you want to wrap an existing window.<br/>
	/// The window is implicitly shown if the "hidden" property is not set.<br/>
	/// Windows with the "tooltip" and "menu" properties are popup windows and have<br/>
	/// the behaviors and guidelines outlined in SDL_CreatePopupWindow().<br/>
	/// If this window is being created to be used with an SDL_Renderer, you should<br/>
	/// not add a graphics API specific property<br/>
	/// (`SDL_PROP_WINDOW_CREATE_OPENGL_BOOLEAN`, etc), as SDL will handle that<br/>
	/// internally when it chooses a renderer. However, SDL might need to recreate<br/>
	/// your window at that point, which may cause the window to appear briefly,<br/>
	/// and then flicker as it is recreated. The correct approach to this is to<br/>
	/// create the window with the `SDL_PROP_WINDOW_CREATE_HIDDEN_BOOLEAN` property<br/>
	/// set to true, then create the renderer, then show the window with<br/>
	/// SDL_ShowWindow().<br/>
	/// <br/>
	/// @param props the properties to use.<br/>
	/// @returns the window that was created or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProperties<br/>
	/// @sa SDL_CreateWindow<br/>
	/// @sa SDL_DestroyWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateWindowWithProperties")]
	public static partial SDL_Window SDL_CreateWindowWithProperties(SDL_PropertiesID props);

	/// <summary>
	/// Get the numeric ID of a window.<br/>
	/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
	/// these events to specific SDL_Window objects.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns the ID of the window on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowFromID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowID")]
	public static partial SDL_WindowID SDL_GetWindowID(SDL_Window window);

	/// <summary>
	/// Get a window from a stored ID.<br/>
	/// The numeric ID is what SDL_WindowEvent references, and is necessary to map<br/>
	/// these events to specific SDL_Window objects.<br/>
	/// <br/>
	/// @param id the ID of the window.<br/>
	/// @returns the window associated with `id` or NULL if it doesn't exist; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowID
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowFromID")]
	public static partial SDL_Window SDL_GetWindowFromID(SDL_WindowID id);

	/// <summary>
	/// Get parent of a window.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns the parent of the window on success or NULL if the window has no<br/>
	/// parent.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreatePopupWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowParent")]
	public static partial SDL_Window SDL_GetWindowParent(SDL_Window window);

	/// <summary>
	/// Get the properties associated with a window.<br/>
	/// The following read-only properties are provided by SDL:<br/>
	/// - `SDL_PROP_WINDOW_SHAPE_POINTER`: the surface associated with a shaped<br/>
	/// window<br/>
	/// - `SDL_PROP_WINDOW_HDR_ENABLED_BOOLEAN`: true if the window has HDR<br/>
	/// headroom above the SDR white point. This property can change dynamically<br/>
	/// when SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
	/// - `SDL_PROP_WINDOW_SDR_WHITE_LEVEL_FLOAT`: the value of SDR white in the<br/>
	/// SDL_COLORSPACE_SRGB_LINEAR colorspace. On Windows this corresponds to the<br/>
	/// SDR white level in scRGB colorspace, and on Apple platforms this is<br/>
	/// always 1.0 for EDR content. This property can change dynamically when<br/>
	/// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
	/// - `SDL_PROP_WINDOW_HDR_HEADROOM_FLOAT`: the additional high dynamic range<br/>
	/// that can be displayed, in terms of the SDR white point. When HDR is not<br/>
	/// enabled, this will be 1.0. This property can change dynamically when<br/>
	/// SDL_EVENT_WINDOW_HDR_STATE_CHANGED is sent.<br/>
	/// On Android:<br/>
	/// - `SDL_PROP_WINDOW_ANDROID_WINDOW_POINTER`: the ANativeWindow associated<br/>
	/// with the window<br/>
	/// - `SDL_PROP_WINDOW_ANDROID_SURFACE_POINTER`: the EGLSurface associated with<br/>
	/// the window<br/>
	/// On iOS:<br/>
	/// - `SDL_PROP_WINDOW_UIKIT_WINDOW_POINTER`: the `(__unsafe_unretained)`<br/>
	/// UIWindow associated with the window<br/>
	/// - `SDL_PROP_WINDOW_UIKIT_METAL_VIEW_TAG_NUMBER`: the NSInteger tag<br/>
	/// assocated with metal views on the window<br/>
	/// - `SDL_PROP_WINDOW_UIKIT_OPENGL_FRAMEBUFFER_NUMBER`: the OpenGL view's<br/>
	/// framebuffer object. It must be bound when rendering to the screen using<br/>
	/// OpenGL.<br/>
	/// - `SDL_PROP_WINDOW_UIKIT_OPENGL_RENDERBUFFER_NUMBER`: the OpenGL view's<br/>
	/// renderbuffer object. It must be bound when SDL_GL_SwapWindow is called.<br/>
	/// - `SDL_PROP_WINDOW_UIKIT_OPENGL_RESOLVE_FRAMEBUFFER_NUMBER`: the OpenGL<br/>
	/// view's resolve framebuffer, when MSAA is used.<br/>
	/// On KMS/DRM:<br/>
	/// - `SDL_PROP_WINDOW_KMSDRM_DEVICE_INDEX_NUMBER`: the device index associated<br/>
	/// with the window (e.g. the X in /dev/dri/cardX)<br/>
	/// - `SDL_PROP_WINDOW_KMSDRM_DRM_FD_NUMBER`: the DRM FD associated with the<br/>
	/// window<br/>
	/// - `SDL_PROP_WINDOW_KMSDRM_GBM_DEVICE_POINTER`: the GBM device associated<br/>
	/// with the window<br/>
	/// On macOS:<br/>
	/// - `SDL_PROP_WINDOW_COCOA_WINDOW_POINTER`: the `(__unsafe_unretained)`<br/>
	/// NSWindow associated with the window<br/>
	/// - `SDL_PROP_WINDOW_COCOA_METAL_VIEW_TAG_NUMBER`: the NSInteger tag<br/>
	/// assocated with metal views on the window<br/>
	/// On Vivante:<br/>
	/// - `SDL_PROP_WINDOW_VIVANTE_DISPLAY_POINTER`: the EGLNativeDisplayType<br/>
	/// associated with the window<br/>
	/// - `SDL_PROP_WINDOW_VIVANTE_WINDOW_POINTER`: the EGLNativeWindowType<br/>
	/// associated with the window<br/>
	/// - `SDL_PROP_WINDOW_VIVANTE_SURFACE_POINTER`: the EGLSurface associated with<br/>
	/// the window<br/>
	/// On Windows:<br/>
	/// - `SDL_PROP_WINDOW_WIN32_HWND_POINTER`: the HWND associated with the window<br/>
	/// - `SDL_PROP_WINDOW_WIN32_HDC_POINTER`: the HDC associated with the window<br/>
	/// - `SDL_PROP_WINDOW_WIN32_INSTANCE_POINTER`: the HINSTANCE associated with<br/>
	/// the window<br/>
	/// On Wayland:<br/>
	/// Note: The `xdg_*` window objects do not internally persist across window<br/>
	/// show/hide calls. They will be null if the window is hidden and must be<br/>
	/// queried each time it is shown.<br/>
	/// - `SDL_PROP_WINDOW_WAYLAND_DISPLAY_POINTER`: the wl_display associated with<br/>
	/// the window<br/>
	/// - `SDL_PROP_WINDOW_WAYLAND_SURFACE_POINTER`: the wl_surface associated with<br/>
	/// the window<br/>
	/// - `SDL_PROP_WINDOW_WAYLAND_EGL_WINDOW_POINTER`: the wl_egl_window<br/>
	/// associated with the window<br/>
	/// - `SDL_PROP_WINDOW_WAYLAND_XDG_SURFACE_POINTER`: the xdg_surface associated<br/>
	/// with the window<br/>
	/// - `SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_POINTER`: the xdg_toplevel role<br/>
	/// associated with the window<br/>
	/// - 'SDL_PROP_WINDOW_WAYLAND_XDG_TOPLEVEL_EXPORT_HANDLE_STRING': the export<br/>
	/// handle associated with the window<br/>
	/// - `SDL_PROP_WINDOW_WAYLAND_XDG_POPUP_POINTER`: the xdg_popup role<br/>
	/// associated with the window<br/>
	/// - `SDL_PROP_WINDOW_WAYLAND_XDG_POSITIONER_POINTER`: the xdg_positioner<br/>
	/// associated with the window, in popup mode<br/>
	/// On X11:<br/>
	/// - `SDL_PROP_WINDOW_X11_DISPLAY_POINTER`: the X11 Display associated with<br/>
	/// the window<br/>
	/// - `SDL_PROP_WINDOW_X11_SCREEN_NUMBER`: the screen number associated with<br/>
	/// the window<br/>
	/// - `SDL_PROP_WINDOW_X11_WINDOW_NUMBER`: the X11 Window associated with the<br/>
	/// window<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowProperties")]
	public static partial SDL_PropertiesID SDL_GetWindowProperties(SDL_Window window);

	/// <summary>
	/// Get the window flags.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns a mask of the SDL_WindowFlags associated with `window`.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateWindow<br/>
	/// @sa SDL_HideWindow<br/>
	/// @sa SDL_MaximizeWindow<br/>
	/// @sa SDL_MinimizeWindow<br/>
	/// @sa SDL_SetWindowFullscreen<br/>
	/// @sa SDL_SetWindowMouseGrab<br/>
	/// @sa SDL_ShowWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowFlags")]
	public static partial SDL_WindowFlags SDL_GetWindowFlags(SDL_Window window);

	/// <summary>
	/// Set the title of a window.<br/>
	/// This string is expected to be in UTF-8 encoding.<br/>
	/// <br/>
	/// @param window the window to change.<br/>
	/// @param title the desired window title in UTF-8 format.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowTitle
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowTitle")]
	public static partial SDLBool SDL_SetWindowTitle(SDL_Window window, byte* title);

	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowTitle")]
	public static partial SDLBool SDL_SetWindowTitle(SDL_Window window, ReadOnlySpan<byte> title);

	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowTitle")]
	public static partial SDLBool SDL_SetWindowTitle(SDL_Window window, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> title);

	/// <summary>
	/// Get the title of a window.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns the title of the window in UTF-8 format or "" if there is no<br/>
	/// title.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowTitle
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowTitle")]
	public static partial byte* SDL_GetWindowTitlePtr(SDL_Window window);

	public static string? SDL_GetWindowTitle(SDL_Window window)
	{
		return ConvertToManaged(SDL_GetWindowTitlePtr(window));
	}

	/// <summary>
	/// Set the icon for a window.<br/>
	/// If this function is passed a surface with alternate representations, the<br/>
	/// surface will be interpreted as the content to be used for 100% display<br/>
	/// scale, and the alternate representations will be used for high DPI<br/>
	/// situations. For example, if the original surface is 32x32, then on a 2x<br/>
	/// macOS display or 200% display scale on Windows, a 64x64 version of the<br/>
	/// image will be used, if available. If a matching version of the image isn't<br/>
	/// available, the closest larger size image will be downscaled to the<br/>
	/// appropriate size and be used instead, if available. Otherwise, the closest<br/>
	/// smaller image will be upscaled and be used instead.<br/>
	/// <br/>
	/// @param window the window to change.<br/>
	/// @param icon an SDL_Surface structure containing the icon for the window.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowIcon")]
	public static partial SDLBool SDL_SetWindowIcon(SDL_Window window, SDL_Surface* icon);

	/// <summary>
	/// Request that the window's position be set.<br/>
	/// If, at the time of this request, the window is in a fixed-size state such<br/>
	/// as maximized, this request may be deferred until the window returns to a<br/>
	/// resizable state.<br/>
	/// This can be used to reposition fullscreen-desktop windows onto a different<br/>
	/// display, however, exclusive fullscreen windows are locked to a specific<br/>
	/// display and can only be repositioned programmatically via<br/>
	/// SDL_SetWindowFullscreenMode().<br/>
	/// On some windowing systems this request is asynchronous and the new<br/>
	/// coordinates may not have have been applied immediately upon the return of<br/>
	/// this function. If an immediate change is required, call SDL_SyncWindow() to<br/>
	/// block until the changes have taken effect.<br/>
	/// When the window position changes, an SDL_EVENT_WINDOW_MOVED event will be<br/>
	/// emitted with the window's new coordinates. Note that the new coordinates<br/>
	/// may not match the exact coordinates requested, as some windowing systems<br/>
	/// can restrict the position of the window in certain scenarios (e.g.<br/>
	/// constraining the position so the window is always within desktop bounds).<br/>
	/// Additionally, as this is just a request, it can be denied by the windowing<br/>
	/// system.<br/>
	/// <br/>
	/// @param window the window to reposition.<br/>
	/// @param x the x coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or<br/>
	/// `SDL_WINDOWPOS_UNDEFINED`.<br/>
	/// @param y the y coordinate of the window, or `SDL_WINDOWPOS_CENTERED` or<br/>
	/// `SDL_WINDOWPOS_UNDEFINED`.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowPosition<br/>
	/// @sa SDL_SyncWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowPosition")]
	public static partial SDLBool SDL_SetWindowPosition(SDL_Window window, int x, int y);

	/// <summary>
	/// Get the position of a window.<br/>
	/// This is the current position of the window as last reported by the<br/>
	/// windowing system.<br/>
	/// If you do not need the value for one of the positions a NULL may be passed<br/>
	/// in the `x` or `y` parameter.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @param x a pointer filled in with the x position of the window, may be<br/>
	/// NULL.<br/>
	/// @param y a pointer filled in with the y position of the window, may be<br/>
	/// NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowPosition
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowPosition")]
	public static partial SDLBool SDL_GetWindowPosition(SDL_Window window, out int x, out int y);

	/// <summary>
	/// Request that the size of a window's client area be set.<br/>
	/// If, at the time of this request, the window in a fixed-size state, such as<br/>
	/// maximized or fullscreen, the request will be deferred until the window<br/>
	/// exits this state and becomes resizable again.<br/>
	/// To change the fullscreen mode of a window, use<br/>
	/// SDL_SetWindowFullscreenMode()<br/>
	/// On some windowing systems, this request is asynchronous and the new window<br/>
	/// size may not have have been applied immediately upon the return of this<br/>
	/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
	/// block until the changes have taken effect.<br/>
	/// When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be<br/>
	/// emitted with the new window dimensions. Note that the new dimensions may<br/>
	/// not match the exact size requested, as some windowing systems can restrict<br/>
	/// the window size in certain scenarios (e.g. constraining the size of the<br/>
	/// content area to remain within the usable desktop bounds). Additionally, as<br/>
	/// this is just a request, it can be denied by the windowing system.<br/>
	/// <br/>
	/// @param window the window to change.<br/>
	/// @param w the width of the window, must be > 0.<br/>
	/// @param h the height of the window, must be > 0.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowSize<br/>
	/// @sa SDL_SetWindowFullscreenMode<br/>
	/// @sa SDL_SyncWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowSize")]
	public static partial SDLBool SDL_SetWindowSize(SDL_Window window, int w, int h);

	/// <summary>
	/// Get the size of a window's client area.<br/>
	/// The window pixel size may differ from its window coordinate size if the<br/>
	/// window is on a high pixel density display. Use SDL_GetWindowSizeInPixels()<br/>
	/// or SDL_GetRenderOutputSize() to get the real client area size in pixels.<br/>
	/// <br/>
	/// @param window the window to query the width and height from.<br/>
	/// @param w a pointer filled in with the width of the window, may be NULL.<br/>
	/// @param h a pointer filled in with the height of the window, may be NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetRenderOutputSize<br/>
	/// @sa SDL_GetWindowSizeInPixels<br/>
	/// @sa SDL_SetWindowSize
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowSize")]
	public static partial SDLBool SDL_GetWindowSize(SDL_Window window, out int w, out int h);

	/// <summary>
	/// Get the safe area for this window.<br/>
	/// Some devices have portions of the screen which are partially obscured or<br/>
	/// not interactive, possibly due to on-screen controls, curved edges, camera<br/>
	/// notches, TV overscan, etc. This function provides the area of the window<br/>
	/// which is safe to have interactible content. You should continue rendering<br/>
	/// into the rest of the window, but it should not contain visually important<br/>
	/// or interactible content.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @param rect a pointer filled in with the client area that is safe for<br/>
	/// interactive content.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowSafeArea")]
	public static partial SDLBool SDL_GetWindowSafeArea(SDL_Window window, Rectangle* rect);

	/// <summary>
	/// Request that the aspect ratio of a window's client area be set.<br/>
	/// The aspect ratio is the ratio of width divided by height, e.g. 2560x1600<br/>
	/// would be 1.6. Larger aspect ratios are wider and smaller aspect ratios are<br/>
	/// narrower.<br/>
	/// If, at the time of this request, the window in a fixed-size state, such as<br/>
	/// maximized or fullscreen, the request will be deferred until the window<br/>
	/// exits this state and becomes resizable again.<br/>
	/// On some windowing systems, this request is asynchronous and the new window<br/>
	/// aspect ratio may not have have been applied immediately upon the return of<br/>
	/// this function. If an immediate change is required, call SDL_SyncWindow() to<br/>
	/// block until the changes have taken effect.<br/>
	/// When the window size changes, an SDL_EVENT_WINDOW_RESIZED event will be<br/>
	/// emitted with the new window dimensions. Note that the new dimensions may<br/>
	/// not match the exact aspect ratio requested, as some windowing systems can<br/>
	/// restrict the window size in certain scenarios (e.g. constraining the size<br/>
	/// of the content area to remain within the usable desktop bounds).<br/>
	/// Additionally, as this is just a request, it can be denied by the windowing<br/>
	/// system.<br/>
	/// <br/>
	/// @param window the window to change.<br/>
	/// @param min_aspect the minimum aspect ratio of the window, or 0.0f for no<br/>
	/// limit.<br/>
	/// @param max_aspect the maximum aspect ratio of the window, or 0.0f for no<br/>
	/// limit.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowAspectRatio<br/>
	/// @sa SDL_SyncWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowAspectRatio")]
	public static partial SDLBool SDL_SetWindowAspectRatio(SDL_Window window, float min_aspect, float max_aspect);

	/// <summary>
	/// Get the size of a window's client area.<br/>
	/// <br/>
	/// @param window the window to query the width and height from.<br/>
	/// @param min_aspect a pointer filled in with the minimum aspect ratio of the<br/>
	/// window, may be NULL.<br/>
	/// @param max_aspect a pointer filled in with the maximum aspect ratio of the<br/>
	/// window, may be NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowAspectRatio
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowAspectRatio")]
	public static partial SDLBool SDL_GetWindowAspectRatio(SDL_Window window, float* min_aspect, float* max_aspect);

	/// <summary>
	/// Get the size of a window's borders (decorations) around the client area.<br/>
	/// Note: If this function fails (returns false), the size values will be<br/>
	/// initialized to 0, 0, 0, 0 (if a non-NULL pointer is provided), as if the<br/>
	/// window in question was borderless.<br/>
	/// Note: This function may fail on systems where the window has not yet been<br/>
	/// decorated by the display server (for example, immediately after calling<br/>
	/// SDL_CreateWindow). It is recommended that you wait at least until the<br/>
	/// window has been presented and composited, so that the window system has a<br/>
	/// chance to decorate the window and provide the border dimensions to SDL.<br/>
	/// This function also returns false if getting the information is not<br/>
	/// supported.<br/>
	/// <br/>
	/// @param window the window to query the size values of the border<br/>
	/// (decorations) from.<br/>
	/// @param top pointer to variable for storing the size of the top border; NULL<br/>
	/// is permitted.<br/>
	/// @param left pointer to variable for storing the size of the left border;<br/>
	/// NULL is permitted.<br/>
	/// @param bottom pointer to variable for storing the size of the bottom<br/>
	/// border; NULL is permitted.<br/>
	/// @param right pointer to variable for storing the size of the right border;<br/>
	/// NULL is permitted.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowSize
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowBordersSize")]
	public static partial SDLBool SDL_GetWindowBordersSize(SDL_Window window, int* top, int* left, int* bottom, int* right);

	/// <summary>
	/// Get the size of a window's client area, in pixels.<br/>
	/// <br/>
	/// @param window the window from which the drawable size should be queried.<br/>
	/// @param w a pointer to variable for storing the width in pixels, may be<br/>
	/// NULL.<br/>
	/// @param h a pointer to variable for storing the height in pixels, may be<br/>
	/// NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateWindow<br/>
	/// @sa SDL_GetWindowSize
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowSizeInPixels")]
	public static partial SDLBool SDL_GetWindowSizeInPixels(SDL_Window window, out int w, out int h);

	/// <summary>
	/// Set the minimum size of a window's client area.<br/>
	/// <br/>
	/// @param window the window to change.<br/>
	/// @param min_w the minimum width of the window, or 0 for no limit.<br/>
	/// @param min_h the minimum height of the window, or 0 for no limit.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowMinimumSize<br/>
	/// @sa SDL_SetWindowMaximumSize
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowMinimumSize")]
	public static partial SDLBool SDL_SetWindowMinimumSize(SDL_Window window, int min_w, int min_h);

	/// <summary>
	/// Get the minimum size of a window's client area.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @param w a pointer filled in with the minimum width of the window, may be<br/>
	/// NULL.<br/>
	/// @param h a pointer filled in with the minimum height of the window, may be<br/>
	/// NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowMaximumSize<br/>
	/// @sa SDL_SetWindowMinimumSize
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowMinimumSize")]
	public static partial SDLBool SDL_GetWindowMinimumSize(SDL_Window window, out int w, out int h);

	/// <summary>
	/// Set the maximum size of a window's client area.<br/>
	/// <br/>
	/// @param window the window to change.<br/>
	/// @param max_w the maximum width of the window, or 0 for no limit.<br/>
	/// @param max_h the maximum height of the window, or 0 for no limit.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowMaximumSize<br/>
	/// @sa SDL_SetWindowMinimumSize
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowMaximumSize")]
	public static partial SDLBool SDL_SetWindowMaximumSize(SDL_Window window, int max_w, int max_h);

	/// <summary>
	/// Get the maximum size of a window's client area.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @param w a pointer filled in with the maximum width of the window, may be<br/>
	/// NULL.<br/>
	/// @param h a pointer filled in with the maximum height of the window, may be<br/>
	/// NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowMinimumSize<br/>
	/// @sa SDL_SetWindowMaximumSize
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowMaximumSize")]
	public static partial SDLBool SDL_GetWindowMaximumSize(SDL_Window window, out int w, out int h);

	/// <summary>
	/// Set the border state of a window.<br/>
	/// This will add or remove the window's `SDL_WINDOW_BORDERLESS` flag and add<br/>
	/// or remove the border from the actual window. This is a no-op if the<br/>
	/// window's border already matches the requested state.<br/>
	/// You can't change the border state of a fullscreen window.<br/>
	/// <br/>
	/// @param window the window of which to change the border state.<br/>
	/// @param bordered false to remove border, true to add border.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowFlags
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowBordered")]
	public static partial SDLBool SDL_SetWindowBordered(SDL_Window window, SDLBool bordered);

	/// <summary>
	/// Set the user-resizable state of a window.<br/>
	/// This will add or remove the window's `SDL_WINDOW_RESIZABLE` flag and<br/>
	/// allow/disallow user resizing of the window. This is a no-op if the window's<br/>
	/// resizable state already matches the requested state.<br/>
	/// You can't change the resizable state of a fullscreen window.<br/>
	/// <br/>
	/// @param window the window of which to change the resizable state.<br/>
	/// @param resizable true to allow resizing, false to disallow.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowFlags
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowResizable")]
	public static partial SDLBool SDL_SetWindowResizable(SDL_Window window, SDLBool resizable);

	/// <summary>
	/// Set the window to always be above the others.<br/>
	/// This will add or remove the window's `SDL_WINDOW_ALWAYS_ON_TOP` flag. This<br/>
	/// will bring the window to the front and keep the window above the rest.<br/>
	/// <br/>
	/// @param window the window of which to change the always on top state.<br/>
	/// @param on_top true to set the window always on top, false to disable.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowFlags
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowAlwaysOnTop")]
	public static partial SDLBool SDL_SetWindowAlwaysOnTop(SDL_Window window, SDLBool on_top);

	/// <summary>
	/// Show a window.<br/>
	/// <br/>
	/// @param window the window to show.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_HideWindow<br/>
	/// @sa SDL_RaiseWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShowWindow")]
	public static partial SDLBool SDL_ShowWindow(SDL_Window window);

	/// <summary>
	/// Hide a window.<br/>
	/// <br/>
	/// @param window the window to hide.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ShowWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_HideWindow")]
	public static partial SDLBool SDL_HideWindow(SDL_Window window);

	/// <summary>
	/// Request that a window be raised above other windows and gain the input<br/>
	/// focus.<br/>
	/// The result of this request is subject to desktop window manager policy,<br/>
	/// particularly if raising the requested window would result in stealing focus<br/>
	/// from another application. If the window is successfully raised and gains<br/>
	/// input focus, an SDL_EVENT_WINDOW_FOCUS_GAINED event will be emitted, and<br/>
	/// the window will have the SDL_WINDOW_INPUT_FOCUS flag set.<br/>
	/// <br/>
	/// @param window the window to raise.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RaiseWindow")]
	public static partial SDLBool SDL_RaiseWindow(SDL_Window window);

	/// <summary>
	/// Request that the window be made as large as possible.<br/>
	/// Non-resizable windows can't be maximized. The window must have the<br/>
	/// SDL_WINDOW_RESIZABLE flag set, or this will have no effect.<br/>
	/// On some windowing systems this request is asynchronous and the new window<br/>
	/// state may not have have been applied immediately upon the return of this<br/>
	/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
	/// block until the changes have taken effect.<br/>
	/// When the window state changes, an SDL_EVENT_WINDOW_MAXIMIZED event will be<br/>
	/// emitted. Note that, as this is just a request, the windowing system can<br/>
	/// deny the state change.<br/>
	/// When maximizing a window, whether the constraints set via<br/>
	/// SDL_SetWindowMaximumSize() are honored depends on the policy of the window<br/>
	/// manager. Win32 and macOS enforce the constraints when maximizing, while X11<br/>
	/// and Wayland window managers may vary.<br/>
	/// <br/>
	/// @param window the window to maximize.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_MinimizeWindow<br/>
	/// @sa SDL_RestoreWindow<br/>
	/// @sa SDL_SyncWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_MaximizeWindow")]
	public static partial SDLBool SDL_MaximizeWindow(SDL_Window window);

	/// <summary>
	/// Request that the window be minimized to an iconic representation.<br/>
	/// On some windowing systems this request is asynchronous and the new window<br/>
	/// state may not have have been applied immediately upon the return of this<br/>
	/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
	/// block until the changes have taken effect.<br/>
	/// When the window state changes, an SDL_EVENT_WINDOW_MINIMIZED event will be<br/>
	/// emitted. Note that, as this is just a request, the windowing system can<br/>
	/// deny the state change.<br/>
	/// <br/>
	/// @param window the window to minimize.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_MaximizeWindow<br/>
	/// @sa SDL_RestoreWindow<br/>
	/// @sa SDL_SyncWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_MinimizeWindow")]
	public static partial SDLBool SDL_MinimizeWindow(SDL_Window window);

	/// <summary>
	/// Request that the size and position of a minimized or maximized window be<br/>
	/// restored.<br/>
	/// On some windowing systems this request is asynchronous and the new window<br/>
	/// state may not have have been applied immediately upon the return of this<br/>
	/// function. If an immediate change is required, call SDL_SyncWindow() to<br/>
	/// block until the changes have taken effect.<br/>
	/// When the window state changes, an SDL_EVENT_WINDOW_RESTORED event will be<br/>
	/// emitted. Note that, as this is just a request, the windowing system can<br/>
	/// deny the state change.<br/>
	/// <br/>
	/// @param window the window to restore.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_MaximizeWindow<br/>
	/// @sa SDL_MinimizeWindow<br/>
	/// @sa SDL_SyncWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RestoreWindow")]
	public static partial SDLBool SDL_RestoreWindow(SDL_Window window);

	/// <summary>
	/// Request that the window's fullscreen state be changed.<br/>
	/// By default a window in fullscreen state uses borderless fullscreen desktop<br/>
	/// mode, but a specific exclusive display mode can be set using<br/>
	/// SDL_SetWindowFullscreenMode().<br/>
	/// On some windowing systems this request is asynchronous and the new<br/>
	/// fullscreen state may not have have been applied immediately upon the return<br/>
	/// of this function. If an immediate change is required, call SDL_SyncWindow()<br/>
	/// to block until the changes have taken effect.<br/>
	/// When the window state changes, an SDL_EVENT_WINDOW_ENTER_FULLSCREEN or<br/>
	/// SDL_EVENT_WINDOW_LEAVE_FULLSCREEN event will be emitted. Note that, as this<br/>
	/// is just a request, it can be denied by the windowing system.<br/>
	/// <br/>
	/// @param window the window to change.<br/>
	/// @param fullscreen true for fullscreen mode, false for windowed mode.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowFullscreenMode<br/>
	/// @sa SDL_SetWindowFullscreenMode<br/>
	/// @sa SDL_SyncWindow
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowFullscreen")]
	public static partial SDLBool SDL_SetWindowFullscreen(SDL_Window window, SDLBool fullscreen);

	/// <summary>
	/// Block until any pending window state is finalized.<br/>
	/// On asynchronous windowing systems, this acts as a synchronization barrier<br/>
	/// for pending window state. It will attempt to wait until any pending window<br/>
	/// state has been applied and is guaranteed to return within finite time. Note<br/>
	/// that for how long it can potentially block depends on the underlying window<br/>
	/// system, as window state changes may involve somewhat lengthy animations<br/>
	/// that must complete before the window is in its final requested state.<br/>
	/// On windowing systems where changes are immediate, this does nothing.<br/>
	/// <br/>
	/// @param window the window for which to wait for the pending state to be<br/>
	/// applied.<br/>
	/// @returns true on success or false if the operation timed out before the<br/>
	/// window was in the requested state.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowSize<br/>
	/// @sa SDL_SetWindowPosition<br/>
	/// @sa SDL_SetWindowFullscreen<br/>
	/// @sa SDL_MinimizeWindow<br/>
	/// @sa SDL_MaximizeWindow<br/>
	/// @sa SDL_RestoreWindow<br/>
	/// @sa SDL_HINT_VIDEO_SYNC_WINDOW_OPERATIONS
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SyncWindow")]
	public static partial SDLBool SDL_SyncWindow(SDL_Window window);

	/// <summary>
	/// Return whether the window has a surface associated with it.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns true if there is a surface associated with the window, or false<br/>
	/// otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WindowHasSurface")]
	public static partial SDLBool SDL_WindowHasSurface(SDL_Window window);

	/// <summary>
	/// Get the SDL surface associated with the window.<br/>
	/// A new surface will be created with the optimal format for the window, if<br/>
	/// necessary. This surface will be freed when the window is destroyed. Do not<br/>
	/// free this surface.<br/>
	/// This surface will be invalidated if the window is resized. After resizing a<br/>
	/// window this function must be called again to return a valid surface.<br/>
	/// You may not combine this with 3D or the rendering API on this window.<br/>
	/// This function is affected by `SDL_HINT_FRAMEBUFFER_ACCELERATION`.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns the surface associated with the window, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DestroyWindowSurface<br/>
	/// @sa SDL_WindowHasSurface<br/>
	/// @sa SDL_UpdateWindowSurface<br/>
	/// @sa SDL_UpdateWindowSurfaceRects
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowSurface")]
	public static partial SDL_Surface* SDL_GetWindowSurface(SDL_Window window);

	/// <summary>
	/// Toggle VSync for the window surface.<br/>
	/// When a window surface is created, vsync defaults to<br/>
	/// SDL_WINDOW_SURFACE_VSYNC_DISABLED.<br/>
	/// The `vsync` parameter can be 1 to synchronize present with every vertical<br/>
	/// refresh, 2 to synchronize present with every second vertical refresh, etc.,<br/>
	/// SDL_WINDOW_SURFACE_VSYNC_ADAPTIVE for late swap tearing (adaptive vsync),<br/>
	/// or SDL_WINDOW_SURFACE_VSYNC_DISABLED to disable. Not every value is<br/>
	/// supported by every driver, so you should check the return value to see<br/>
	/// whether the requested setting is supported.<br/>
	/// <br/>
	/// @param window the window.<br/>
	/// @param vsync the vertical refresh sync interval.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowSurfaceVSync
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowSurfaceVSync")]
	public static partial SDLBool SDL_SetWindowSurfaceVSync(SDL_Window window, int vsync);

	/// <summary>
	/// Get VSync for the window surface.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @param vsync an int filled with the current vertical refresh sync interval.<br/>
	/// See SDL_SetWindowSurfaceVSync() for the meaning of the value.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowSurfaceVSync
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowSurfaceVSync")]
	public static partial SDLBool SDL_GetWindowSurfaceVSync(SDL_Window window, int* vsync);

	/// <summary>
	/// Copy the window surface to the screen.<br/>
	/// This is the function you use to reflect any changes to the surface on the<br/>
	/// screen.<br/>
	/// This function is equivalent to the SDL 1.2 API SDL_Flip().<br/>
	/// <br/>
	/// @param window the window to update.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowSurface<br/>
	/// @sa SDL_UpdateWindowSurfaceRects
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UpdateWindowSurface")]
	public static partial SDLBool SDL_UpdateWindowSurface(SDL_Window window);

	/// <summary>
	/// Copy areas of the window surface to the screen.<br/>
	/// This is the function you use to reflect changes to portions of the surface<br/>
	/// on the screen.<br/>
	/// This function is equivalent to the SDL 1.2 API SDL_UpdateRects().<br/>
	/// Note that this function will update _at least_ the rectangles specified,<br/>
	/// but this is only intended as an optimization; in practice, this might<br/>
	/// update more of the screen (or all of the screen!), depending on what method<br/>
	/// SDL uses to send pixels to the system.<br/>
	/// <br/>
	/// @param window the window to update.<br/>
	/// @param rects an array of SDL_Rect structures representing areas of the<br/>
	/// surface to copy, in pixels.<br/>
	/// @param numrects the number of rectangles.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowSurface<br/>
	/// @sa SDL_UpdateWindowSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UpdateWindowSurfaceRects")]
	public static partial SDLBool SDL_UpdateWindowSurfaceRects(SDL_Window window, Rectangle* rects, int numrects);

	/// <summary>
	/// Destroy the surface associated with the window.<br/>
	/// <br/>
	/// @param window the window to update.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowSurface<br/>
	/// @sa SDL_WindowHasSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyWindowSurface")]
	public static partial SDLBool SDL_DestroyWindowSurface(SDL_Window window);

	/// <summary>
	/// Set a window's keyboard grab mode.<br/>
	/// Keyboard grab enables capture of system keyboard shortcuts like Alt+Tab or<br/>
	/// the Meta/Super key. Note that not all system keyboard shortcuts can be<br/>
	/// captured by applications (one example is Ctrl+Alt+Del on Windows).<br/>
	/// This is primarily intended for specialized applications such as VNC clients<br/>
	/// or VM frontends. Normal games should not use keyboard grab.<br/>
	/// When keyboard grab is enabled, SDL will continue to handle Alt+Tab when the<br/>
	/// window is full-screen to ensure the user is not trapped in your<br/>
	/// application. If you have a custom keyboard shortcut to exit fullscreen<br/>
	/// mode, you may suppress this behavior with<br/>
	/// `SDL_HINT_ALLOW_ALT_TAB_WHILE_GRABBED`.<br/>
	/// If the caller enables a grab while another window is currently grabbed, the<br/>
	/// other window loses its grab in favor of the caller's window.<br/>
	/// <br/>
	/// @param window the window for which the keyboard grab mode should be set.<br/>
	/// @param grabbed this is true to grab keyboard, and false to release.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowKeyboardGrab<br/>
	/// @sa SDL_SetWindowMouseGrab
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowKeyboardGrab")]
	public static partial SDLBool SDL_SetWindowKeyboardGrab(SDL_Window window, SDLBool grabbed);

	/// <summary>
	/// Set a window's mouse grab mode.<br/>
	/// Mouse grab confines the mouse cursor to the window.<br/>
	/// <br/>
	/// @param window the window for which the mouse grab mode should be set.<br/>
	/// @param grabbed this is true to grab mouse, and false to release.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowMouseGrab<br/>
	/// @sa SDL_SetWindowKeyboardGrab
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowMouseGrab")]
	public static partial SDLBool SDL_SetWindowMouseGrab(SDL_Window window, SDLBool grabbed);

	/// <summary>
	/// Get a window's keyboard grab mode.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns true if keyboard is grabbed, and false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowKeyboardGrab
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowKeyboardGrab")]
	public static partial SDLBool SDL_GetWindowKeyboardGrab(SDL_Window window);

	/// <summary>
	/// Get a window's mouse grab mode.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns true if mouse is grabbed, and false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowKeyboardGrab
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowMouseGrab")]
	public static partial SDLBool SDL_GetWindowMouseGrab(SDL_Window window);

	/// <summary>
	/// Get the window that currently has an input grab enabled.<br/>
	/// <br/>
	/// @returns the window if input is grabbed or NULL otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowMouseGrab<br/>
	/// @sa SDL_SetWindowKeyboardGrab
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGrabbedWindow")]
	public static partial SDL_Window SDL_GetGrabbedWindow();

	/// <summary>
	/// Confines the cursor to the specified area of a window.<br/>
	/// Note that this does NOT grab the cursor, it only defines the area a cursor<br/>
	/// is restricted to when the window has mouse focus.<br/>
	/// <br/>
	/// @param window the window that will be associated with the barrier.<br/>
	/// @param rect a rectangle area in window-relative coordinates. If NULL the<br/>
	/// barrier for the specified window will be destroyed.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowMouseRect<br/>
	/// @sa SDL_SetWindowMouseGrab
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowMouseRect")]
	public static partial SDLBool SDL_SetWindowMouseRect(SDL_Window window, Rectangle* rect);

	/// <summary>
	/// Get the mouse confinement rectangle of a window.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns a pointer to the mouse confinement rectangle of a window, or NULL<br/>
	/// if there isn't one.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowMouseRect
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowMouseRect")]
	public static partial Rectangle* SDL_GetWindowMouseRect(SDL_Window window);

	/// <summary>
	/// Set the opacity for a window.<br/>
	/// The parameter `opacity` will be clamped internally between 0.0f<br/>
	/// (transparent) and 1.0f (opaque).<br/>
	/// This function also returns false if setting the opacity isn't supported.<br/>
	/// <br/>
	/// @param window the window which will be made transparent or opaque.<br/>
	/// @param opacity the opacity value (0.0f - transparent, 1.0f - opaque).<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetWindowOpacity
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowOpacity")]
	public static partial SDLBool SDL_SetWindowOpacity(SDL_Window window, float opacity);

	/// <summary>
	/// Get the opacity of a window.<br/>
	/// If transparency isn't supported on this platform, opacity will be returned<br/>
	/// as 1.0f without error.<br/>
	/// <br/>
	/// @param window the window to get the current opacity value from.<br/>
	/// @returns the opacity, (0.0f - transparent, 1.0f - opaque), or -1.0f on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowOpacity
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetWindowOpacity")]
	public static partial float SDL_GetWindowOpacity(SDL_Window window);

	/// <summary>
	/// Set the window as a child of a parent window.<br/>
	/// If the window is already the child of an existing window, it will be<br/>
	/// reparented to the new owner. Setting the parent window to NULL unparents<br/>
	/// the window and removes child window status.<br/>
	/// Attempting to set the parent of a window that is currently in the modal<br/>
	/// state will fail. Use SDL_SetWindowModalFor() to cancel the modal status<br/>
	/// before attempting to change the parent.<br/>
	/// Setting a parent window that is currently the sibling or descendent of the<br/>
	/// child window results in undefined behavior.<br/>
	/// <br/>
	/// @param window the window that should become the child of a parent.<br/>
	/// @param parent the new parent window for the child window.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowModal
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowParent")]
	public static partial SDLBool SDL_SetWindowParent(SDL_Window window, SDL_Window parent);

	/// <summary>
	/// Toggle the state of the window as modal.<br/>
	/// To enable modal status on a window, the window must currently be the child<br/>
	/// window of a parent, or toggling modal status on will fail.<br/>
	/// <br/>
	/// @param window the window on which to set the modal state.<br/>
	/// @param modal true to toggle modal status on, false to toggle it off.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetWindowParent
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowModal")]
	public static partial SDLBool SDL_SetWindowModal(SDL_Window window, SDLBool modal);

	/// <summary>
	/// Set whether the window may have input focus.<br/>
	/// <br/>
	/// @param window the window to set focusable state.<br/>
	/// @param focusable true to allow input focus, false to not allow input focus.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowFocusable")]
	public static partial SDLBool SDL_SetWindowFocusable(SDL_Window window, SDLBool focusable);

	/// <summary>
	/// Display the system-level window menu.<br/>
	/// This default window menu is provided by the system and on some platforms<br/>
	/// provides functionality for setting or changing privileged state on the<br/>
	/// window, such as moving it between workspaces or displays, or toggling the<br/>
	/// always-on-top property.<br/>
	/// On platforms or desktops where this is unsupported, this function does<br/>
	/// nothing.<br/>
	/// <br/>
	/// @param window the window for which the menu will be displayed.<br/>
	/// @param x the x coordinate of the menu, relative to the origin (top-left) of<br/>
	/// the client area.<br/>
	/// @param y the y coordinate of the menu, relative to the origin (top-left) of<br/>
	/// the client area.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShowWindowSystemMenu")]
	public static partial SDLBool SDL_ShowWindowSystemMenu(SDL_Window window, int x, int y);

	/// <summary>
	/// Provide a callback that decides if a window region has special properties.<br/>
	/// Normally windows are dragged and resized by decorations provided by the<br/>
	/// system window manager (a title bar, borders, etc), but for some apps, it<br/>
	/// makes sense to drag them from somewhere else inside the window itself; for<br/>
	/// example, one might have a borderless window that wants to be draggable from<br/>
	/// any part, or simulate its own title bar, etc.<br/>
	/// This function lets the app provide a callback that designates pieces of a<br/>
	/// given window as special. This callback is run during event processing if we<br/>
	/// need to tell the OS to treat a region of the window specially; the use of<br/>
	/// this callback is known as "hit testing."<br/>
	/// Mouse input may not be delivered to your application if it is within a<br/>
	/// special area; the OS will often apply that input to moving the window or<br/>
	/// resizing the window and not deliver it to the application.<br/>
	/// Specifying NULL for a callback disables hit-testing. Hit-testing is<br/>
	/// disabled by default.<br/>
	/// Platforms that don't support this functionality will return false<br/>
	/// unconditionally, even if you're attempting to disable hit-testing.<br/>
	/// Your callback may fire at any time, and its firing does not indicate any<br/>
	/// specific behavior (for example, on Windows, this certainly might fire when<br/>
	/// the OS is deciding whether to drag your window, but it fires for lots of<br/>
	/// other reasons, too, some unrelated to anything you probably care about _and<br/>
	/// when the mouse isn't actually at the location it is testing_). Since this<br/>
	/// can fire at any time, you should try to keep your callback efficient,<br/>
	/// devoid of allocations, etc.<br/>
	/// <br/>
	/// @param window the window to set hit-testing on.<br/>
	/// @param callback the function to call when doing a hit-test.<br/>
	/// @param callback_data an app-defined void pointer passed to **callback**.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowHitTest")]
	public static partial SDLBool SDL_SetWindowHitTest(SDL_Window window, delegate* unmanaged[Cdecl]<SDL_Window, Point*, nint, SDL_HitTestResult> callback, nint callback_data);

	/// <summary>
	/// Set the shape of a transparent window.<br/>
	/// This sets the alpha channel of a transparent window and any fully<br/>
	/// transparent areas are also transparent to mouse clicks. If you are using<br/>
	/// something besides the SDL render API, then you are responsible for setting<br/>
	/// the alpha channel of the window yourself.<br/>
	/// The shape is copied inside this function, so you can free it afterwards. If<br/>
	/// your shape surface changes, you should call SDL_SetWindowShape() again to<br/>
	/// update the window.<br/>
	/// The window must have been created with the SDL_WINDOW_TRANSPARENT flag.<br/>
	/// <br/>
	/// @param window the window.<br/>
	/// @param shape the surface representing the shape of the window, or NULL to<br/>
	/// remove any current shape.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowShape")]
	public static partial SDLBool SDL_SetWindowShape(SDL_Window window, SDL_Surface* shape);

	/// <summary>
	/// Request a window to demand attention from the user.<br/>
	/// <br/>
	/// @param window the window to be flashed.<br/>
	/// @param operation the operation to perform.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_FlashWindow")]
	public static partial SDLBool SDL_FlashWindow(SDL_Window window, SDL_FlashOperation operation);

	/// <summary>
	/// Destroy a window.<br/>
	/// Any popups or modal windows owned by the window will be recursively<br/>
	/// destroyed as well.<br/>
	/// <br/>
	/// @param window the window to destroy.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreatePopupWindow<br/>
	/// @sa SDL_CreateWindow<br/>
	/// @sa SDL_CreateWindowWithProperties
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyWindow")]
	public static partial void SDL_DestroyWindow(SDL_Window window);

	/// <summary>
	/// Check whether the screensaver is currently enabled.<br/>
	/// The screensaver is disabled by default.<br/>
	/// The default can also be changed using `SDL_HINT_VIDEO_ALLOW_SCREENSAVER`.<br/>
	/// <br/>
	/// @returns true if the screensaver is enabled, false if it is disabled.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DisableScreenSaver<br/>
	/// @sa SDL_EnableScreenSaver
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ScreenSaverEnabled")]
	public static partial SDLBool SDL_ScreenSaverEnabled();

	/// <summary>
	/// Allow the screen to be blanked by a screen saver.<br/>
	/// <br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_DisableScreenSaver<br/>
	/// @sa SDL_ScreenSaverEnabled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EnableScreenSaver")]
	public static partial SDLBool SDL_EnableScreenSaver();

	/// <summary>
	/// Prevent the screen from being blanked by a screen saver.<br/>
	/// If you disable the screensaver, it is automatically re-enabled when SDL<br/>
	/// quits.<br/>
	/// The screensaver is disabled by default, but this may by changed by<br/>
	/// SDL_HINT_VIDEO_ALLOW_SCREENSAVER.<br/>
	/// <br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_EnableScreenSaver<br/>
	/// @sa SDL_ScreenSaverEnabled
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DisableScreenSaver")]
	public static partial SDLBool SDL_DisableScreenSaver();

	/// <summary>
	/// Dynamically load an OpenGL library.<br/>
	/// This should be done after initializing the video driver, but before<br/>
	/// creating any OpenGL windows. If no OpenGL library is loaded, the default<br/>
	/// library will be loaded upon creation of the first OpenGL window.<br/>
	/// If you do this, you need to retrieve all of the GL functions used in your<br/>
	/// program from the dynamic library using SDL_GL_GetProcAddress().<br/>
	/// <br/>
	/// @param path the platform dependent OpenGL library name, or NULL to open the<br/>
	/// default OpenGL library.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_GetProcAddress<br/>
	/// @sa SDL_GL_UnloadLibrary
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_LoadLibrary")]
	public static partial SDLBool SDL_GL_LoadLibrary(byte* path);

	[LibraryImport(LibName, EntryPoint = "SDL_GL_LoadLibrary")]
	public static partial SDLBool SDL_GL_LoadLibrary(ReadOnlySpan<byte> path);

	[LibraryImport(LibName, EntryPoint = "SDL_GL_LoadLibrary")]
	public static partial SDLBool SDL_GL_LoadLibrary([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);

	/// <summary>
	/// Get an OpenGL function by name.<br/>
	/// If the GL library is loaded at runtime with SDL_GL_LoadLibrary(), then all<br/>
	/// GL functions must be retrieved this way. Usually this is used to retrieve<br/>
	/// function pointers to OpenGL extensions.<br/>
	/// There are some quirks to looking up OpenGL functions that require some<br/>
	/// extra care from the application. If you code carefully, you can handle<br/>
	/// these quirks without any platform-specific code, though:<br/>
	/// - On Windows, function pointers are specific to the current GL context;<br/>
	/// this means you need to have created a GL context and made it current<br/>
	/// before calling SDL_GL_GetProcAddress(). If you recreate your context or<br/>
	/// create a second context, you should assume that any existing function<br/>
	/// pointers aren't valid to use with it. This is (currently) a<br/>
	/// Windows-specific limitation, and in practice lots of drivers don't suffer<br/>
	/// this limitation, but it is still the way the wgl API is documented to<br/>
	/// work and you should expect crashes if you don't respect it. Store a copy<br/>
	/// of the function pointers that comes and goes with context lifespan.<br/>
	/// - On X11, function pointers returned by this function are valid for any<br/>
	/// context, and can even be looked up before a context is created at all.<br/>
	/// This means that, for at least some common OpenGL implementations, if you<br/>
	/// look up a function that doesn't exist, you'll get a non-NULL result that<br/>
	/// is _NOT_ safe to call. You must always make sure the function is actually<br/>
	/// available for a given GL context before calling it, by checking for the<br/>
	/// existence of the appropriate extension with SDL_GL_ExtensionSupported(),<br/>
	/// or verifying that the version of OpenGL you're using offers the function<br/>
	/// as core functionality.<br/>
	/// - Some OpenGL drivers, on all platforms, *will* return NULL if a function<br/>
	/// isn't supported, but you can't count on this behavior. Check for<br/>
	/// extensions you use, and if you get a NULL anyway, act as if that<br/>
	/// extension wasn't available. This is probably a bug in the driver, but you<br/>
	/// can code defensively for this scenario anyhow.<br/>
	/// - Just because you're on Linux/Unix, don't assume you'll be using X11.<br/>
	/// Next-gen display servers are waiting to replace it, and may or may not<br/>
	/// make the same promises about function pointers.<br/>
	/// - OpenGL function pointers must be declared `APIENTRY` as in the example<br/>
	/// code. This will ensure the proper calling convention is followed on<br/>
	/// platforms where this matters (Win32) thereby avoiding stack corruption.<br/>
	/// <br/>
	/// @param proc the name of an OpenGL function.<br/>
	/// @returns a pointer to the named OpenGL function. The returned pointer<br/>
	/// should be cast to the appropriate function signature.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_ExtensionSupported<br/>
	/// @sa SDL_GL_LoadLibrary<br/>
	/// @sa SDL_GL_UnloadLibrary
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_GetProcAddress")]
	public static partial delegate* unmanaged[Cdecl]<void>* SDL_GL_GetProcAddress(byte* proc);

	[LibraryImport(LibName, EntryPoint = "SDL_GL_GetProcAddress")]
	public static partial delegate* unmanaged[Cdecl]<void>* SDL_GL_GetProcAddress(ReadOnlySpan<byte> proc);

	[LibraryImport(LibName, EntryPoint = "SDL_GL_GetProcAddress")]
	public static partial delegate* unmanaged[Cdecl]<void>* SDL_GL_GetProcAddress([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> proc);

	/// <summary>
	/// Get an EGL library function by name.<br/>
	/// If an EGL library is loaded, this function allows applications to get entry<br/>
	/// points for EGL functions. This is useful to provide to an EGL API and<br/>
	/// extension loader.<br/>
	/// <br/>
	/// @param proc the name of an EGL function.<br/>
	/// @returns a pointer to the named EGL function. The returned pointer should<br/>
	/// be cast to the appropriate function signature.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_EGL_GetCurrentDisplay
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EGL_GetProcAddress")]
	public static partial delegate* unmanaged[Cdecl]<void>* SDL_EGL_GetProcAddress(byte* proc);

	[LibraryImport(LibName, EntryPoint = "SDL_EGL_GetProcAddress")]
	public static partial delegate* unmanaged[Cdecl]<void>* SDL_EGL_GetProcAddress(ReadOnlySpan<byte> proc);

	[LibraryImport(LibName, EntryPoint = "SDL_EGL_GetProcAddress")]
	public static partial delegate* unmanaged[Cdecl]<void>* SDL_EGL_GetProcAddress([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> proc);

	/// <summary>
	/// Unload the OpenGL library previously loaded by SDL_GL_LoadLibrary().<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_LoadLibrary
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_UnloadLibrary")]
	public static partial void SDL_GL_UnloadLibrary();

	/// <summary>
	/// Check if an OpenGL extension is supported for the current context.<br/>
	/// This function operates on the current GL context; you must have created a<br/>
	/// context and it must be current before calling this function. Do not assume<br/>
	/// that all contexts you create will have the same set of extensions<br/>
	/// available, or that recreating an existing context will offer the same<br/>
	/// extensions again.<br/>
	/// While it's probably not a massive overhead, this function is not an O(1)<br/>
	/// operation. Check the extensions you care about after creating the GL<br/>
	/// context and save that information somewhere instead of calling the function<br/>
	/// every time you need to know.<br/>
	/// <br/>
	/// @param extension the name of the extension to check.<br/>
	/// @returns true if the extension is supported, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_ExtensionSupported")]
	public static partial SDLBool SDL_GL_ExtensionSupported(byte* extension);

	[LibraryImport(LibName, EntryPoint = "SDL_GL_ExtensionSupported")]
	public static partial SDLBool SDL_GL_ExtensionSupported(ReadOnlySpan<byte> extension);

	[LibraryImport(LibName, EntryPoint = "SDL_GL_ExtensionSupported")]
	public static partial SDLBool SDL_GL_ExtensionSupported([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> extension);

	/// <summary>
	/// Reset all previously set OpenGL context attributes to their default values.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_GetAttribute<br/>
	/// @sa SDL_GL_SetAttribute
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_ResetAttributes")]
	public static partial void SDL_GL_ResetAttributes();

	/// <summary>
	/// Set an OpenGL window attribute before window creation.<br/>
	/// This function sets the OpenGL attribute `attr` to `value`. The requested<br/>
	/// attributes should be set before creating an OpenGL window. You should use<br/>
	/// SDL_GL_GetAttribute() to check the values after creating the OpenGL<br/>
	/// context, since the values obtained can differ from the requested ones.<br/>
	/// <br/>
	/// @param attr an SDL_GLattr enum value specifying the OpenGL attribute to<br/>
	/// set.<br/>
	/// @param value the desired value for the attribute.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_GetAttribute<br/>
	/// @sa SDL_GL_ResetAttributes
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_SetAttribute")]
	public static partial SDLBool SDL_GL_SetAttribute(SDL_GLattr attr, int value);

	/// <summary>
	/// Get the actual value for an attribute from the current context.<br/>
	/// <br/>
	/// @param attr an SDL_GLattr enum value specifying the OpenGL attribute to<br/>
	/// get.<br/>
	/// @param value a pointer filled in with the current value of `attr`.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_ResetAttributes<br/>
	/// @sa SDL_GL_SetAttribute
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_GetAttribute")]
	public static partial SDLBool SDL_GL_GetAttribute(SDL_GLattr attr, int* value);

	/// <summary>
	/// Create an OpenGL context for an OpenGL window, and make it current.<br/>
	/// Windows users new to OpenGL should note that, for historical reasons, GL<br/>
	/// functions added after OpenGL version 1.1 are not available by default.<br/>
	/// Those functions must be loaded at run-time, either with an OpenGL<br/>
	/// extension-handling library or with SDL_GL_GetProcAddress() and its related<br/>
	/// functions.<br/>
	/// SDL_GLContext is opaque to the application.<br/>
	/// <br/>
	/// @param window the window to associate with the context.<br/>
	/// @returns the OpenGL context associated with `window` or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_DestroyContext<br/>
	/// @sa SDL_GL_MakeCurrent
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_CreateContext")]
	public static partial SDL_GLContext SDL_GL_CreateContext(SDL_Window window);

	/// <summary>
	/// Set up an OpenGL context for rendering into an OpenGL window.<br/>
	/// The context must have been created with a compatible window.<br/>
	/// <br/>
	/// @param window the window to associate with the context.<br/>
	/// @param context the OpenGL context to associate with the window.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_CreateContext
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_MakeCurrent")]
	public static partial SDLBool SDL_GL_MakeCurrent(SDL_Window window, SDL_GLContext context);

	/// <summary>
	/// Get the currently active OpenGL window.<br/>
	/// <br/>
	/// @returns the currently active OpenGL window on success or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_GetCurrentWindow")]
	public static partial SDL_Window SDL_GL_GetCurrentWindow();

	/// <summary>
	/// Get the currently active OpenGL context.<br/>
	/// <br/>
	/// @returns the currently active OpenGL context or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_MakeCurrent
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_GetCurrentContext")]
	public static partial SDL_GLContext SDL_GL_GetCurrentContext();

	/// <summary>
	/// Get the currently active EGL display.<br/>
	/// <br/>
	/// @returns the currently active EGL display or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EGL_GetCurrentDisplay")]
	public static partial nint SDL_EGL_GetCurrentDisplay();

	/// <summary>
	/// Get the currently active EGL config.<br/>
	/// <br/>
	/// @returns the currently active EGL config or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EGL_GetCurrentConfig")]
	public static partial nint SDL_EGL_GetCurrentConfig();

	/// <summary>
	/// Get the EGL surface associated with the window.<br/>
	/// <br/>
	/// @param window the window to query.<br/>
	/// @returns the EGLSurface pointer associated with the window, or NULL on<br/>
	/// failure.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EGL_GetWindowSurface")]
	public static partial nint SDL_EGL_GetWindowSurface(SDL_Window window);

	/// <summary>
	/// Sets the callbacks for defining custom EGLAttrib arrays for EGL<br/>
	/// initialization.<br/>
	/// Callbacks that aren't needed can be set to NULL.<br/>
	/// NOTE: These callback pointers will be reset after SDL_GL_ResetAttributes.<br/>
	/// <br/>
	/// @param platformAttribCallback callback for attributes to pass to<br/>
	/// eglGetPlatformDisplay. May be NULL.<br/>
	/// @param surfaceAttribCallback callback for attributes to pass to<br/>
	/// eglCreateSurface. May be NULL.<br/>
	/// @param contextAttribCallback callback for attributes to pass to<br/>
	/// eglCreateContext. May be NULL.<br/>
	/// @param userdata a pointer that is passed to the callbacks.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EGL_SetAttributeCallbacks")]
	public static partial void SDL_EGL_SetAttributeCallbacks(delegate* unmanaged[Cdecl]<nint, nint> platformAttribCallback, delegate* unmanaged[Cdecl]<nint, nint, nint, int*> surfaceAttribCallback, delegate* unmanaged[Cdecl]<nint, nint, nint, int*> contextAttribCallback, nint userdata);

	/// <summary>
	/// Set the swap interval for the current OpenGL context.<br/>
	/// Some systems allow specifying -1 for the interval, to enable adaptive<br/>
	/// vsync. Adaptive vsync works the same as vsync, but if you've already missed<br/>
	/// the vertical retrace for a given frame, it swaps buffers immediately, which<br/>
	/// might be less jarring for the user during occasional framerate drops. If an<br/>
	/// application requests adaptive vsync and the system does not support it,<br/>
	/// this function will fail and return false. In such a case, you should<br/>
	/// probably retry the call with 1 for the interval.<br/>
	/// Adaptive vsync is implemented for some glX drivers with<br/>
	/// GLX_EXT_swap_control_tear, and for some Windows drivers with<br/>
	/// WGL_EXT_swap_control_tear.<br/>
	/// Read more on the Khronos wiki:<br/>
	/// https://www.khronos.org/opengl/wiki/Swap_Interval#Adaptive_Vsync<br/>
	/// <br/>
	/// @param interval 0 for immediate updates, 1 for updates synchronized with<br/>
	/// the vertical retrace, -1 for adaptive vsync.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_GetSwapInterval
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_SetSwapInterval")]
	public static partial SDLBool SDL_GL_SetSwapInterval(int interval);

	/// <summary>
	/// Get the swap interval for the current OpenGL context.<br/>
	/// If the system can't determine the swap interval, or there isn't a valid<br/>
	/// current context, this function will set *interval to 0 as a safe default.<br/>
	/// <br/>
	/// @param interval output interval value. 0 if there is no vertical retrace<br/>
	/// synchronization, 1 if the buffer swap is synchronized with<br/>
	/// the vertical retrace, and -1 if late swaps happen<br/>
	/// immediately instead of waiting for the next retrace.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_SetSwapInterval
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_GetSwapInterval")]
	public static partial SDLBool SDL_GL_GetSwapInterval(int* interval);

	/// <summary>
	/// Update a window with OpenGL rendering.<br/>
	/// This is used with double-buffered OpenGL contexts, which are the default.<br/>
	/// On macOS, make sure you bind 0 to the draw framebuffer before swapping the<br/>
	/// window, otherwise nothing will happen. If you aren't using<br/>
	/// glBindFramebuffer(), this is the default and you won't have to do anything<br/>
	/// extra.<br/>
	/// <br/>
	/// @param window the window to change.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_SwapWindow")]
	public static partial SDLBool SDL_GL_SwapWindow(SDL_Window window);

	/// <summary>
	/// Delete an OpenGL context.<br/>
	/// <br/>
	/// @param context the OpenGL context to be deleted.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GL_CreateContext
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GL_DestroyContext")]
	public static partial SDLBool SDL_GL_DestroyContext(SDL_GLContext context);

	/// <summary>
	/// Dynamically load the Vulkan loader library.<br/>
	/// This should be called after initializing the video driver, but before<br/>
	/// creating any Vulkan windows. If no Vulkan loader library is loaded, the<br/>
	/// default library will be loaded upon creation of the first Vulkan window.<br/>
	/// It is fairly common for Vulkan applications to link with libvulkan instead<br/>
	/// of explicitly loading it at run time. This will work with SDL provided the<br/>
	/// application links to a dynamic library and both it and SDL use the same<br/>
	/// search path.<br/>
	/// If you specify a non-NULL `path`, an application should retrieve all of the<br/>
	/// Vulkan functions it uses from the dynamic library using<br/>
	/// SDL_Vulkan_GetVkGetInstanceProcAddr unless you can guarantee `path` points<br/>
	/// to the same vulkan loader library the application linked to.<br/>
	/// On Apple devices, if `path` is NULL, SDL will attempt to find the<br/>
	/// `vkGetInstanceProcAddr` address within all the Mach-O images of the current<br/>
	/// process. This is because it is fairly common for Vulkan applications to<br/>
	/// link with libvulkan (and historically MoltenVK was provided as a static<br/>
	/// library). If it is not found, on macOS, SDL will attempt to load<br/>
	/// `vulkan.framework/vulkan`, `libvulkan.1.dylib`,<br/>
	/// `MoltenVK.framework/MoltenVK`, and `libMoltenVK.dylib`, in that order. On<br/>
	/// iOS, SDL will attempt to load `libMoltenVK.dylib`. Applications using a<br/>
	/// dynamic framework or .dylib must ensure it is included in its application<br/>
	/// bundle.<br/>
	/// On non-Apple devices, application linking with a static libvulkan is not<br/>
	/// supported. Either do not link to the Vulkan loader or link to a dynamic<br/>
	/// library version.<br/>
	/// <br/>
	/// @param path the platform dependent Vulkan loader library name or NULL.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Vulkan_GetVkGetInstanceProcAddr<br/>
	/// @sa SDL_Vulkan_UnloadLibrary
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Vulkan_LoadLibrary")]
	public static partial SDLBool SDL_Vulkan_LoadLibrary(byte* path);

	[LibraryImport(LibName, EntryPoint = "SDL_Vulkan_LoadLibrary")]
	public static partial SDLBool SDL_Vulkan_LoadLibrary(ReadOnlySpan<byte> path);

	[LibraryImport(LibName, EntryPoint = "SDL_Vulkan_LoadLibrary")]
	public static partial SDLBool SDL_Vulkan_LoadLibrary([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> path);

	/// <summary>
	/// Get the address of the `vkGetInstanceProcAddr` function.<br/>
	/// This should be called after either calling SDL_Vulkan_LoadLibrary() or<br/>
	/// creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.<br/>
	/// The actual type of the returned function pointer is<br/>
	/// PFN_vkGetInstanceProcAddr, but that isn't available because the Vulkan<br/>
	/// headers are not included here. You should cast the return value of this<br/>
	/// function to that type, e.g.<br/>
	/// `vkGetInstanceProcAddr =<br/>
	/// (PFN_vkGetInstanceProcAddr)SDL_Vulkan_GetVkGetInstanceProcAddr();`<br/>
	/// <br/>
	/// @returns the function pointer for `vkGetInstanceProcAddr` or NULL on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Vulkan_GetVkGetInstanceProcAddr")]
	public static partial delegate* unmanaged[Cdecl]<void>* SDL_Vulkan_GetVkGetInstanceProcAddr();

	/// <summary>
	/// Unload the Vulkan library previously loaded by SDL_Vulkan_LoadLibrary().<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Vulkan_LoadLibrary
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Vulkan_UnloadLibrary")]
	public static partial void SDL_Vulkan_UnloadLibrary();

	/// <summary>
	/// Get the Vulkan instance extensions needed for vkCreateInstance.<br/>
	/// This should be called after either calling SDL_Vulkan_LoadLibrary() or<br/>
	/// creating an SDL_Window with the `SDL_WINDOW_VULKAN` flag.<br/>
	/// On return, the variable pointed to by `count` will be set to the number of<br/>
	/// elements returned, suitable for using with<br/>
	/// VkInstanceCreateInfo::enabledExtensionCount, and the returned array can be<br/>
	/// used with VkInstanceCreateInfo::ppEnabledExtensionNames, for calling<br/>
	/// Vulkan's vkCreateInstance API.<br/>
	/// You should not free the returned array; it is owned by SDL.<br/>
	/// <br/>
	/// @param count a pointer filled in with the number of extensions returned.<br/>
	/// @returns an array of extension name strings on success, NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Vulkan_CreateSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Vulkan_GetInstanceExtensions")]
	public static partial byte** SDL_Vulkan_GetInstanceExtensions(out uint count);

	/// <summary>
	/// Create a Vulkan rendering surface for a window.<br/>
	/// The `window` must have been created with the `SDL_WINDOW_VULKAN` flag and<br/>
	/// `instance` must have been created with extensions returned by<br/>
	/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
	/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
	/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
	/// <br/>
	/// @param window the window to which to attach the Vulkan surface.<br/>
	/// @param instance the Vulkan instance handle.<br/>
	/// @param allocator a VkAllocationCallbacks struct, which lets the app set the<br/>
	/// allocator that creates the surface. Can be NULL.<br/>
	/// @param surface a pointer to a VkSurfaceKHR handle to output the newly<br/>
	/// created surface.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Vulkan_GetInstanceExtensions<br/>
	/// @sa SDL_Vulkan_DestroySurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Vulkan_CreateSurface")]
	public static partial SDLBool SDL_Vulkan_CreateSurface(SDL_Window window, nint instance, nint allocator, ulong** surface);

	/// <summary>
	/// Destroy the Vulkan rendering surface of a window.<br/>
	/// This should be called before SDL_DestroyWindow, if SDL_Vulkan_CreateSurface<br/>
	/// was called after SDL_CreateWindow.<br/>
	/// The `instance` must have been created with extensions returned by<br/>
	/// SDL_Vulkan_GetInstanceExtensions() enabled and `surface` must have been<br/>
	/// created successfully by an SDL_Vulkan_CreateSurface() call.<br/>
	/// If `allocator` is NULL, Vulkan will use the system default allocator. This<br/>
	/// argument is passed directly to Vulkan and isn't used by SDL itself.<br/>
	/// <br/>
	/// @param instance the Vulkan instance handle.<br/>
	/// @param surface vkSurfaceKHR handle to destroy.<br/>
	/// @param allocator a VkAllocationCallbacks struct, which lets the app set the<br/>
	/// allocator that destroys the surface. Can be NULL.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Vulkan_GetInstanceExtensions<br/>
	/// @sa SDL_Vulkan_CreateSurface
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Vulkan_DestroySurface")]
	public static partial void SDL_Vulkan_DestroySurface(nint instance, ulong* surface, nint allocator);

	/// <summary>
	/// Query support for presentation via a given physical device and queue<br/>
	/// family.<br/>
	/// The `instance` must have been created with extensions returned by<br/>
	/// SDL_Vulkan_GetInstanceExtensions() enabled.<br/>
	/// <br/>
	/// @param instance the Vulkan instance handle.<br/>
	/// @param physicalDevice a valid Vulkan physical device handle.<br/>
	/// @param queueFamilyIndex a valid queue family index for the given physical<br/>
	/// device.<br/>
	/// @returns true if supported, false if unsupported or an error occurred.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Vulkan_GetInstanceExtensions
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_Vulkan_GetPresentationSupport")]
	public static partial SDLBool SDL_Vulkan_GetPresentationSupport(nint instance, nint physicalDevice, uint queueFamilyIndex);

	/// <summary>
	/// Set a callback for every Windows message, run before TranslateMessage().<br/>
	/// The callback may modify the message, and should return true if the message<br/>
	/// should continue to be processed, or false to prevent further processing.<br/>
	/// <br/>
	/// @param callback the SDL_WindowsMessageHook function to call.<br/>
	/// @param userdata a pointer to pass to every iteration of `callback`.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_WindowsMessageHook<br/>
	/// @sa SDL_HINT_WINDOWS_ENABLE_MESSAGELOOP
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetWindowsMessageHook")]
	public static partial void SDL_SetWindowsMessageHook(delegate* unmanaged[Cdecl]<nint, tagMSG, SDLBool> callback, nint userdata);

	/// <summary>
	/// Get the D3D9 adapter index that matches the specified display.<br/>
	/// The returned adapter index can be passed to `IDirect3D9::CreateDevice` and<br/>
	/// controls on which monitor a full screen application will appear.<br/>
	/// <br/>
	/// @param displayID the instance of the display to query.<br/>
	/// @returns the D3D9 adapter index on success or -1 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDirect3D9AdapterIndex")]
	public static partial int SDL_GetDirect3D9AdapterIndex(SDL_DisplayID displayID);

	/// <summary>
	/// Get the DXGI Adapter and Output indices for the specified display.<br/>
	/// The DXGI Adapter and Output indices can be passed to `EnumAdapters` and<br/>
	/// `EnumOutputs` respectively to get the objects required to create a DX10 or<br/>
	/// DX11 device and swap chain.<br/>
	/// <br/>
	/// @param displayID the instance of the display to query.<br/>
	/// @param adapterIndex a pointer to be filled in with the adapter index.<br/>
	/// @param outputIndex a pointer to be filled in with the output index.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetDXGIOutputInfo")]
	public static partial SDLBool SDL_GetDXGIOutputInfo(SDL_DisplayID displayID, int* adapterIndex, int* outputIndex);

	/// <summary>
	/// Set a callback for every X11 event.<br/>
	/// The callback may modify the event, and should return true if the event<br/>
	/// should continue to be processed, or false to prevent further processing.<br/>
	/// <br/>
	/// @param callback the SDL_X11EventHook function to call.<br/>
	/// @param userdata a pointer to pass to every iteration of `callback`.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetX11EventHook")]
	public static partial void SDL_SetX11EventHook(delegate* unmanaged[Cdecl]<nint, _XEvent, SDLBool> callback, nint userdata);

	/// <summary>
	/// Use this function to set the animation callback on Apple iOS.<br/>
	/// The function prototype for `callback` is:<br/>
	/// ```c<br/>
	/// void callback(void *callbackParam);<br/>
	/// ```<br/>
	/// Where its parameter, `callbackParam`, is what was passed as `callbackParam`<br/>
	/// to SDL_SetiOSAnimationCallback().<br/>
	/// This function is only available on Apple iOS.<br/>
	/// For more information see:<br/>
	/// https://wiki.libsdl.org/SDL3/README/ios<br/>
	/// Note that if you use the "main callbacks" instead of a standard C `main`<br/>
	/// function, you don't have to use this API, as SDL will manage this for you.<br/>
	/// Details on main callbacks are here:<br/>
	/// https://wiki.libsdl.org/SDL3/README/main-functions<br/>
	/// <br/>
	/// @param window the window for which the animation callback should be set.<br/>
	/// @param interval the number of frames after which **callback** will be<br/>
	/// called.<br/>
	/// @param callback the function to call for every frame.<br/>
	/// @param callbackParam a pointer that is passed to `callback`.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetiOSEventPump
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetiOSAnimationCallback")]
	public static partial SDLBool SDL_SetiOSAnimationCallback(SDL_Window window, int interval, delegate* unmanaged[Cdecl]<nint, void> callback, nint callbackParam);

	/// <summary>
	/// Use this function to enable or disable the SDL event pump on Apple iOS.<br/>
	/// This function is only available on Apple iOS.<br/>
	/// <br/>
	/// @param enabled true to enable the event pump, false to disable it.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetiOSAnimationCallback
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetiOSEventPump")]
	public static partial void SDL_SetiOSEventPump(SDLBool enabled);

	/// <summary>
	/// Get the Android Java Native Interface Environment of the current thread.<br/>
	/// This is the JNIEnv one needs to access the Java virtual machine from native<br/>
	/// code, and is needed for many Android APIs to be usable from C.<br/>
	/// The prototype of the function in SDL's code actually declare a void* return<br/>
	/// type, even if the implementation returns a pointer to a JNIEnv. The<br/>
	/// rationale being that the SDL headers can avoid including jni.h.<br/>
	/// <br/>
	/// @returns a pointer to Java native interface object (JNIEnv) to which the<br/>
	/// current thread is attached, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAndroidActivity
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAndroidJNIEnv")]
	public static partial nint SDL_GetAndroidJNIEnv();

	/// <summary>
	/// Retrieve the Java instance of the Android activity class.<br/>
	/// The prototype of the function in SDL's code actually declares a void*<br/>
	/// return type, even if the implementation returns a jobject. The rationale<br/>
	/// being that the SDL headers can avoid including jni.h.<br/>
	/// The jobject returned by the function is a local reference and must be<br/>
	/// released by the caller. See the PushLocalFrame() and PopLocalFrame() or<br/>
	/// DeleteLocalRef() functions of the Java native interface:<br/>
	/// https://docs.oracle.com/javase/1.5.0/docs/guide/jni/spec/functions.html<br/>
	/// <br/>
	/// @returns the jobject representing the instance of the Activity class of the<br/>
	/// Android application, or NULL on failure; call SDL_GetError() for<br/>
	/// more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAndroidJNIEnv
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAndroidActivity")]
	public static partial nint SDL_GetAndroidActivity();

	/// <summary>
	/// Query Android API level of the current device.<br/>
	/// - API level 35: Android 15 (VANILLA_ICE_CREAM)<br/>
	/// - API level 34: Android 14 (UPSIDE_DOWN_CAKE)<br/>
	/// - API level 33: Android 13 (TIRAMISU)<br/>
	/// - API level 32: Android 12L (S_V2)<br/>
	/// - API level 31: Android 12 (S)<br/>
	/// - API level 30: Android 11 (R)<br/>
	/// - API level 29: Android 10 (Q)<br/>
	/// - API level 28: Android 9 (P)<br/>
	/// - API level 27: Android 8.1 (O_MR1)<br/>
	/// - API level 26: Android 8.0 (O)<br/>
	/// - API level 25: Android 7.1 (N_MR1)<br/>
	/// - API level 24: Android 7.0 (N)<br/>
	/// - API level 23: Android 6.0 (M)<br/>
	/// - API level 22: Android 5.1 (LOLLIPOP_MR1)<br/>
	/// - API level 21: Android 5.0 (LOLLIPOP, L)<br/>
	/// - API level 20: Android 4.4W (KITKAT_WATCH)<br/>
	/// - API level 19: Android 4.4 (KITKAT)<br/>
	/// - API level 18: Android 4.3 (JELLY_BEAN_MR2)<br/>
	/// - API level 17: Android 4.2 (JELLY_BEAN_MR1)<br/>
	/// - API level 16: Android 4.1 (JELLY_BEAN)<br/>
	/// - API level 15: Android 4.0.3 (ICE_CREAM_SANDWICH_MR1)<br/>
	/// - API level 14: Android 4.0 (ICE_CREAM_SANDWICH)<br/>
	/// - API level 13: Android 3.2 (HONEYCOMB_MR2)<br/>
	/// - API level 12: Android 3.1 (HONEYCOMB_MR1)<br/>
	/// - API level 11: Android 3.0 (HONEYCOMB)<br/>
	/// - API level 10: Android 2.3.3 (GINGERBREAD_MR1)<br/>
	/// <br/>
	/// @returns the Android API level.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAndroidSDKVersion")]
	public static partial int SDL_GetAndroidSDKVersion();

	/// <summary>
	/// Query if the application is running on a Chromebook.<br/>
	/// <br/>
	/// @returns true if this is a Chromebook, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IsChromebook")]
	public static partial SDLBool SDL_IsChromebook();

	/// <summary>
	/// Query if the application is running on a Samsung DeX docking station.<br/>
	/// <br/>
	/// @returns true if this is a DeX docking station, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IsDeXMode")]
	public static partial SDLBool SDL_IsDeXMode();

	/// <summary>
	/// Trigger the Android system back button behavior.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SendAndroidBackButton")]
	public static partial void SDL_SendAndroidBackButton();

	/// <summary>
	/// Get the path used for internal storage for this Android application.<br/>
	/// This path is unique to your application and cannot be written to by other<br/>
	/// applications.<br/>
	/// Your internal storage path is typically:<br/>
	/// `/data/data/your.app.package/files`.<br/>
	/// This is a C wrapper over `android.content.Context.getFilesDir()`:<br/>
	/// https://developer.android.com/reference/android/content/Context#getFilesDir()<br/>
	/// <br/>
	/// @returns the path used for internal storage or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAndroidExternalStorageState
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAndroidInternalStoragePath")]
	public static partial byte* SDL_GetAndroidInternalStoragePathPtr();

	public static string? SDL_GetAndroidInternalStoragePath()
	{
		return ConvertToManaged(SDL_GetAndroidInternalStoragePathPtr());
	}

	/// <summary>
	/// Get the current state of external storage for this Android application.<br/>
	/// The current state of external storage, a bitmask of these values:<br/>
	/// `SDL_ANDROID_EXTERNAL_STORAGE_READ`, `SDL_ANDROID_EXTERNAL_STORAGE_WRITE`.<br/>
	/// If external storage is currently unavailable, this will return 0.<br/>
	/// <br/>
	/// @returns the current state of external storage, or 0 if external storage is<br/>
	/// currently unavailable.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAndroidExternalStoragePath
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAndroidExternalStorageState")]
	public static partial uint SDL_GetAndroidExternalStorageState();

	/// <summary>
	/// Get the path used for external storage for this Android application.<br/>
	/// This path is unique to your application, but is public and can be written<br/>
	/// to by other applications.<br/>
	/// Your external storage path is typically:<br/>
	/// `/storage/sdcard0/Android/data/your.app.package/files`.<br/>
	/// This is a C wrapper over `android.content.Context.getExternalFilesDir()`:<br/>
	/// https://developer.android.com/reference/android/content/Context#getExternalFilesDir()<br/>
	/// <br/>
	/// @returns the path used for external storage for this application on success<br/>
	/// or NULL on failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetAndroidExternalStorageState
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAndroidExternalStoragePath")]
	public static partial byte* SDL_GetAndroidExternalStoragePathPtr();

	public static string? SDL_GetAndroidExternalStoragePath()
	{
		return ConvertToManaged(SDL_GetAndroidExternalStoragePathPtr());
	}

	/// <summary>
	/// Get the path used for caching data for this Android application.<br/>
	/// This path is unique to your application, but is public and can be written<br/>
	/// to by other applications.<br/>
	/// Your cache path is typically: `/data/data/your.app.package/cache/`.<br/>
	/// This is a C wrapper over `android.content.Context.getCacheDir()`:<br/>
	/// https://developer.android.com/reference/android/content/Context#getCacheDir()<br/>
	/// <br/>
	/// @returns the path used for caches for this application on success or NULL<br/>
	/// on failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetAndroidCachePath")]
	public static partial byte* SDL_GetAndroidCachePathPtr();

	public static string? SDL_GetAndroidCachePath()
	{
		return ConvertToManaged(SDL_GetAndroidCachePathPtr());
	}

	/// <summary>
	/// Request permissions at runtime, asynchronously.<br/>
	/// You do not need to call this for built-in functionality of SDL; recording<br/>
	/// from a microphone or reading images from a camera, using standard SDL APIs,<br/>
	/// will manage permission requests for you.<br/>
	/// This function never blocks. Instead, the app-supplied callback will be<br/>
	/// called when a decision has been made. This callback may happen on a<br/>
	/// different thread, and possibly much later, as it might wait on a user to<br/>
	/// respond to a system dialog. If permission has already been granted for a<br/>
	/// specific entitlement, the callback will still fire, probably on the current<br/>
	/// thread and before this function returns.<br/>
	/// If the request submission fails, this function returns -1 and the callback<br/>
	/// will NOT be called, but this should only happen in catastrophic conditions,<br/>
	/// like memory running out. Normally there will be a yes or no to the request<br/>
	/// through the callback.<br/>
	/// <br/>
	/// @param permission the permission to request.<br/>
	/// @param cb the callback to trigger when the request has a response.<br/>
	/// @param userdata an app-controlled pointer that is passed to the callback.<br/>
	/// @returns true if the request was submitted, false if there was an error<br/>
	/// submitting. The result of the request is only ever reported<br/>
	/// through the callback, not this return value.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RequestAndroidPermission")]
	public static partial SDLBool SDL_RequestAndroidPermission(byte* permission, delegate* unmanaged[Cdecl]<nint, byte*, SDLBool, void> cb, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_RequestAndroidPermission")]
	public static partial SDLBool SDL_RequestAndroidPermission(ReadOnlySpan<byte> permission, delegate* unmanaged[Cdecl]<nint, byte*, SDLBool, void> cb, nint userdata);

	[LibraryImport(LibName, EntryPoint = "SDL_RequestAndroidPermission")]
	public static partial SDLBool SDL_RequestAndroidPermission([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> permission, delegate* unmanaged[Cdecl]<nint, byte*, SDLBool, void> cb, nint userdata);

	/// <summary>
	/// Shows an Android toast notification.<br/>
	/// Toasts are a sort of lightweight notification that are unique to Android.<br/>
	/// https://developer.android.com/guide/topics/ui/notifiers/toasts<br/>
	/// Shows toast in UI thread.<br/>
	/// For the `gravity` parameter, choose a value from here, or -1 if you don't<br/>
	/// have a preference:<br/>
	/// https://developer.android.com/reference/android/view/Gravity<br/>
	/// <br/>
	/// @param message text message to be shown.<br/>
	/// @param duration 0=short, 1=long.<br/>
	/// @param gravity where the notification should appear on the screen.<br/>
	/// @param xoffset set this parameter only when gravity >=0.<br/>
	/// @param yoffset set this parameter only when gravity >=0.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ShowAndroidToast")]
	public static partial SDLBool SDL_ShowAndroidToast(byte* message, int duration, int gravity, int xoffset, int yoffset);

	[LibraryImport(LibName, EntryPoint = "SDL_ShowAndroidToast")]
	public static partial SDLBool SDL_ShowAndroidToast(ReadOnlySpan<byte> message, int duration, int gravity, int xoffset, int yoffset);

	[LibraryImport(LibName, EntryPoint = "SDL_ShowAndroidToast")]
	public static partial SDLBool SDL_ShowAndroidToast([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> message, int duration, int gravity, int xoffset, int yoffset);

	/// <summary>
	/// Send a user command to SDLActivity.<br/>
	/// Override "boolean onUnhandledMessage(Message msg)" to handle the message.<br/>
	/// <br/>
	/// @param command user command that must be greater or equal to 0x8000.<br/>
	/// @param param user parameter.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SendAndroidMessage")]
	public static partial SDLBool SDL_SendAndroidMessage(uint command, int param);

	/// <summary>
	/// Query if the current device is a tablet.<br/>
	/// If SDL can't determine this, it will return false.<br/>
	/// <br/>
	/// @returns true if the device is a tablet, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IsTablet")]
	public static partial SDLBool SDL_IsTablet();

	/// <summary>
	/// Query if the current device is a TV.<br/>
	/// If SDL can't determine this, it will return false.<br/>
	/// <br/>
	/// @returns true if the device is a TV, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_IsTV")]
	public static partial SDLBool SDL_IsTV();

	/// <summary>
	/// Let iOS apps with external event handling report<br/>
	/// onApplicationWillTerminate.<br/>
	/// This functions allows iOS apps that have their own event handling to hook<br/>
	/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
	/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
	/// available on all platforms, in case it might be useful for some specific<br/>
	/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
	/// code will handle all this for windows created by SDL_CreateWindow!<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OnApplicationWillTerminate")]
	public static partial void SDL_OnApplicationWillTerminate();

	/// <summary>
	/// Let iOS apps with external event handling report<br/>
	/// onApplicationDidReceiveMemoryWarning.<br/>
	/// This functions allows iOS apps that have their own event handling to hook<br/>
	/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
	/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
	/// available on all platforms, in case it might be useful for some specific<br/>
	/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
	/// code will handle all this for windows created by SDL_CreateWindow!<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OnApplicationDidReceiveMemoryWarning")]
	public static partial void SDL_OnApplicationDidReceiveMemoryWarning();

	/// <summary>
	/// Let iOS apps with external event handling report<br/>
	/// onApplicationWillResignActive.<br/>
	/// This functions allows iOS apps that have their own event handling to hook<br/>
	/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
	/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
	/// available on all platforms, in case it might be useful for some specific<br/>
	/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
	/// code will handle all this for windows created by SDL_CreateWindow!<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OnApplicationWillEnterBackground")]
	public static partial void SDL_OnApplicationWillEnterBackground();

	/// <summary>
	/// Let iOS apps with external event handling report<br/>
	/// onApplicationDidEnterBackground.<br/>
	/// This functions allows iOS apps that have their own event handling to hook<br/>
	/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
	/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
	/// available on all platforms, in case it might be useful for some specific<br/>
	/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
	/// code will handle all this for windows created by SDL_CreateWindow!<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OnApplicationDidEnterBackground")]
	public static partial void SDL_OnApplicationDidEnterBackground();

	/// <summary>
	/// Let iOS apps with external event handling report<br/>
	/// onApplicationWillEnterForeground.<br/>
	/// This functions allows iOS apps that have their own event handling to hook<br/>
	/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
	/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
	/// available on all platforms, in case it might be useful for some specific<br/>
	/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
	/// code will handle all this for windows created by SDL_CreateWindow!<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OnApplicationWillEnterForeground")]
	public static partial void SDL_OnApplicationWillEnterForeground();

	/// <summary>
	/// Let iOS apps with external event handling report<br/>
	/// onApplicationDidBecomeActive.<br/>
	/// This functions allows iOS apps that have their own event handling to hook<br/>
	/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
	/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
	/// available on all platforms, in case it might be useful for some specific<br/>
	/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
	/// code will handle all this for windows created by SDL_CreateWindow!<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OnApplicationDidEnterForeground")]
	public static partial void SDL_OnApplicationDidEnterForeground();

	/// <summary>
	/// Let iOS apps with external event handling report<br/>
	/// onApplicationDidChangeStatusBarOrientation.<br/>
	/// This functions allows iOS apps that have their own event handling to hook<br/>
	/// into SDL to generate SDL events. This maps directly to an iOS-specific<br/>
	/// event, but since it doesn't do anything iOS-specific internally, it is<br/>
	/// available on all platforms, in case it might be useful for some specific<br/>
	/// paradigm. Most apps do not need to use this directly; SDL's internal event<br/>
	/// code will handle all this for windows created by SDL_CreateWindow!<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_OnApplicationDidChangeStatusBarOrientation")]
	public static partial void SDL_OnApplicationDidChangeStatusBarOrientation();

	/// <summary>
	/// Checks for GPU runtime support.<br/>
	/// <br/>
	/// @param format_flags a bitflag indicating which shader formats the app is<br/>
	/// able to provide.<br/>
	/// @param name the preferred GPU driver, or NULL to let SDL pick the optimal<br/>
	/// driver.<br/>
	/// @returns true if supported, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateGPUDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GPUSupportsShaderFormats")]
	public static partial SDLBool SDL_GPUSupportsShaderFormats(SDL_GPUShaderFormat format_flags, byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_GPUSupportsShaderFormats")]
	public static partial SDLBool SDL_GPUSupportsShaderFormats(SDL_GPUShaderFormat format_flags, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_GPUSupportsShaderFormats")]
	public static partial SDLBool SDL_GPUSupportsShaderFormats(SDL_GPUShaderFormat format_flags, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Checks for GPU runtime support.<br/>
	/// <br/>
	/// @param props the properties to use.<br/>
	/// @returns true if supported, false otherwise.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateGPUDeviceWithProperties
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GPUSupportsProperties")]
	public static partial SDLBool SDL_GPUSupportsProperties(SDL_PropertiesID props);

	/// <summary>
	/// Creates a GPU context.<br/>
	/// <br/>
	/// @param format_flags a bitflag indicating which shader formats the app is<br/>
	/// able to provide.<br/>
	/// @param debug_mode enable debug mode properties and validations.<br/>
	/// @param name the preferred GPU driver, or NULL to let SDL pick the optimal<br/>
	/// driver.<br/>
	/// @returns a GPU context on success or NULL on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGPUShaderFormats<br/>
	/// @sa SDL_GetGPUDeviceDriver<br/>
	/// @sa SDL_DestroyGPUDevice<br/>
	/// @sa SDL_GPUSupportsShaderFormats
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUDevice")]
	public static partial SDL_GPUDevice SDL_CreateGPUDevice(SDL_GPUShaderFormat format_flags, SDLBool debug_mode, byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUDevice")]
	public static partial SDL_GPUDevice SDL_CreateGPUDevice(SDL_GPUShaderFormat format_flags, SDLBool debug_mode, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUDevice")]
	public static partial SDL_GPUDevice SDL_CreateGPUDevice(SDL_GPUShaderFormat format_flags, SDLBool debug_mode, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Creates a GPU context.<br/>
	/// These are the supported properties:<br/>
	/// - `SDL_PROP_GPU_DEVICE_CREATE_DEBUGMODE_BOOL`: enable debug mode properties<br/>
	/// and validations, defaults to true.<br/>
	/// - `SDL_PROP_GPU_DEVICE_CREATE_PREFERLOWPOWER_BOOL`: enable to prefer energy<br/>
	/// efficiency over maximum GPU performance, defaults to false.<br/>
	/// - `SDL_PROP_GPU_DEVICE_CREATE_NAME_STRING`: the name of the GPU driver to<br/>
	/// use, if a specific one is desired.<br/>
	/// These are the current shader format properties:<br/>
	/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_PRIVATE_BOOL`: The app is able to<br/>
	/// provide shaders for an NDA platform.<br/>
	/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_SPIRV_BOOL`: The app is able to<br/>
	/// provide SPIR-V shaders if applicable.<br/>
	/// - SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXBC_BOOL`: The app is able to provide<br/>
	/// DXBC shaders if applicable<br/>
	/// `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_DXIL_BOOL`: The app is able to<br/>
	/// provide DXIL shaders if applicable.<br/>
	/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_MSL_BOOL`: The app is able to provide<br/>
	/// MSL shaders if applicable.<br/>
	/// - `SDL_PROP_GPU_DEVICE_CREATE_SHADERS_METALLIB_BOOL`: The app is able to<br/>
	/// provide Metal shader libraries if applicable.<br/>
	/// With the D3D12 renderer:<br/>
	/// - `SDL_PROP_GPU_DEVICE_CREATE_D3D12_SEMANTIC_NAME_STRING`: the prefix to<br/>
	/// use for all vertex semantics, default is "TEXCOORD".<br/>
	/// <br/>
	/// @param props the properties to use.<br/>
	/// @returns a GPU context on success or NULL on failure; call SDL_GetError()<br/>
	/// for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGPUShaderFormats<br/>
	/// @sa SDL_GetGPUDeviceDriver<br/>
	/// @sa SDL_DestroyGPUDevice<br/>
	/// @sa SDL_GPUSupportsProperties
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUDeviceWithProperties")]
	public static partial SDL_GPUDevice SDL_CreateGPUDeviceWithProperties(SDL_PropertiesID props);

	/// <summary>
	/// Destroys a GPU context previously returned by SDL_CreateGPUDevice.<br/>
	/// <br/>
	/// @param device a GPU Context to destroy.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateGPUDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyGPUDevice")]
	public static partial void SDL_DestroyGPUDevice(SDL_GPUDevice device);

	/// <summary>
	/// Get the number of GPU drivers compiled into SDL.<br/>
	/// <br/>
	/// @returns the number of built in GPU drivers.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetGPUDriver
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetNumGPUDrivers")]
	public static partial int SDL_GetNumGPUDrivers();

	/// <summary>
	/// Get the name of a built in GPU driver.<br/>
	/// The GPU drivers are presented in the order in which they are normally<br/>
	/// checked during initialization.<br/>
	/// The names of drivers are all simple, low-ASCII identifiers, like "vulkan",<br/>
	/// "metal" or "direct3d12". These never have Unicode characters, and are not<br/>
	/// meant to be proper names.<br/>
	/// <br/>
	/// @param index the index of a GPU driver.<br/>
	/// @returns the name of the GPU driver with the given **index**.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GetNumGPUDrivers
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGPUDriver")]
	public static partial byte* SDL_GetGPUDriverPtr(int index);

	public static string? SDL_GetGPUDriver(int index)
	{
		return ConvertToManaged(SDL_GetGPUDriverPtr(index));
	}

	/// <summary>
	/// Returns the name of the backend used to create this GPU context.<br/>
	/// <br/>
	/// @param device a GPU context to query.<br/>
	/// @returns the name of the device's driver, or NULL on error.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGPUDeviceDriver")]
	public static partial byte* SDL_GetGPUDeviceDriverPtr(SDL_GPUDevice device);

	public static string? SDL_GetGPUDeviceDriver(SDL_GPUDevice device)
	{
		return ConvertToManaged(SDL_GetGPUDeviceDriverPtr(device));
	}

	/// <summary>
	/// Returns the supported shader formats for this GPU context.<br/>
	/// <br/>
	/// @param device a GPU context to query.<br/>
	/// @returns a bitflag indicating which shader formats the driver is able to<br/>
	/// consume.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGPUShaderFormats")]
	public static partial SDL_GPUShaderFormat SDL_GetGPUShaderFormats(SDL_GPUDevice device);

	/// <summary>
	/// Creates a pipeline object to be used in a compute workflow.<br/>
	/// Shader resource bindings must be authored to follow a particular order<br/>
	/// depending on the shader format.<br/>
	/// For SPIR-V shaders, use the following resource sets:<br/>
	/// - 0: Sampled textures, followed by read-only storage textures, followed by<br/>
	/// read-only storage buffers<br/>
	/// - 1: Write-only storage textures, followed by write-only storage buffers<br/>
	/// - 2: Uniform buffers<br/>
	/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
	/// - t registers: Sampled textures, followed by read-only storage textures,<br/>
	/// followed by read-only storage buffers<br/>
	/// - u registers: Write-only storage textures, followed by write-only storage<br/>
	/// buffers<br/>
	/// - b registers: Uniform buffers<br/>
	/// For DXIL shaders, use the following register order:<br/>
	/// - (t[n], space0): Sampled textures, followed by read-only storage textures,<br/>
	/// followed by read-only storage buffers<br/>
	/// - (u[n], space1): Write-only storage textures, followed by write-only<br/>
	/// storage buffers<br/>
	/// - (b[n], space2): Uniform buffers<br/>
	/// For MSL/metallib, use the following order:<br/>
	/// - [[buffer]]: Uniform buffers, followed by write-only storage buffers,<br/>
	/// followed by write-only storage buffers<br/>
	/// - [[texture]]: Sampled textures, followed by read-only storage textures,<br/>
	/// followed by write-only storage textures<br/>
	/// <br/>
	/// @param device a GPU Context.<br/>
	/// @param createinfo a struct describing the state of the compute pipeline to<br/>
	/// create.<br/>
	/// @returns a compute pipeline object on success, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BindGPUComputePipeline<br/>
	/// @sa SDL_ReleaseGPUComputePipeline
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUComputePipeline")]
	public static partial SDL_GPUComputePipeline SDL_CreateGPUComputePipeline(SDL_GPUDevice device, SDL_GPUComputePipelineCreateInfo* createinfo);

	/// <summary>
	/// Creates a pipeline object to be used in a graphics workflow.<br/>
	/// <br/>
	/// @param device a GPU Context.<br/>
	/// @param createinfo a struct describing the state of the graphics pipeline to<br/>
	/// create.<br/>
	/// @returns a graphics pipeline object on success, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateGPUShader<br/>
	/// @sa SDL_BindGPUGraphicsPipeline<br/>
	/// @sa SDL_ReleaseGPUGraphicsPipeline
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUGraphicsPipeline")]
	public static partial SDL_GPUGraphicsPipeline SDL_CreateGPUGraphicsPipeline(SDL_GPUDevice device, SDL_GPUGraphicsPipelineCreateInfo* createinfo);

	/// <summary>
	/// Creates a sampler object to be used when binding textures in a graphics<br/>
	/// workflow.<br/>
	/// <br/>
	/// @param device a GPU Context.<br/>
	/// @param createinfo a struct describing the state of the sampler to create.<br/>
	/// @returns a sampler object on success, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_BindGPUVertexSamplers<br/>
	/// @sa SDL_BindGPUFragmentSamplers<br/>
	/// @sa SDL_ReleaseSampler
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUSampler")]
	public static partial SDL_GPUSampler SDL_CreateGPUSampler(SDL_GPUDevice device, SDL_GPUSamplerCreateInfo* createinfo);

	/// <summary>
	/// Creates a shader to be used when creating a graphics pipeline.<br/>
	/// Shader resource bindings must be authored to follow a particular order<br/>
	/// depending on the shader format.<br/>
	/// For SPIR-V shaders, use the following resource sets:<br/>
	/// For vertex shaders:<br/>
	/// - 0: Sampled textures, followed by storage textures, followed by storage<br/>
	/// buffers<br/>
	/// - 1: Uniform buffers<br/>
	/// For fragment shaders:<br/>
	/// - 2: Sampled textures, followed by storage textures, followed by storage<br/>
	/// buffers<br/>
	/// - 3: Uniform buffers<br/>
	/// For DXBC Shader Model 5_0 shaders, use the following register order:<br/>
	/// - t registers: Sampled textures, followed by storage textures, followed by<br/>
	/// storage buffers<br/>
	/// - s registers: Samplers with indices corresponding to the sampled textures<br/>
	/// - b registers: Uniform buffers<br/>
	/// For DXIL shaders, use the following register order:<br/>
	/// For vertex shaders:<br/>
	/// - (t[n], space0): Sampled textures, followed by storage textures, followed<br/>
	/// by storage buffers<br/>
	/// - (s[n], space0): Samplers with indices corresponding to the sampled<br/>
	/// textures<br/>
	/// - (b[n], space1): Uniform buffers<br/>
	/// For pixel shaders:<br/>
	/// - (t[n], space2): Sampled textures, followed by storage textures, followed<br/>
	/// by storage buffers<br/>
	/// - (s[n], space2): Samplers with indices corresponding to the sampled<br/>
	/// textures<br/>
	/// - (b[n], space3): Uniform buffers<br/>
	/// For MSL/metallib, use the following order:<br/>
	/// - [[texture]]: Sampled textures, followed by storage textures<br/>
	/// - [[sampler]]: Samplers with indices corresponding to the sampled textures<br/>
	/// - [[buffer]]: Uniform buffers, followed by storage buffers. Vertex buffer 0<br/>
	/// is bound at [[buffer(14)]], vertex buffer 1 at [[buffer(15)]], and so on.<br/>
	/// Rather than manually authoring vertex buffer indices, use the<br/>
	/// [[stage_in]] attribute which will automatically use the vertex input<br/>
	/// information from the SDL_GPUPipeline.<br/>
	/// <br/>
	/// @param device a GPU Context.<br/>
	/// @param createinfo a struct describing the state of the shader to create.<br/>
	/// @returns a shader object on success, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateGPUGraphicsPipeline<br/>
	/// @sa SDL_ReleaseGPUShader
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUShader")]
	public static partial SDL_GPUShader SDL_CreateGPUShader(SDL_GPUDevice device, SDL_GPUShaderCreateInfo* createinfo);

	/// <summary>
	/// Creates a texture object to be used in graphics or compute workflows.<br/>
	/// The contents of this texture are undefined until data is written to the<br/>
	/// texture.<br/>
	/// Note that certain combinations of usage flags are invalid. For example, a<br/>
	/// texture cannot have both the SAMPLER and GRAPHICS_STORAGE_READ flags.<br/>
	/// If you request a sample count higher than the hardware supports, the<br/>
	/// implementation will automatically fall back to the highest available sample<br/>
	/// count.<br/>
	/// <br/>
	/// @param device a GPU Context.<br/>
	/// @param createinfo a struct describing the state of the texture to create.<br/>
	/// @returns a texture object on success, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_UploadToGPUTexture<br/>
	/// @sa SDL_DownloadFromGPUTexture<br/>
	/// @sa SDL_BindGPUVertexSamplers<br/>
	/// @sa SDL_BindGPUVertexStorageTextures<br/>
	/// @sa SDL_BindGPUFragmentSamplers<br/>
	/// @sa SDL_BindGPUFragmentStorageTextures<br/>
	/// @sa SDL_BindGPUComputeStorageTextures<br/>
	/// @sa SDL_BlitGPUTexture<br/>
	/// @sa SDL_ReleaseGPUTexture<br/>
	/// @sa SDL_GPUTextureSupportsFormat
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUTexture")]
	public static partial SDL_GPUTexture SDL_CreateGPUTexture(SDL_GPUDevice device, SDL_GPUTextureCreateInfo* createinfo);

	/// <summary>
	/// Creates a buffer object to be used in graphics or compute workflows.<br/>
	/// The contents of this buffer are undefined until data is written to the<br/>
	/// buffer.<br/>
	/// Note that certain combinations of usage flags are invalid. For example, a<br/>
	/// buffer cannot have both the VERTEX and INDEX flags.<br/>
	/// <br/>
	/// @param device a GPU Context.<br/>
	/// @param createinfo a struct describing the state of the buffer to create.<br/>
	/// @returns a buffer object on success, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SetGPUBufferName<br/>
	/// @sa SDL_UploadToGPUBuffer<br/>
	/// @sa SDL_DownloadFromGPUBuffer<br/>
	/// @sa SDL_CopyGPUBufferToBuffer<br/>
	/// @sa SDL_BindGPUVertexBuffers<br/>
	/// @sa SDL_BindGPUIndexBuffer<br/>
	/// @sa SDL_BindGPUVertexStorageBuffers<br/>
	/// @sa SDL_BindGPUFragmentStorageBuffers<br/>
	/// @sa SDL_DrawGPUPrimitivesIndirect<br/>
	/// @sa SDL_DrawGPUIndexedPrimitivesIndirect<br/>
	/// @sa SDL_BindGPUComputeStorageBuffers<br/>
	/// @sa SDL_DispatchGPUComputeIndirect<br/>
	/// @sa SDL_ReleaseGPUBuffer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUBuffer")]
	public static partial SDL_GPUBuffer SDL_CreateGPUBuffer(SDL_GPUDevice device, SDL_GPUBufferCreateInfo* createinfo);

	/// <summary>
	/// Creates a transfer buffer to be used when uploading to or downloading from<br/>
	/// graphics resources.<br/>
	/// <br/>
	/// @param device a GPU Context.<br/>
	/// @param createinfo a struct describing the state of the transfer buffer to<br/>
	/// create.<br/>
	/// @returns a transfer buffer on success, or NULL on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_UploadToGPUBuffer<br/>
	/// @sa SDL_DownloadFromGPUBuffer<br/>
	/// @sa SDL_UploadToGPUTexture<br/>
	/// @sa SDL_DownloadFromGPUTexture<br/>
	/// @sa SDL_ReleaseGPUTransferBuffer
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateGPUTransferBuffer")]
	public static partial SDL_GPUTransferBuffer SDL_CreateGPUTransferBuffer(SDL_GPUDevice device, SDL_GPUTransferBufferCreateInfo* createinfo);

	/// <summary>
	/// Sets an arbitrary string constant to label a buffer.<br/>
	/// Useful for debugging.<br/>
	/// <br/>
	/// @param device a GPU Context.<br/>
	/// @param buffer a buffer to attach the name to.<br/>
	/// @param text a UTF-8 string constant to mark as the name of the buffer.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUBufferName")]
	public static partial void SDL_SetGPUBufferName(SDL_GPUDevice device, SDL_GPUBuffer buffer, byte* text);

	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUBufferName")]
	public static partial void SDL_SetGPUBufferName(SDL_GPUDevice device, SDL_GPUBuffer buffer, ReadOnlySpan<byte> text);

	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUBufferName")]
	public static partial void SDL_SetGPUBufferName(SDL_GPUDevice device, SDL_GPUBuffer buffer, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> text);

	/// <summary>
	/// Sets an arbitrary string constant to label a texture.<br/>
	/// Useful for debugging.<br/>
	/// <br/>
	/// @param device a GPU Context.<br/>
	/// @param texture a texture to attach the name to.<br/>
	/// @param text a UTF-8 string constant to mark as the name of the texture.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUTextureName")]
	public static partial void SDL_SetGPUTextureName(SDL_GPUDevice device, SDL_GPUTexture texture, byte* text);

	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUTextureName")]
	public static partial void SDL_SetGPUTextureName(SDL_GPUDevice device, SDL_GPUTexture texture, ReadOnlySpan<byte> text);

	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUTextureName")]
	public static partial void SDL_SetGPUTextureName(SDL_GPUDevice device, SDL_GPUTexture texture, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> text);

	/// <summary>
	/// Inserts an arbitrary string label into the command buffer callstream.<br/>
	/// Useful for debugging.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @param text a UTF-8 string constant to insert as the label.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_InsertGPUDebugLabel")]
	public static partial void SDL_InsertGPUDebugLabel(SDL_GPUCommandBuffer command_buffer, byte* text);

	[LibraryImport(LibName, EntryPoint = "SDL_InsertGPUDebugLabel")]
	public static partial void SDL_InsertGPUDebugLabel(SDL_GPUCommandBuffer command_buffer, ReadOnlySpan<byte> text);

	[LibraryImport(LibName, EntryPoint = "SDL_InsertGPUDebugLabel")]
	public static partial void SDL_InsertGPUDebugLabel(SDL_GPUCommandBuffer command_buffer, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> text);

	/// <summary>
	/// Begins a debug group with an arbitary name.<br/>
	/// Used for denoting groups of calls when viewing the command buffer<br/>
	/// callstream in a graphics debugging tool.<br/>
	/// Each call to SDL_PushGPUDebugGroup must have a corresponding call to<br/>
	/// SDL_PopGPUDebugGroup.<br/>
	/// On some backends (e.g. Metal), pushing a debug group during a<br/>
	/// render/blit/compute pass will create a group that is scoped to the native<br/>
	/// pass rather than the command buffer. For best results, if you push a debug<br/>
	/// group during a pass, always pop it in the same pass.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @param name a UTF-8 string constant that names the group.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PopGPUDebugGroup
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PushGPUDebugGroup")]
	public static partial void SDL_PushGPUDebugGroup(SDL_GPUCommandBuffer command_buffer, byte* name);

	[LibraryImport(LibName, EntryPoint = "SDL_PushGPUDebugGroup")]
	public static partial void SDL_PushGPUDebugGroup(SDL_GPUCommandBuffer command_buffer, ReadOnlySpan<byte> name);

	[LibraryImport(LibName, EntryPoint = "SDL_PushGPUDebugGroup")]
	public static partial void SDL_PushGPUDebugGroup(SDL_GPUCommandBuffer command_buffer, [global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name);

	/// <summary>
	/// Ends the most-recently pushed debug group.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_PushGPUDebugGroup
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PopGPUDebugGroup")]
	public static partial void SDL_PopGPUDebugGroup(SDL_GPUCommandBuffer command_buffer);

	/// <summary>
	/// Frees the given texture as soon as it is safe to do so.<br/>
	/// You must not reference the texture after calling this function.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param texture a texture to be destroyed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReleaseGPUTexture")]
	public static partial void SDL_ReleaseGPUTexture(SDL_GPUDevice device, SDL_GPUTexture texture);

	/// <summary>
	/// Frees the given sampler as soon as it is safe to do so.<br/>
	/// You must not reference the sampler after calling this function.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param sampler a sampler to be destroyed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReleaseGPUSampler")]
	public static partial void SDL_ReleaseGPUSampler(SDL_GPUDevice device, SDL_GPUSampler sampler);

	/// <summary>
	/// Frees the given buffer as soon as it is safe to do so.<br/>
	/// You must not reference the buffer after calling this function.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param buffer a buffer to be destroyed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReleaseGPUBuffer")]
	public static partial void SDL_ReleaseGPUBuffer(SDL_GPUDevice device, SDL_GPUBuffer buffer);

	/// <summary>
	/// Frees the given transfer buffer as soon as it is safe to do so.<br/>
	/// You must not reference the transfer buffer after calling this function.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param transfer_buffer a transfer buffer to be destroyed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReleaseGPUTransferBuffer")]
	public static partial void SDL_ReleaseGPUTransferBuffer(SDL_GPUDevice device, SDL_GPUTransferBuffer transfer_buffer);

	/// <summary>
	/// Frees the given compute pipeline as soon as it is safe to do so.<br/>
	/// You must not reference the compute pipeline after calling this function.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param compute_pipeline a compute pipeline to be destroyed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReleaseGPUComputePipeline")]
	public static partial void SDL_ReleaseGPUComputePipeline(SDL_GPUDevice device, SDL_GPUComputePipeline compute_pipeline);

	/// <summary>
	/// Frees the given shader as soon as it is safe to do so.<br/>
	/// You must not reference the shader after calling this function.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param shader a shader to be destroyed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReleaseGPUShader")]
	public static partial void SDL_ReleaseGPUShader(SDL_GPUDevice device, SDL_GPUShader shader);

	/// <summary>
	/// Frees the given graphics pipeline as soon as it is safe to do so.<br/>
	/// You must not reference the graphics pipeline after calling this function.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param graphics_pipeline a graphics pipeline to be destroyed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReleaseGPUGraphicsPipeline")]
	public static partial void SDL_ReleaseGPUGraphicsPipeline(SDL_GPUDevice device, SDL_GPUGraphicsPipeline graphics_pipeline);

	/// <summary>
	/// Acquire a command buffer.<br/>
	/// This command buffer is managed by the implementation and should not be<br/>
	/// freed by the user. The command buffer may only be used on the thread it was<br/>
	/// acquired on. The command buffer should be submitted on the thread it was<br/>
	/// acquired on.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @returns a command buffer, or NULL on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SubmitGPUCommandBuffer<br/>
	/// @sa SDL_SubmitGPUCommandBufferAndAcquireFence
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AcquireGPUCommandBuffer")]
	public static partial SDL_GPUCommandBuffer SDL_AcquireGPUCommandBuffer(SDL_GPUDevice device);

	/// <summary>
	/// Pushes data to a vertex uniform slot on the command buffer.<br/>
	/// Subsequent draw calls will use this uniform data.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @param slot_index the vertex uniform slot to push data to.<br/>
	/// @param data client data to write.<br/>
	/// @param length the length of the data to write.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PushGPUVertexUniformData")]
	public static partial void SDL_PushGPUVertexUniformData(SDL_GPUCommandBuffer command_buffer, uint slot_index, nint data, uint length);

	/// <summary>
	/// Pushes data to a fragment uniform slot on the command buffer.<br/>
	/// Subsequent draw calls will use this uniform data.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @param slot_index the fragment uniform slot to push data to.<br/>
	/// @param data client data to write.<br/>
	/// @param length the length of the data to write.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PushGPUFragmentUniformData")]
	public static partial void SDL_PushGPUFragmentUniformData(SDL_GPUCommandBuffer command_buffer, uint slot_index, nint data, uint length);

	/// <summary>
	/// Pushes data to a uniform slot on the command buffer.<br/>
	/// Subsequent draw calls will use this uniform data.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @param slot_index the uniform slot to push data to.<br/>
	/// @param data client data to write.<br/>
	/// @param length the length of the data to write.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_PushGPUComputeUniformData")]
	public static partial void SDL_PushGPUComputeUniformData(SDL_GPUCommandBuffer command_buffer, uint slot_index, nint data, uint length);

	/// <summary>
	/// Begins a render pass on a command buffer.<br/>
	/// A render pass consists of a set of texture subresources (or depth slices in<br/>
	/// the 3D texture case) which will be rendered to during the render pass,<br/>
	/// along with corresponding clear values and load/store operations. All<br/>
	/// operations related to graphics pipelines must take place inside of a render<br/>
	/// pass. A default viewport and scissor state are automatically set when this<br/>
	/// is called. You cannot begin another render pass, or begin a compute pass or<br/>
	/// copy pass until you have ended the render pass.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @param color_target_infos an array of texture subresources with<br/>
	/// corresponding clear values and load/store ops.<br/>
	/// @param num_color_targets the number of color targets in the<br/>
	/// color_target_infos array.<br/>
	/// @param depth_stencil_target_info a texture subresource with corresponding<br/>
	/// clear value and load/store ops, may be<br/>
	/// NULL.<br/>
	/// @returns a render pass handle.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_EndGPURenderPass
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BeginGPURenderPass")]
	public static partial SDL_GPURenderPass SDL_BeginGPURenderPass(SDL_GPUCommandBuffer command_buffer, SDL_GPUColorTargetInfo* color_target_infos, uint num_color_targets, SDL_GPUDepthStencilTargetInfo* depth_stencil_target_info);

	/// <summary>
	/// Binds a graphics pipeline on a render pass to be used in rendering.<br/>
	/// A graphics pipeline must be bound before making any draw calls.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param graphics_pipeline the graphics pipeline to bind.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUGraphicsPipeline")]
	public static partial void SDL_BindGPUGraphicsPipeline(SDL_GPURenderPass render_pass, SDL_GPUGraphicsPipeline graphics_pipeline);

	/// <summary>
	/// Sets the current viewport state on a command buffer.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param viewport the viewport to set.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUViewport")]
	public static partial void SDL_SetGPUViewport(SDL_GPURenderPass render_pass, SDL_GPUViewport* viewport);

	/// <summary>
	/// Sets the current scissor state on a command buffer.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param scissor the scissor area to set.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUScissor")]
	public static partial void SDL_SetGPUScissor(SDL_GPURenderPass render_pass, Rectangle* scissor);

	/// <summary>
	/// Sets the current blend constants on a command buffer.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param blend_constants the blend constant color.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_GPU_BLENDFACTOR_CONSTANT_COLOR<br/>
	/// @sa SDL_GPU_BLENDFACTOR_ONE_MINUS_CONSTANT_COLOR
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUBlendConstants")]
	public static partial void SDL_SetGPUBlendConstants(SDL_GPURenderPass render_pass, SDL_FColor blend_constants);

	/// <summary>
	/// Sets the current stencil reference value on a command buffer.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param reference the stencil reference value to set.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUStencilReference")]
	public static partial void SDL_SetGPUStencilReference(SDL_GPURenderPass render_pass, byte reference);

	/// <summary>
	/// Binds vertex buffers on a command buffer for use with subsequent draw<br/>
	/// calls.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param first_slot the vertex buffer slot to begin binding from.<br/>
	/// @param bindings an array of SDL_GPUBufferBinding structs containing vertex<br/>
	/// buffers and offset values.<br/>
	/// @param num_bindings the number of bindings in the bindings array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUVertexBuffers")]
	public static partial void SDL_BindGPUVertexBuffers(SDL_GPURenderPass render_pass, uint first_slot, SDL_GPUBufferBinding* bindings, uint num_bindings);

	/// <summary>
	/// Binds an index buffer on a command buffer for use with subsequent draw<br/>
	/// calls.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param binding a pointer to a struct containing an index buffer and offset.<br/>
	/// @param index_element_size whether the index values in the buffer are 16- or<br/>
	/// 32-bit.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUIndexBuffer")]
	public static partial void SDL_BindGPUIndexBuffer(SDL_GPURenderPass render_pass, SDL_GPUBufferBinding* binding, SDL_GPUIndexElementSize index_element_size);

	/// <summary>
	/// Binds texture-sampler pairs for use on the vertex shader.<br/>
	/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param first_slot the vertex sampler slot to begin binding from.<br/>
	/// @param texture_sampler_bindings an array of texture-sampler binding<br/>
	/// structs.<br/>
	/// @param num_bindings the number of texture-sampler pairs to bind from the<br/>
	/// array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUVertexSamplers")]
	public static partial void SDL_BindGPUVertexSamplers(SDL_GPURenderPass render_pass, uint first_slot, SDL_GPUTextureSamplerBinding* texture_sampler_bindings, uint num_bindings);

	/// <summary>
	/// Binds storage textures for use on the vertex shader.<br/>
	/// These textures must have been created with<br/>
	/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param first_slot the vertex storage texture slot to begin binding from.<br/>
	/// @param storage_textures an array of storage textures.<br/>
	/// @param num_bindings the number of storage texture to bind from the array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUVertexStorageTextures")]
	public static partial void SDL_BindGPUVertexStorageTextures(SDL_GPURenderPass render_pass, uint first_slot, SDL_GPUTexture** storage_textures, uint num_bindings);

	/// <summary>
	/// Binds storage buffers for use on the vertex shader.<br/>
	/// These buffers must have been created with<br/>
	/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param first_slot the vertex storage buffer slot to begin binding from.<br/>
	/// @param storage_buffers an array of buffers.<br/>
	/// @param num_bindings the number of buffers to bind from the array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUVertexStorageBuffers")]
	public static partial void SDL_BindGPUVertexStorageBuffers(SDL_GPURenderPass render_pass, uint first_slot, SDL_GPUBuffer** storage_buffers, uint num_bindings);

	/// <summary>
	/// Binds texture-sampler pairs for use on the fragment shader.<br/>
	/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param first_slot the fragment sampler slot to begin binding from.<br/>
	/// @param texture_sampler_bindings an array of texture-sampler binding<br/>
	/// structs.<br/>
	/// @param num_bindings the number of texture-sampler pairs to bind from the<br/>
	/// array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUFragmentSamplers")]
	public static partial void SDL_BindGPUFragmentSamplers(SDL_GPURenderPass render_pass, uint first_slot, SDL_GPUTextureSamplerBinding* texture_sampler_bindings, uint num_bindings);

	/// <summary>
	/// Binds storage textures for use on the fragment shader.<br/>
	/// These textures must have been created with<br/>
	/// SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param first_slot the fragment storage texture slot to begin binding from.<br/>
	/// @param storage_textures an array of storage textures.<br/>
	/// @param num_bindings the number of storage textures to bind from the array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUFragmentStorageTextures")]
	public static partial void SDL_BindGPUFragmentStorageTextures(SDL_GPURenderPass render_pass, uint first_slot, SDL_GPUTexture** storage_textures, uint num_bindings);

	/// <summary>
	/// Binds storage buffers for use on the fragment shader.<br/>
	/// These buffers must have been created with<br/>
	/// SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param first_slot the fragment storage buffer slot to begin binding from.<br/>
	/// @param storage_buffers an array of storage buffers.<br/>
	/// @param num_bindings the number of storage buffers to bind from the array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUFragmentStorageBuffers")]
	public static partial void SDL_BindGPUFragmentStorageBuffers(SDL_GPURenderPass render_pass, uint first_slot, SDL_GPUBuffer** storage_buffers, uint num_bindings);

	/// <summary>
	/// Draws data using bound graphics state with an index buffer and instancing<br/>
	/// enabled.<br/>
	/// You must not call this function before binding a graphics pipeline.<br/>
	/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
	/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
	/// example, SV_VertexID). If your shader depends on these variables, the<br/>
	/// correlating draw call parameter MUST be 0.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param num_indices the number of indices to draw per instance.<br/>
	/// @param num_instances the number of instances to draw.<br/>
	/// @param first_index the starting index within the index buffer.<br/>
	/// @param vertex_offset value added to vertex index before indexing into the<br/>
	/// vertex buffer.<br/>
	/// @param first_instance the ID of the first instance to draw.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DrawGPUIndexedPrimitives")]
	public static partial void SDL_DrawGPUIndexedPrimitives(SDL_GPURenderPass render_pass, uint num_indices, uint num_instances, uint first_index, int vertex_offset, uint first_instance);

	/// <summary>
	/// Draws data using bound graphics state.<br/>
	/// You must not call this function before binding a graphics pipeline.<br/>
	/// Note that the `first_vertex` and `first_instance` parameters are NOT<br/>
	/// compatible with built-in vertex/instance ID variables in shaders (for<br/>
	/// example, SV_VertexID). If your shader depends on these variables, the<br/>
	/// correlating draw call parameter MUST be 0.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param num_vertices the number of vertices to draw.<br/>
	/// @param num_instances the number of instances that will be drawn.<br/>
	/// @param first_vertex the index of the first vertex to draw.<br/>
	/// @param first_instance the ID of the first instance to draw.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DrawGPUPrimitives")]
	public static partial void SDL_DrawGPUPrimitives(SDL_GPURenderPass render_pass, uint num_vertices, uint num_instances, uint first_vertex, uint first_instance);

	/// <summary>
	/// Draws data using bound graphics state and with draw parameters set from a<br/>
	/// buffer.<br/>
	/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
	/// match the layout of SDL_GPUIndirectDrawCommand. You must not call this<br/>
	/// function before binding a graphics pipeline.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param buffer a buffer containing draw parameters.<br/>
	/// @param offset the offset to start reading from the draw buffer.<br/>
	/// @param draw_count the number of draw parameter sets that should be read<br/>
	/// from the draw buffer.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DrawGPUPrimitivesIndirect")]
	public static partial void SDL_DrawGPUPrimitivesIndirect(SDL_GPURenderPass render_pass, SDL_GPUBuffer buffer, uint offset, uint draw_count);

	/// <summary>
	/// Draws data using bound graphics state with an index buffer enabled and with<br/>
	/// draw parameters set from a buffer.<br/>
	/// The buffer must consist of tightly-packed draw parameter sets that each<br/>
	/// match the layout of SDL_GPUIndexedIndirectDrawCommand. You must not call<br/>
	/// this function before binding a graphics pipeline.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// @param buffer a buffer containing draw parameters.<br/>
	/// @param offset the offset to start reading from the draw buffer.<br/>
	/// @param draw_count the number of draw parameter sets that should be read<br/>
	/// from the draw buffer.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DrawGPUIndexedPrimitivesIndirect")]
	public static partial void SDL_DrawGPUIndexedPrimitivesIndirect(SDL_GPURenderPass render_pass, SDL_GPUBuffer buffer, uint offset, uint draw_count);

	/// <summary>
	/// Ends the given render pass.<br/>
	/// All bound graphics state on the render pass command buffer is unset. The<br/>
	/// render pass handle is now invalid.<br/>
	/// <br/>
	/// @param render_pass a render pass handle.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EndGPURenderPass")]
	public static partial void SDL_EndGPURenderPass(SDL_GPURenderPass render_pass);

	/// <summary>
	/// Begins a compute pass on a command buffer.<br/>
	/// A compute pass is defined by a set of texture subresources and buffers that<br/>
	/// may be written to by compute pipelines. These textures and buffers must<br/>
	/// have been created with the COMPUTE_STORAGE_WRITE bit or the<br/>
	/// COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE bit. If you do not create a texture<br/>
	/// with COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE, you must not read from the<br/>
	/// texture in the compute pass. All operations related to compute pipelines<br/>
	/// must take place inside of a compute pass. You must not begin another<br/>
	/// compute pass, or a render pass or copy pass before ending the compute pass.<br/>
	/// A VERY IMPORTANT NOTE - Reads and writes in compute passes are NOT<br/>
	/// implicitly synchronized. This means you may cause data races by both<br/>
	/// reading and writing a resource region in a compute pass, or by writing<br/>
	/// multiple times to a resource region. If your compute work depends on<br/>
	/// reading the completed output from a previous dispatch, you MUST end the<br/>
	/// current compute pass and begin a new one before you can safely access the<br/>
	/// data. Otherwise you will receive unexpected results. Reading and writing a<br/>
	/// texture in the same compute pass is only supported by specific texture<br/>
	/// formats. Make sure you check the format support!<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @param storage_texture_bindings an array of writeable storage texture<br/>
	/// binding structs.<br/>
	/// @param num_storage_texture_bindings the number of storage textures to bind<br/>
	/// from the array.<br/>
	/// @param storage_buffer_bindings an array of writeable storage buffer binding<br/>
	/// structs.<br/>
	/// @param num_storage_buffer_bindings the number of storage buffers to bind<br/>
	/// from the array.<br/>
	/// @returns a compute pass handle.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_EndGPUComputePass
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BeginGPUComputePass")]
	public static partial SDL_GPUComputePass SDL_BeginGPUComputePass(SDL_GPUCommandBuffer command_buffer, SDL_GPUStorageTextureReadWriteBinding* storage_texture_bindings, uint num_storage_texture_bindings, SDL_GPUStorageBufferReadWriteBinding* storage_buffer_bindings, uint num_storage_buffer_bindings);

	/// <summary>
	/// Binds a compute pipeline on a command buffer for use in compute dispatch.<br/>
	/// <br/>
	/// @param compute_pass a compute pass handle.<br/>
	/// @param compute_pipeline a compute pipeline to bind.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUComputePipeline")]
	public static partial void SDL_BindGPUComputePipeline(SDL_GPUComputePass compute_pass, SDL_GPUComputePipeline compute_pipeline);

	/// <summary>
	/// Binds texture-sampler pairs for use on the compute shader.<br/>
	/// The textures must have been created with SDL_GPU_TEXTUREUSAGE_SAMPLER.<br/>
	/// <br/>
	/// @param compute_pass a compute pass handle.<br/>
	/// @param first_slot the compute sampler slot to begin binding from.<br/>
	/// @param texture_sampler_bindings an array of texture-sampler binding<br/>
	/// structs.<br/>
	/// @param num_bindings the number of texture-sampler bindings to bind from the<br/>
	/// array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUComputeSamplers")]
	public static partial void SDL_BindGPUComputeSamplers(SDL_GPUComputePass compute_pass, uint first_slot, SDL_GPUTextureSamplerBinding* texture_sampler_bindings, uint num_bindings);

	/// <summary>
	/// Binds storage textures as readonly for use on the compute pipeline.<br/>
	/// These textures must have been created with<br/>
	/// SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ.<br/>
	/// <br/>
	/// @param compute_pass a compute pass handle.<br/>
	/// @param first_slot the compute storage texture slot to begin binding from.<br/>
	/// @param storage_textures an array of storage textures.<br/>
	/// @param num_bindings the number of storage textures to bind from the array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUComputeStorageTextures")]
	public static partial void SDL_BindGPUComputeStorageTextures(SDL_GPUComputePass compute_pass, uint first_slot, SDL_GPUTexture** storage_textures, uint num_bindings);

	/// <summary>
	/// Binds storage buffers as readonly for use on the compute pipeline.<br/>
	/// These buffers must have been created with<br/>
	/// SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ.<br/>
	/// <br/>
	/// @param compute_pass a compute pass handle.<br/>
	/// @param first_slot the compute storage buffer slot to begin binding from.<br/>
	/// @param storage_buffers an array of storage buffer binding structs.<br/>
	/// @param num_bindings the number of storage buffers to bind from the array.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BindGPUComputeStorageBuffers")]
	public static partial void SDL_BindGPUComputeStorageBuffers(SDL_GPUComputePass compute_pass, uint first_slot, SDL_GPUBuffer** storage_buffers, uint num_bindings);

	/// <summary>
	/// Dispatches compute work.<br/>
	/// You must not call this function before binding a compute pipeline.<br/>
	/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
	/// the dispatches write to the same resource region as each other, there is no<br/>
	/// guarantee of which order the writes will occur. If the write order matters,<br/>
	/// you MUST end the compute pass and begin another one.<br/>
	/// <br/>
	/// @param compute_pass a compute pass handle.<br/>
	/// @param groupcount_x number of local workgroups to dispatch in the X<br/>
	/// dimension.<br/>
	/// @param groupcount_y number of local workgroups to dispatch in the Y<br/>
	/// dimension.<br/>
	/// @param groupcount_z number of local workgroups to dispatch in the Z<br/>
	/// dimension.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DispatchGPUCompute")]
	public static partial void SDL_DispatchGPUCompute(SDL_GPUComputePass compute_pass, uint groupcount_x, uint groupcount_y, uint groupcount_z);

	/// <summary>
	/// Dispatches compute work with parameters set from a buffer.<br/>
	/// The buffer layout should match the layout of<br/>
	/// SDL_GPUIndirectDispatchCommand. You must not call this function before<br/>
	/// binding a compute pipeline.<br/>
	/// A VERY IMPORTANT NOTE If you dispatch multiple times in a compute pass, and<br/>
	/// the dispatches write to the same resource region as each other, there is no<br/>
	/// guarantee of which order the writes will occur. If the write order matters,<br/>
	/// you MUST end the compute pass and begin another one.<br/>
	/// <br/>
	/// @param compute_pass a compute pass handle.<br/>
	/// @param buffer a buffer containing dispatch parameters.<br/>
	/// @param offset the offset to start reading from the dispatch buffer.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DispatchGPUComputeIndirect")]
	public static partial void SDL_DispatchGPUComputeIndirect(SDL_GPUComputePass compute_pass, SDL_GPUBuffer buffer, uint offset);

	/// <summary>
	/// Ends the current compute pass.<br/>
	/// All bound compute state on the command buffer is unset. The compute pass<br/>
	/// handle is now invalid.<br/>
	/// <br/>
	/// @param compute_pass a compute pass handle.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EndGPUComputePass")]
	public static partial void SDL_EndGPUComputePass(SDL_GPUComputePass compute_pass);

	/// <summary>
	/// Maps a transfer buffer into application address space.<br/>
	/// You must unmap the transfer buffer before encoding upload commands.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param transfer_buffer a transfer buffer.<br/>
	/// @param cycle if true, cycles the transfer buffer if it is already bound.<br/>
	/// @returns the address of the mapped transfer buffer memory, or NULL on<br/>
	/// failure; call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_MapGPUTransferBuffer")]
	public static partial nint SDL_MapGPUTransferBuffer(SDL_GPUDevice device, SDL_GPUTransferBuffer transfer_buffer, SDLBool cycle);

	/// <summary>
	/// Unmaps a previously mapped transfer buffer.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param transfer_buffer a previously mapped transfer buffer.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnmapGPUTransferBuffer")]
	public static partial void SDL_UnmapGPUTransferBuffer(SDL_GPUDevice device, SDL_GPUTransferBuffer transfer_buffer);

	/// <summary>
	/// Begins a copy pass on a command buffer.<br/>
	/// All operations related to copying to or from buffers or textures take place<br/>
	/// inside a copy pass. You must not begin another copy pass, or a render pass<br/>
	/// or compute pass before ending the copy pass.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @returns a copy pass handle.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BeginGPUCopyPass")]
	public static partial SDL_GPUCopyPass SDL_BeginGPUCopyPass(SDL_GPUCommandBuffer command_buffer);

	/// <summary>
	/// Uploads data from a transfer buffer to a texture.<br/>
	/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
	/// finished in subsequent commands.<br/>
	/// You must align the data in the transfer buffer to a multiple of the texel<br/>
	/// size of the texture format.<br/>
	/// <br/>
	/// @param copy_pass a copy pass handle.<br/>
	/// @param source the source transfer buffer with image layout information.<br/>
	/// @param destination the destination texture region.<br/>
	/// @param cycle if true, cycles the texture if the texture is bound, otherwise<br/>
	/// overwrites the data.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UploadToGPUTexture")]
	public static partial void SDL_UploadToGPUTexture(SDL_GPUCopyPass copy_pass, SDL_GPUTextureTransferInfo* source, SDL_GPUTextureRegion* destination, SDLBool cycle);

	/// <summary>
	/// Uploads data from a transfer buffer to a buffer.<br/>
	/// The upload occurs on the GPU timeline. You may assume that the upload has<br/>
	/// finished in subsequent commands.<br/>
	/// <br/>
	/// @param copy_pass a copy pass handle.<br/>
	/// @param source the source transfer buffer with offset.<br/>
	/// @param destination the destination buffer with offset and size.<br/>
	/// @param cycle if true, cycles the buffer if it is already bound, otherwise<br/>
	/// overwrites the data.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UploadToGPUBuffer")]
	public static partial void SDL_UploadToGPUBuffer(SDL_GPUCopyPass copy_pass, SDL_GPUTransferBufferLocation* source, SDL_GPUBufferRegion* destination, SDLBool cycle);

	/// <summary>
	/// Performs a texture-to-texture copy.<br/>
	/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
	/// in subsequent commands.<br/>
	/// <br/>
	/// @param copy_pass a copy pass handle.<br/>
	/// @param source a source texture region.<br/>
	/// @param destination a destination texture region.<br/>
	/// @param w the width of the region to copy.<br/>
	/// @param h the height of the region to copy.<br/>
	/// @param d the depth of the region to copy.<br/>
	/// @param cycle if true, cycles the destination texture if the destination<br/>
	/// texture is bound, otherwise overwrites the data.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CopyGPUTextureToTexture")]
	public static partial void SDL_CopyGPUTextureToTexture(SDL_GPUCopyPass copy_pass, SDL_GPUTextureLocation* source, SDL_GPUTextureLocation* destination, uint w, uint h, uint d, SDLBool cycle);

	/// <summary>
	/// Performs a buffer-to-buffer copy.<br/>
	/// This copy occurs on the GPU timeline. You may assume the copy has finished<br/>
	/// in subsequent commands.<br/>
	/// <br/>
	/// @param copy_pass a copy pass handle.<br/>
	/// @param source the buffer and offset to copy from.<br/>
	/// @param destination the buffer and offset to copy to.<br/>
	/// @param size the length of the buffer to copy.<br/>
	/// @param cycle if true, cycles the destination buffer if it is already bound,<br/>
	/// otherwise overwrites the data.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CopyGPUBufferToBuffer")]
	public static partial void SDL_CopyGPUBufferToBuffer(SDL_GPUCopyPass copy_pass, SDL_GPUBufferLocation* source, SDL_GPUBufferLocation* destination, uint size, SDLBool cycle);

	/// <summary>
	/// Copies data from a texture to a transfer buffer on the GPU timeline.<br/>
	/// This data is not guaranteed to be copied until the command buffer fence is<br/>
	/// signaled.<br/>
	/// <br/>
	/// @param copy_pass a copy pass handle.<br/>
	/// @param source the source texture region.<br/>
	/// @param destination the destination transfer buffer with image layout<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DownloadFromGPUTexture")]
	public static partial void SDL_DownloadFromGPUTexture(SDL_GPUCopyPass copy_pass, SDL_GPUTextureRegion* source, SDL_GPUTextureTransferInfo* destination);

	/// <summary>
	/// Copies data from a buffer to a transfer buffer on the GPU timeline.<br/>
	/// This data is not guaranteed to be copied until the command buffer fence is<br/>
	/// signaled.<br/>
	/// <br/>
	/// @param copy_pass a copy pass handle.<br/>
	/// @param source the source buffer with offset and size.<br/>
	/// @param destination the destination transfer buffer with offset.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DownloadFromGPUBuffer")]
	public static partial void SDL_DownloadFromGPUBuffer(SDL_GPUCopyPass copy_pass, SDL_GPUBufferRegion* source, SDL_GPUTransferBufferLocation* destination);

	/// <summary>
	/// Ends the current copy pass.<br/>
	/// <br/>
	/// @param copy_pass a copy pass handle.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EndGPUCopyPass")]
	public static partial void SDL_EndGPUCopyPass(SDL_GPUCopyPass copy_pass);

	/// <summary>
	/// Generates mipmaps for the given texture.<br/>
	/// This function must not be called inside of any pass.<br/>
	/// <br/>
	/// @param command_buffer a command_buffer.<br/>
	/// @param texture a texture with more than 1 mip level.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GenerateMipmapsForGPUTexture")]
	public static partial void SDL_GenerateMipmapsForGPUTexture(SDL_GPUCommandBuffer command_buffer, SDL_GPUTexture texture);

	/// <summary>
	/// Blits from a source texture region to a destination texture region.<br/>
	/// This function must not be called inside of any pass.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @param info the blit info struct containing the blit parameters.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_BlitGPUTexture")]
	public static partial void SDL_BlitGPUTexture(SDL_GPUCommandBuffer command_buffer, SDL_GPUBlitInfo* info);

	/// <summary>
	/// Determines whether a swapchain composition is supported by the window.<br/>
	/// The window must be claimed before calling this function.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param window an SDL_Window.<br/>
	/// @param swapchain_composition the swapchain composition to check.<br/>
	/// @returns true if supported, false if unsupported.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ClaimWindowForGPUDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WindowSupportsGPUSwapchainComposition")]
	public static partial SDLBool SDL_WindowSupportsGPUSwapchainComposition(SDL_GPUDevice device, SDL_Window window, SDL_GPUSwapchainComposition swapchain_composition);

	/// <summary>
	/// Determines whether a presentation mode is supported by the window.<br/>
	/// The window must be claimed before calling this function.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param window an SDL_Window.<br/>
	/// @param present_mode the presentation mode to check.<br/>
	/// @returns true if supported, false if unsupported.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ClaimWindowForGPUDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WindowSupportsGPUPresentMode")]
	public static partial SDLBool SDL_WindowSupportsGPUPresentMode(SDL_GPUDevice device, SDL_Window window, SDL_GPUPresentMode present_mode);

	/// <summary>
	/// Claims a window, creating a swapchain structure for it.<br/>
	/// This must be called before SDL_AcquireGPUSwapchainTexture is called using<br/>
	/// the window. You should only call this function from the thread that created<br/>
	/// the window.<br/>
	/// The swapchain will be created with SDL_GPU_SWAPCHAINCOMPOSITION_SDR and<br/>
	/// SDL_GPU_PRESENTMODE_VSYNC. If you want to have different swapchain<br/>
	/// parameters, you must call SDL_SetGPUSwapchainParameters after claiming the<br/>
	/// window.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param window an SDL_Window.<br/>
	/// @returns true on success, or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AcquireGPUSwapchainTexture<br/>
	/// @sa SDL_ReleaseWindowFromGPUDevice<br/>
	/// @sa SDL_WindowSupportsGPUPresentMode<br/>
	/// @sa SDL_WindowSupportsGPUSwapchainComposition
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ClaimWindowForGPUDevice")]
	public static partial SDLBool SDL_ClaimWindowForGPUDevice(SDL_GPUDevice device, SDL_Window window);

	/// <summary>
	/// Unclaims a window, destroying its swapchain structure.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param window an SDL_Window that has been claimed.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ClaimWindowForGPUDevice
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReleaseWindowFromGPUDevice")]
	public static partial void SDL_ReleaseWindowFromGPUDevice(SDL_GPUDevice device, SDL_Window window);

	/// <summary>
	/// Changes the swapchain parameters for the given claimed window.<br/>
	/// This function will fail if the requested present mode or swapchain<br/>
	/// composition are unsupported by the device. Check if the parameters are<br/>
	/// supported via SDL_WindowSupportsGPUPresentMode /<br/>
	/// SDL_WindowSupportsGPUSwapchainComposition prior to calling this function.<br/>
	/// SDL_GPU_PRESENTMODE_VSYNC and SDL_GPU_SWAPCHAINCOMPOSITION_SDR are always<br/>
	/// supported.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param window an SDL_Window that has been claimed.<br/>
	/// @param swapchain_composition the desired composition of the swapchain.<br/>
	/// @param present_mode the desired present mode for the swapchain.<br/>
	/// @returns true if successful, false on error; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_WindowSupportsGPUPresentMode<br/>
	/// @sa SDL_WindowSupportsGPUSwapchainComposition
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetGPUSwapchainParameters")]
	public static partial SDLBool SDL_SetGPUSwapchainParameters(SDL_GPUDevice device, SDL_Window window, SDL_GPUSwapchainComposition swapchain_composition, SDL_GPUPresentMode present_mode);

	/// <summary>
	/// Obtains the texture format of the swapchain for the given window.<br/>
	/// Note that this format can change if the swapchain parameters change.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param window an SDL_Window that has been claimed.<br/>
	/// @returns the texture format of the swapchain.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetGPUSwapchainTextureFormat")]
	public static partial SDL_GPUTextureFormat SDL_GetGPUSwapchainTextureFormat(SDL_GPUDevice device, SDL_Window window);

	/// <summary>
	/// Acquire a texture to use in presentation.<br/>
	/// When a swapchain texture is acquired on a command buffer, it will<br/>
	/// automatically be submitted for presentation when the command buffer is<br/>
	/// submitted. The swapchain texture should only be referenced by the command<br/>
	/// buffer used to acquire it. The swapchain texture handle can be filled in<br/>
	/// with NULL under certain conditions. This is not necessarily an error. If<br/>
	/// this function returns false then there is an error.<br/>
	/// The swapchain texture is managed by the implementation and must not be<br/>
	/// freed by the user. You MUST NOT call this function from any thread other<br/>
	/// than the one that created the window.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @param window a window that has been claimed.<br/>
	/// @param swapchain_texture a pointer filled in with a swapchain texture<br/>
	/// handle.<br/>
	/// @param swapchain_texture_width a pointer filled in with the swapchain<br/>
	/// texture width, may be NULL.<br/>
	/// @param swapchain_texture_height a pointer filled in with the swapchain<br/>
	/// texture height, may be NULL.<br/>
	/// @returns true on success, false on error; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_ClaimWindowForGPUDevice<br/>
	/// @sa SDL_SubmitGPUCommandBuffer<br/>
	/// @sa SDL_SubmitGPUCommandBufferAndAcquireFence<br/>
	/// @sa SDL_GetWindowSizeInPixels
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_AcquireGPUSwapchainTexture")]
	public static partial SDLBool SDL_AcquireGPUSwapchainTexture(SDL_GPUCommandBuffer command_buffer, SDL_Window window, SDL_GPUTexture swapchain_texture, uint* swapchain_texture_width, uint* swapchain_texture_height);

	/// <summary>
	/// Submits a command buffer so its commands can be processed on the GPU.<br/>
	/// It is invalid to use the command buffer after this is called.<br/>
	/// This must be called from the thread the command buffer was acquired on.<br/>
	/// All commands in the submission are guaranteed to begin executing before any<br/>
	/// command in a subsequent submission begins executing.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @returns true on success, false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AcquireGPUCommandBuffer<br/>
	/// @sa SDL_AcquireGPUSwapchainTexture<br/>
	/// @sa SDL_SubmitGPUCommandBufferAndAcquireFence
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SubmitGPUCommandBuffer")]
	public static partial SDLBool SDL_SubmitGPUCommandBuffer(SDL_GPUCommandBuffer command_buffer);

	/// <summary>
	/// Submits a command buffer so its commands can be processed on the GPU, and<br/>
	/// acquires a fence associated with the command buffer.<br/>
	/// You must release this fence when it is no longer needed or it will cause a<br/>
	/// leak. It is invalid to use the command buffer after this is called.<br/>
	/// This must be called from the thread the command buffer was acquired on.<br/>
	/// All commands in the submission are guaranteed to begin executing before any<br/>
	/// command in a subsequent submission begins executing.<br/>
	/// <br/>
	/// @param command_buffer a command buffer.<br/>
	/// @returns a fence associated with the command buffer, or NULL on failure;<br/>
	/// call SDL_GetError() for more information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_AcquireGPUCommandBuffer<br/>
	/// @sa SDL_AcquireGPUSwapchainTexture<br/>
	/// @sa SDL_SubmitGPUCommandBuffer<br/>
	/// @sa SDL_ReleaseGPUFence
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SubmitGPUCommandBufferAndAcquireFence")]
	public static partial SDL_GPUFence SDL_SubmitGPUCommandBufferAndAcquireFence(SDL_GPUCommandBuffer command_buffer);

	/// <summary>
	/// Blocks the thread until the GPU is completely idle.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @returns true on success, false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_WaitForGPUFences
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WaitForGPUIdle")]
	public static partial SDLBool SDL_WaitForGPUIdle(SDL_GPUDevice device);

	/// <summary>
	/// Blocks the thread until the given fences are signaled.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param wait_all if 0, wait for any fence to be signaled, if 1, wait for all<br/>
	/// fences to be signaled.<br/>
	/// @param fences an array of fences to wait on.<br/>
	/// @param num_fences the number of fences in the fences array.<br/>
	/// @returns true on success, false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SubmitGPUCommandBufferAndAcquireFence<br/>
	/// @sa SDL_WaitForGPUIdle
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WaitForGPUFences")]
	public static partial SDLBool SDL_WaitForGPUFences(SDL_GPUDevice device, SDLBool wait_all, SDL_GPUFence** fences, uint num_fences);

	/// <summary>
	/// Checks the status of a fence.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param fence a fence.<br/>
	/// @returns true if the fence is signaled, false if it is not.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SubmitGPUCommandBufferAndAcquireFence
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_QueryGPUFence")]
	public static partial SDLBool SDL_QueryGPUFence(SDL_GPUDevice device, SDL_GPUFence fence);

	/// <summary>
	/// Releases a fence obtained from SDL_SubmitGPUCommandBufferAndAcquireFence.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param fence a fence.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_SubmitGPUCommandBufferAndAcquireFence
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReleaseGPUFence")]
	public static partial void SDL_ReleaseGPUFence(SDL_GPUDevice device, SDL_GPUFence fence);

	/// <summary>
	/// Obtains the texel block size for a texture format.<br/>
	/// <br/>
	/// @param format the texture format you want to know the texel size of.<br/>
	/// @returns the texel block size of the texture format.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_UploadToGPUTexture
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GPUTextureFormatTexelBlockSize")]
	public static partial uint SDL_GPUTextureFormatTexelBlockSize(SDL_GPUTextureFormat format);

	/// <summary>
	/// Determines whether a texture format is supported for a given type and<br/>
	/// usage.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param format the texture format to check.<br/>
	/// @param type the type of texture (2D, 3D, Cube).<br/>
	/// @param usage a bitmask of all usage scenarios to check.<br/>
	/// @returns whether the texture format is supported for this type and usage.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GPUTextureSupportsFormat")]
	public static partial SDLBool SDL_GPUTextureSupportsFormat(SDL_GPUDevice device, SDL_GPUTextureFormat format, SDL_GPUTextureType type, SDL_GPUTextureUsageFlags usage);

	/// <summary>
	/// Determines if a sample count for a texture format is supported.<br/>
	/// <br/>
	/// @param device a GPU context.<br/>
	/// @param format the texture format to check.<br/>
	/// @param sample_count the sample count to check.<br/>
	/// @returns a hardware-specific version of min(preferred, possible).<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GPUTextureSupportsSampleCount")]
	public static partial SDLBool SDL_GPUTextureSupportsSampleCount(SDL_GPUDevice device, SDL_GPUTextureFormat format, SDL_GPUSampleCount sample_count);

	/// <summary>
	/// An app-supplied function for program entry.<br/>
	/// Apps do not directly create this function; they should create a standard<br/>
	/// ANSI-C `main` function instead. If SDL needs to insert some startup code<br/>
	/// before `main` runs, or the platform doesn't actually _use_ a function<br/>
	/// called "main", SDL will do some macro magic to redefine `main` to<br/>
	/// `SDL_main` and provide its own `main`.<br/>
	/// Apps should include `SDL_main.h` in the same file as their `main` function,<br/>
	/// and they should not use that symbol for anything else in that file, as it<br/>
	/// might get redefined.<br/>
	/// This function is only provided by the app if it isn't using<br/>
	/// SDL_MAIN_USE_CALLBACKS.<br/>
	/// Program startup is a surprisingly complex topic. Please see<br/>
	/// [README/main-functions](README/main-functions), (or<br/>
	/// docs/README-main-functions.md in the source tree) for a more detailed<br/>
	/// explanation.<br/>
	/// <br/>
	/// @param argc an ANSI-C style main function's argc.<br/>
	/// @param argv an ANSI-C style main function's argv.<br/>
	/// @returns an ANSI-C main return code; generally 0 is considered successful<br/>
	/// program completion, and small non-zero values are considered<br/>
	/// errors.<br/>
	/// @threadsafety This is the program entry point.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_main")]
	public static partial int SDL_main(int argc, byte** argv);

	/// <summary>
	/// Circumvent failure of SDL_Init() when not using SDL_main() as an entry<br/>
	/// point.<br/>
	/// This function is defined in SDL_main.h, along with the preprocessor rule to<br/>
	/// redefine main() as SDL_main(). Thus to ensure that your main() function<br/>
	/// will not be changed it is necessary to define SDL_MAIN_HANDLED before<br/>
	/// including SDL.h.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_Init
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_SetMainReady")]
	public static partial void SDL_SetMainReady();

	/// <summary>
	/// Initializes and launches an SDL application, by doing platform-specific<br/>
	/// initialization before calling your mainFunction and cleanups after it<br/>
	/// returns, if that is needed for a specific platform, otherwise it just calls<br/>
	/// mainFunction.<br/>
	/// You can use this if you want to use your own main() implementation without<br/>
	/// using SDL_main (like when using SDL_MAIN_HANDLED). When using this, you do<br/>
	/// *not* need SDL_SetMainReady().<br/>
	/// <br/>
	/// @param argc the argc parameter from the application's main() function, or 0<br/>
	/// if the platform's main-equivalent has no argc.<br/>
	/// @param argv the argv parameter from the application's main() function, or<br/>
	/// NULL if the platform's main-equivalent has no argv.<br/>
	/// @param mainFunction your SDL app's C-style main(). NOT the function you're<br/>
	/// calling this from! Its name doesn't matter; it doesn't<br/>
	/// literally have to be `main`.<br/>
	/// @param reserved should be NULL (reserved for future use, will probably be<br/>
	/// platform-specific then).<br/>
	/// @returns the return value from mainFunction: 0 on success, otherwise<br/>
	/// failure; SDL_GetError() might have more information on the<br/>
	/// failure.<br/>
	/// @threadsafety Generally this is called once, near startup, from the<br/>
	/// process's initial thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RunApp")]
	public static partial int SDL_RunApp(int argc, byte** argv, delegate* unmanaged[Cdecl]<int, byte**, int> mainFunction, nint reserved);

	/// <summary>
	/// An entry point for SDL's use in SDL_MAIN_USE_CALLBACKS.<br/>
	/// Generally, you should not call this function directly. This only exists to<br/>
	/// hand off work into SDL as soon as possible, where it has a lot more control<br/>
	/// and functionality available, and make the inline code in SDL_main.h as<br/>
	/// small as possible.<br/>
	/// Not all platforms use this, it's actual use is hidden in a magic<br/>
	/// header-only library, and you should not call this directly unless you<br/>
	/// _really_ know what you're doing.<br/>
	/// <br/>
	/// @param argc standard Unix main argc.<br/>
	/// @param argv standard Unix main argv.<br/>
	/// @param appinit the application's SDL_AppInit function.<br/>
	/// @param appiter the application's SDL_AppIterate function.<br/>
	/// @param appevent the application's SDL_AppEvent function.<br/>
	/// @param appquit the application's SDL_AppQuit function.<br/>
	/// @returns standard Unix main return value.<br/>
	/// @threadsafety It is not safe to call this anywhere except as the only<br/>
	/// function call in SDL_main.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_EnterAppMainCallbacks")]
	public static partial int SDL_EnterAppMainCallbacks(int argc, byte** argv, delegate* unmanaged[Cdecl]<nint, int, byte**, SDL_AppResult> appinit, delegate* unmanaged[Cdecl]<nint, SDL_AppResult> appiter, delegate* unmanaged[Cdecl]<nint, SDL_Event*, SDL_AppResult> appevent, delegate* unmanaged[Cdecl]<nint, SDL_AppResult, void> appquit);

	/// <summary>
	/// Register a win32 window class for SDL's use.<br/>
	/// This can be called to set the application window class at startup. It is<br/>
	/// safe to call this multiple times, as long as every call is eventually<br/>
	/// paired with a call to SDL_UnregisterApp, but a second registration attempt<br/>
	/// while a previous registration is still active will be ignored, other than<br/>
	/// to increment a counter.<br/>
	/// Most applications do not need to, and should not, call this directly; SDL<br/>
	/// will call it when initializing the video subsystem.<br/>
	/// <br/>
	/// @param name the window class name, in UTF-8 encoding. If NULL, SDL<br/>
	/// currently uses "SDL_app" but this isn't guaranteed.<br/>
	/// @param style the value to use in WNDCLASSEX::style. If `name` is NULL, SDL<br/>
	/// currently uses `(CS_BYTEALIGNCLIENT | CS_OWNDC)` regardless of<br/>
	/// what is specified here.<br/>
	/// @param hInst the HINSTANCE to use in WNDCLASSEX::hInstance. If zero, SDL<br/>
	/// will use `GetModuleHandle(NULL)` instead.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_RegisterApp")]
	public static partial SDLBool SDL_RegisterApp(byte* name, uint style, nint hInst);

	[LibraryImport(LibName, EntryPoint = "SDL_RegisterApp")]
	public static partial SDLBool SDL_RegisterApp(ReadOnlySpan<byte> name, uint style, nint hInst);

	[LibraryImport(LibName, EntryPoint = "SDL_RegisterApp")]
	public static partial SDLBool SDL_RegisterApp([global::System.Runtime.InteropServices.Marshalling.MarshalUsing(typeof(Utf8CustomMarshaller))] ReadOnlySpan<char> name, uint style, nint hInst);

	/// <summary>
	/// Deregister the win32 window class from an SDL_RegisterApp call.<br/>
	/// This can be called to undo the effects of SDL_RegisterApp.<br/>
	/// Most applications do not need to, and should not, call this directly; SDL<br/>
	/// will call it when deinitializing the video subsystem.<br/>
	/// It is safe to call this multiple times, as long as every call is eventually<br/>
	/// paired with a prior call to SDL_RegisterApp. The window class will only be<br/>
	/// deregistered when the registration counter in SDL_RegisterApp decrements to<br/>
	/// zero through calls to this function.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_UnregisterApp")]
	public static partial void SDL_UnregisterApp();

	/// <summary>
	/// Create a new process.<br/>
	/// The path to the executable is supplied in args[0]. args[1..N] are<br/>
	/// additional arguments passed on the command line of the new process, and the<br/>
	/// argument list should be terminated with a NULL, e.g.:<br/>
	/// ```c<br/>
	/// const char *args[] = { "myprogram", "argument", NULL };<br/>
	/// ```<br/>
	/// Setting pipe_stdio to true is equivalent to setting<br/>
	/// `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` and<br/>
	/// `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` to `SDL_PROCESS_STDIO_APP`, and<br/>
	/// will allow the use of SDL_ReadProcess() or SDL_GetProcessInput() and<br/>
	/// SDL_GetProcessOutput().<br/>
	/// See SDL_CreateProcessWithProperties() for more details.<br/>
	/// <br/>
	/// @param args the path and arguments for the new process.<br/>
	/// @param pipe_stdio true to create pipes to the process's standard input and<br/>
	/// from the process's standard output, false for the process<br/>
	/// to have no input and inherit the application's standard<br/>
	/// output.<br/>
	/// @returns the newly created and running process, or NULL if the process<br/>
	/// couldn't be created.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProcessWithProperties<br/>
	/// @sa SDL_GetProcessProperties<br/>
	/// @sa SDL_ReadProcess<br/>
	/// @sa SDL_GetProcessInput<br/>
	/// @sa SDL_GetProcessOutput<br/>
	/// @sa SDL_KillProcess<br/>
	/// @sa SDL_WaitProcess<br/>
	/// @sa SDL_DestroyProcess
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateProcess")]
	public static partial SDL_Process SDL_CreateProcess(byte** args, SDLBool pipe_stdio);

	/// <summary>
	/// Create a new process with the specified properties.<br/>
	/// These are the supported properties:<br/>
	/// - `SDL_PROP_PROCESS_CREATE_ARGS_POINTER`: an array of strings containing<br/>
	/// the program to run, any arguments, and a NULL pointer, e.g. const char<br/>
	/// *args[] = { "myprogram", "argument", NULL }. This is a required property.<br/>
	/// - `SDL_PROP_PROCESS_CREATE_ENVIRONMENT_POINTER`: an SDL_Environment<br/>
	/// pointer. If this property is set, it will be the entire environment for<br/>
	/// the process, otherwise the current environment is used.<br/>
	/// - `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER`: an SDL_ProcessIO value describing<br/>
	/// where standard input for the process comes from, defaults to<br/>
	/// `SDL_PROCESS_STDIO_NULL`.<br/>
	/// - `SDL_PROP_PROCESS_CREATE_STDIN_POINTER`: an SDL_IOStream pointer used for<br/>
	/// standard input when `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` is set to<br/>
	/// `SDL_PROCESS_STDIO_REDIRECT`.<br/>
	/// - `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER`: an SDL_ProcessIO value<br/>
	/// describing where standard output for the process goes go, defaults to<br/>
	/// `SDL_PROCESS_STDIO_INHERITED`.<br/>
	/// - `SDL_PROP_PROCESS_CREATE_STDOUT_POINTER`: an SDL_IOStream pointer used<br/>
	/// for standard output when `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` is set<br/>
	/// to `SDL_PROCESS_STDIO_REDIRECT`.<br/>
	/// - `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER`: an SDL_ProcessIO value<br/>
	/// describing where standard error for the process goes go, defaults to<br/>
	/// `SDL_PROCESS_STDIO_INHERITED`.<br/>
	/// - `SDL_PROP_PROCESS_CREATE_STDERR_POINTER`: an SDL_IOStream pointer used<br/>
	/// for standard error when `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` is set to<br/>
	/// `SDL_PROCESS_STDIO_REDIRECT`.<br/>
	/// - `SDL_PROP_PROCESS_CREATE_STDERR_TO_STDOUT_BOOLEAN`: true if the error<br/>
	/// output of the process should be redirected into the standard output of<br/>
	/// the process. This property has no effect if<br/>
	/// `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` is set.<br/>
	/// - `SDL_PROP_PROCESS_CREATE_BACKGROUND_BOOLEAN`: true if the process should<br/>
	/// run in the background. In this case the default input and output is<br/>
	/// `SDL_PROCESS_STDIO_NULL` and the exitcode of the process is not<br/>
	/// available, and will always be 0.<br/>
	/// On POSIX platforms, wait() and waitpid(-1, ...) should not be called, and<br/>
	/// SIGCHLD should not be ignored or handled because those would prevent SDL<br/>
	/// from properly tracking the lifetime of the underlying process. You should<br/>
	/// use SDL_WaitProcess() instead.<br/>
	/// <br/>
	/// @param props the properties to use.<br/>
	/// @returns the newly created and running process, or NULL if the process<br/>
	/// couldn't be created.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProcess<br/>
	/// @sa SDL_GetProcessProperties<br/>
	/// @sa SDL_ReadProcess<br/>
	/// @sa SDL_GetProcessInput<br/>
	/// @sa SDL_GetProcessOutput<br/>
	/// @sa SDL_KillProcess<br/>
	/// @sa SDL_WaitProcess<br/>
	/// @sa SDL_DestroyProcess
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_CreateProcessWithProperties")]
	public static partial SDL_Process SDL_CreateProcessWithProperties(SDL_PropertiesID props);

	/// <summary>
	/// Get the properties associated with a process.<br/>
	/// The following read-only properties are provided by SDL:<br/>
	/// - `SDL_PROP_PROCESS_PID_NUMBER`: the process ID of the process.<br/>
	/// - `SDL_PROP_PROCESS_STDIN_POINTER`: an SDL_IOStream that can be used to<br/>
	/// write input to the process, if it was created with<br/>
	/// `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` set to `SDL_PROCESS_STDIO_APP`.<br/>
	/// - `SDL_PROP_PROCESS_STDOUT_POINTER`: a non-blocking SDL_IOStream that can<br/>
	/// be used to read output from the process, if it was created with<br/>
	/// `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` set to `SDL_PROCESS_STDIO_APP`.<br/>
	/// - `SDL_PROP_PROCESS_STDERR_POINTER`: a non-blocking SDL_IOStream that can<br/>
	/// be used to read error output from the process, if it was created with<br/>
	/// `SDL_PROP_PROCESS_CREATE_STDERR_NUMBER` set to `SDL_PROCESS_STDIO_APP`.<br/>
	/// - `SDL_PROP_PROCESS_BACKGROUND_BOOLEAN`: true if the process is running in<br/>
	/// the background.<br/>
	/// <br/>
	/// @param process the process to query.<br/>
	/// @returns a valid property ID on success or 0 on failure; call<br/>
	/// SDL_GetError() for more information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProcess<br/>
	/// @sa SDL_CreateProcessWithProperties
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetProcessProperties")]
	public static partial SDL_PropertiesID SDL_GetProcessProperties(SDL_Process process);

	/// <summary>
	/// Read all the output from a process.<br/>
	/// If a process was created with I/O enabled, you can use this function to<br/>
	/// read the output. This function blocks until the process is complete,<br/>
	/// capturing all output, and providing the process exit code.<br/>
	/// The data is allocated with a zero byte at the end (null terminated) for<br/>
	/// convenience. This extra byte is not included in the value reported via<br/>
	/// `datasize`.<br/>
	/// The data should be freed with SDL_free().<br/>
	/// <br/>
	/// @param process The process to read.<br/>
	/// @param datasize a pointer filled in with the number of bytes read, may be<br/>
	/// NULL.<br/>
	/// @param exitcode a pointer filled in with the process exit code if the<br/>
	/// process has exited, may be NULL.<br/>
	/// @returns the data or NULL on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety This function is not thread safe.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProcess<br/>
	/// @sa SDL_CreateProcessWithProperties<br/>
	/// @sa SDL_DestroyProcess
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_ReadProcess")]
	public static partial nint SDL_ReadProcess(SDL_Process process, nuint* datasize, int* exitcode);

	/// <summary>
	/// Get the SDL_IOStream associated with process standard input.<br/>
	/// The process must have been created with SDL_CreateProcess() and pipe_stdio<br/>
	/// set to true, or with SDL_CreateProcessWithProperties() and<br/>
	/// `SDL_PROP_PROCESS_CREATE_STDIN_NUMBER` set to `SDL_PROCESS_STDIO_APP`.<br/>
	/// Writing to this stream can return less data than expected if the process<br/>
	/// hasn't read its input. It may be blocked waiting for its output to be read,<br/>
	/// so if you may need to call SDL_GetOutputStream() and read the output in<br/>
	/// parallel with writing input.<br/>
	/// <br/>
	/// @param process The process to get the input stream for.<br/>
	/// @returns the input stream or NULL on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProcess<br/>
	/// @sa SDL_CreateProcessWithProperties<br/>
	/// @sa SDL_GetProcessOutput
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetProcessInput")]
	public static partial SDL_IOStream SDL_GetProcessInput(SDL_Process process);

	/// <summary>
	/// Get the SDL_IOStream associated with process standard output.<br/>
	/// The process must have been created with SDL_CreateProcess() and pipe_stdio<br/>
	/// set to true, or with SDL_CreateProcessWithProperties() and<br/>
	/// `SDL_PROP_PROCESS_CREATE_STDOUT_NUMBER` set to `SDL_PROCESS_STDIO_APP`.<br/>
	/// Reading from this stream can return 0 with SDL_GetIOStatus() returning<br/>
	/// SDL_IO_STATUS_NOT_READY if no output is available yet.<br/>
	/// <br/>
	/// @param process The process to get the output stream for.<br/>
	/// @returns the output stream or NULL on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety It is safe to call this function from any thread.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProcess<br/>
	/// @sa SDL_CreateProcessWithProperties<br/>
	/// @sa SDL_GetProcessInput
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_GetProcessOutput")]
	public static partial SDL_IOStream SDL_GetProcessOutput(SDL_Process process);

	/// <summary>
	/// Stop a process.<br/>
	/// <br/>
	/// @param process The process to stop.<br/>
	/// @param force true to terminate the process immediately, false to try to<br/>
	/// stop the process gracefully. In general you should try to stop<br/>
	/// the process gracefully first as terminating a process may<br/>
	/// leave it with half-written data or in some other unstable<br/>
	/// state.<br/>
	/// @returns true on success or false on failure; call SDL_GetError() for more<br/>
	/// information.<br/>
	/// @threadsafety This function is not thread safe.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProcess<br/>
	/// @sa SDL_CreateProcessWithProperties<br/>
	/// @sa SDL_WaitProcess<br/>
	/// @sa SDL_DestroyProcess
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_KillProcess")]
	public static partial SDLBool SDL_KillProcess(SDL_Process process, SDLBool force);

	/// <summary>
	/// Wait for a process to finish.<br/>
	/// This can be called multiple times to get the status of a process.<br/>
	/// The exit code will be the exit code of the process if it terminates<br/>
	/// normally, a negative signal if it terminated due to a signal, or -255<br/>
	/// otherwise. It will not be changed if the process is still running.<br/>
	/// <br/>
	/// @param process The process to wait for.<br/>
	/// @param block If true, block until the process finishes; otherwise, report<br/>
	/// on the process' status.<br/>
	/// @param exitcode a pointer filled in with the process exit code if the<br/>
	/// process has exited, may be NULL.<br/>
	/// @returns true if the process exited, false otherwise.<br/>
	/// @threadsafety This function is not thread safe.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProcess<br/>
	/// @sa SDL_CreateProcessWithProperties<br/>
	/// @sa SDL_KillProcess<br/>
	/// @sa SDL_DestroyProcess
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_WaitProcess")]
	public static partial SDLBool SDL_WaitProcess(SDL_Process process, SDLBool block, int* exitcode);

	/// <summary>
	/// Destroy a previously created process object.<br/>
	/// Note that this does not stop the process, just destroys the SDL object used<br/>
	/// to track it. If you want to stop the process you should use<br/>
	/// SDL_KillProcess().<br/>
	/// <br/>
	/// @param process The process object to destroy.<br/>
	/// @threadsafety This function is not thread safe.<br/>
	/// <br/>
	/// @since This function is available since SDL 3.0.0.<br/>
	/// <br/>
	/// @sa SDL_CreateProcess<br/>
	/// @sa SDL_CreateProcessWithProperties<br/>
	/// @sa SDL_KillProcess
	/// </summary>
	[LibraryImport(LibName, EntryPoint = "SDL_DestroyProcess")]
	public static partial void SDL_DestroyProcess(SDL_Process process);

}
