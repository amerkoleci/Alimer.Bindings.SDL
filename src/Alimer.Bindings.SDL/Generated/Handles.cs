// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

#nullable enable

using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;

namespace SDL3;

/// <summary>
/// An atomic spinlock.<br/>
/// The atomic locks are efficient spinlocks using CPU instructions, but are<br/>
/// vulnerable to starvation and can spin forever if a thread holding a lock<br/>
/// has been terminated. For this reason you should minimize the code executed<br/>
/// inside an atomic lock and never do expensive things like API or system<br/>
/// calls while holding them.<br/>
/// They are also vulnerable to starvation if the thread holding the lock is<br/>
/// lower priority than other threads and doesn't get scheduled. In general you<br/>
/// should use mutexes instead, since they have better performance and<br/>
/// contention behavior.<br/>
/// The atomic locks are not safe to lock recursively.<br/>
/// Porting Note: The spin lock functions and type are required and can not be<br/>
/// emulated because they are used in the atomic emulation code.
/// </summary>
public enum SDL_SpinLock : int
{
}

/// <summary>
/// SDL Audio Device instance IDs.<br/>
/// Zero is used to signify an invalid/null device.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_AudioDeviceID : uint
{
}

/// <summary>
/// A set of blend modes used in drawing operations.<br/>
/// These predefined blend modes are supported everywhere.<br/>
/// Additional values may be obtained from SDL_ComposeCustomBlendMode.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_ComposeCustomBlendMode
/// </summary>
[Flags]
public enum SDL_BlendMode : uint
{
	None = SDL3.SDL_BLENDMODE_NONE,
	Blend = SDL3.SDL_BLENDMODE_BLEND,
	BlendPremultiplied = SDL3.SDL_BLENDMODE_BLEND_PREMULTIPLIED,
	Add = SDL3.SDL_BLENDMODE_ADD,
	AddPremultiplied = SDL3.SDL_BLENDMODE_ADD_PREMULTIPLIED,
	Mod = SDL3.SDL_BLENDMODE_MOD,
	Mul = SDL3.SDL_BLENDMODE_MUL,
	Invalid = SDL3.SDL_BLENDMODE_INVALID,
}

/// <summary>
/// This is a unique ID for a camera device for the time it is connected to the<br/>
/// system, and is never reused for the lifetime of the application.<br/>
/// If the device is disconnected and reconnected, it will get a new ID.<br/>
/// The value 0 is an invalid ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_GetCameras
/// </summary>
public enum SDL_CameraID : uint
{
}

/// <summary>
/// Flags for path matching.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_GlobDirectory<br/>
/// @sa SDL_GlobStorageDirectory
/// </summary>
[Flags]
public enum SDL_GlobFlags : uint
{
	CaseInsensitive = SDL3.SDL_GLOB_CASEINSENSITIVE,
}

/// <summary>
/// This is a unique ID for a haptic device for the time it is connected to the<br/>
/// system, and is never reused for the lifetime of the application.<br/>
/// If the haptic device is disconnected and reconnected, it will get a new ID.<br/>
/// The value 0 is an invalid ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_HapticID : uint
{
}

/// <summary>
/// Initialization flags for SDL_Init and/or SDL_InitSubSystem<br/>
/// These are the flags which may be passed to SDL_Init(). You should specify<br/>
/// the subsystems which you will be using in your application.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_Init<br/>
/// @sa SDL_Quit<br/>
/// @sa SDL_InitSubSystem<br/>
/// @sa SDL_QuitSubSystem<br/>
/// @sa SDL_WasInit
/// </summary>
[Flags]
public enum SDL_InitFlags : uint
{
	Audio = SDL3.SDL_INIT_AUDIO,
	Video = SDL3.SDL_INIT_VIDEO,
	Joystick = SDL3.SDL_INIT_JOYSTICK,
	Haptic = SDL3.SDL_INIT_HAPTIC,
	Gamepad = SDL3.SDL_INIT_GAMEPAD,
	Events = SDL3.SDL_INIT_EVENTS,
	Sensor = SDL3.SDL_INIT_SENSOR,
	Camera = SDL3.SDL_INIT_CAMERA,
}

/// <summary>
/// This is a unique ID for a joystick for the time it is connected to the<br/>
/// system, and is never reused for the lifetime of the application.<br/>
/// If the joystick is disconnected and reconnected, it will get a new ID.<br/>
/// The value 0 is an invalid ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_JoystickID : uint
{
}

/// <summary>
/// This is a unique ID for a keyboard for the time it is connected to the<br/>
/// system, and is never reused for the lifetime of the application.<br/>
/// If the keyboard is disconnected and reconnected, it will get a new ID.<br/>
/// The value 0 is an invalid ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_KeyboardID : uint
{
}

/// <summary>
/// The SDL virtual key representation.<br/>
/// Values of this type are used to represent keyboard keys using the current<br/>
/// layout of the keyboard. These values include Unicode values representing<br/>
/// the unmodified character that would be generated by pressing the key, or an<br/>
/// `SDLK_*` constant for those keys that do not generate characters.<br/>
/// A special exception is the number keys at the top of the keyboard which map<br/>
/// to SDLK_0...SDLK_9 on AZERTY layouts.<br/>
/// Keys with the `SDLK_EXTENDED_MASK` bit set do not map to a scancode or<br/>
/// unicode code point.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_Keycode : uint
{
	ExtendedMask = SDL3.SDLK_EXTENDED_MASK,
	Unknown = SDL3.SDLK_UNKNOWN,
	Return = SDL3.SDLK_RETURN,
	Escape = SDL3.SDLK_ESCAPE,
	Backspace = SDL3.SDLK_BACKSPACE,
	Tab = SDL3.SDLK_TAB,
	Space = SDL3.SDLK_SPACE,
	Exclaim = SDL3.SDLK_EXCLAIM,
	Dblapostrophe = SDL3.SDLK_DBLAPOSTROPHE,
	Hash = SDL3.SDLK_HASH,
	Dollar = SDL3.SDLK_DOLLAR,
	Percent = SDL3.SDLK_PERCENT,
	Ampersand = SDL3.SDLK_AMPERSAND,
	Apostrophe = SDL3.SDLK_APOSTROPHE,
	LeftParen = SDL3.SDLK_LEFTPAREN,
	RightParen = SDL3.SDLK_RIGHTPAREN,
	Asterisk = SDL3.SDLK_ASTERISK,
	Plus = SDL3.SDLK_PLUS,
	Comma = SDL3.SDLK_COMMA,
	Minus = SDL3.SDLK_MINUS,
	Period = SDL3.SDLK_PERIOD,
	Slash = SDL3.SDLK_SLASH,
	_0 = SDL3.SDLK_0,
	_1 = SDL3.SDLK_1,
	_2 = SDL3.SDLK_2,
	_3 = SDL3.SDLK_3,
	_4 = SDL3.SDLK_4,
	_5 = SDL3.SDLK_5,
	_6 = SDL3.SDLK_6,
	_7 = SDL3.SDLK_7,
	_8 = SDL3.SDLK_8,
	_9 = SDL3.SDLK_9,
	Colon = SDL3.SDLK_COLON,
	Semicolon = SDL3.SDLK_SEMICOLON,
	Less = SDL3.SDLK_LESS,
	Equals = SDL3.SDLK_EQUALS,
	Greater = SDL3.SDLK_GREATER,
	Question = SDL3.SDLK_QUESTION,
	At = SDL3.SDLK_AT,
	LeftBracket = SDL3.SDLK_LEFTBRACKET,
	Backslash = SDL3.SDLK_BACKSLASH,
	RightBracket = SDL3.SDLK_RIGHTBRACKET,
	Caret = SDL3.SDLK_CARET,
	Underscore = SDL3.SDLK_UNDERSCORE,
	Grave = SDL3.SDLK_GRAVE,
	A = SDL3.SDLK_A,
	B = SDL3.SDLK_B,
	C = SDL3.SDLK_C,
	D = SDL3.SDLK_D,
	E = SDL3.SDLK_E,
	F = SDL3.SDLK_F,
	G = SDL3.SDLK_G,
	H = SDL3.SDLK_H,
	I = SDL3.SDLK_I,
	J = SDL3.SDLK_J,
	K = SDL3.SDLK_K,
	L = SDL3.SDLK_L,
	M = SDL3.SDLK_M,
	N = SDL3.SDLK_N,
	O = SDL3.SDLK_O,
	P = SDL3.SDLK_P,
	Q = SDL3.SDLK_Q,
	R = SDL3.SDLK_R,
	S = SDL3.SDLK_S,
	T = SDL3.SDLK_T,
	U = SDL3.SDLK_U,
	V = SDL3.SDLK_V,
	W = SDL3.SDLK_W,
	X = SDL3.SDLK_X,
	Y = SDL3.SDLK_Y,
	Z = SDL3.SDLK_Z,
	Leftbrace = SDL3.SDLK_LEFTBRACE,
	Pipe = SDL3.SDLK_PIPE,
	Rightbrace = SDL3.SDLK_RIGHTBRACE,
	Tilde = SDL3.SDLK_TILDE,
	Delete = SDL3.SDLK_DELETE,
	PlusMinus = SDL3.SDLK_PLUSMINUS,
	Capslock = SDL3.SDLK_CAPSLOCK,
	F1 = SDL3.SDLK_F1,
	F2 = SDL3.SDLK_F2,
	F3 = SDL3.SDLK_F3,
	F4 = SDL3.SDLK_F4,
	F5 = SDL3.SDLK_F5,
	F6 = SDL3.SDLK_F6,
	F7 = SDL3.SDLK_F7,
	F8 = SDL3.SDLK_F8,
	F9 = SDL3.SDLK_F9,
	F10 = SDL3.SDLK_F10,
	F11 = SDL3.SDLK_F11,
	F12 = SDL3.SDLK_F12,
	PrintScreen = SDL3.SDLK_PRINTSCREEN,
	ScrollLock = SDL3.SDLK_SCROLLLOCK,
	Pause = SDL3.SDLK_PAUSE,
	Insert = SDL3.SDLK_INSERT,
	Home = SDL3.SDLK_HOME,
	PageUp = SDL3.SDLK_PAGEUP,
	End = SDL3.SDLK_END,
	PageDown = SDL3.SDLK_PAGEDOWN,
	Right = SDL3.SDLK_RIGHT,
	Left = SDL3.SDLK_LEFT,
	Down = SDL3.SDLK_DOWN,
	Up = SDL3.SDLK_UP,
	NumLockClear = SDL3.SDLK_NUMLOCKCLEAR,
	KpDivide = SDL3.SDLK_KP_DIVIDE,
	KpMultiply = SDL3.SDLK_KP_MULTIPLY,
	KpMinus = SDL3.SDLK_KP_MINUS,
	KpPlus = SDL3.SDLK_KP_PLUS,
	KpEnter = SDL3.SDLK_KP_ENTER,
	Kp1 = SDL3.SDLK_KP_1,
	Kp2 = SDL3.SDLK_KP_2,
	Kp3 = SDL3.SDLK_KP_3,
	Kp4 = SDL3.SDLK_KP_4,
	Kp5 = SDL3.SDLK_KP_5,
	Kp6 = SDL3.SDLK_KP_6,
	Kp7 = SDL3.SDLK_KP_7,
	Kp8 = SDL3.SDLK_KP_8,
	Kp9 = SDL3.SDLK_KP_9,
	Kp0 = SDL3.SDLK_KP_0,
	KpPeriod = SDL3.SDLK_KP_PERIOD,
	Application = SDL3.SDLK_APPLICATION,
	Power = SDL3.SDLK_POWER,
	KpEquals = SDL3.SDLK_KP_EQUALS,
	F13 = SDL3.SDLK_F13,
	F14 = SDL3.SDLK_F14,
	F15 = SDL3.SDLK_F15,
	F16 = SDL3.SDLK_F16,
	F17 = SDL3.SDLK_F17,
	F18 = SDL3.SDLK_F18,
	F19 = SDL3.SDLK_F19,
	F20 = SDL3.SDLK_F20,
	F21 = SDL3.SDLK_F21,
	F22 = SDL3.SDLK_F22,
	F23 = SDL3.SDLK_F23,
	F24 = SDL3.SDLK_F24,
	Execute = SDL3.SDLK_EXECUTE,
	Help = SDL3.SDLK_HELP,
	Menu = SDL3.SDLK_MENU,
	Select = SDL3.SDLK_SELECT,
	Stop = SDL3.SDLK_STOP,
	Again = SDL3.SDLK_AGAIN,
	Undo = SDL3.SDLK_UNDO,
	Cut = SDL3.SDLK_CUT,
	Copy = SDL3.SDLK_COPY,
	Paste = SDL3.SDLK_PASTE,
	Find = SDL3.SDLK_FIND,
	Mute = SDL3.SDLK_MUTE,
	VolumeUp = SDL3.SDLK_VOLUMEUP,
	VolumeDown = SDL3.SDLK_VOLUMEDOWN,
	KpComma = SDL3.SDLK_KP_COMMA,
	KpEqualsas400 = SDL3.SDLK_KP_EQUALSAS400,
	Alterase = SDL3.SDLK_ALTERASE,
	Sysreq = SDL3.SDLK_SYSREQ,
	Cancel = SDL3.SDLK_CANCEL,
	Clear = SDL3.SDLK_CLEAR,
	Prior = SDL3.SDLK_PRIOR,
	Return2 = SDL3.SDLK_RETURN2,
	Separator = SDL3.SDLK_SEPARATOR,
	Out = SDL3.SDLK_OUT,
	Oper = SDL3.SDLK_OPER,
	Clearagain = SDL3.SDLK_CLEARAGAIN,
	Crsel = SDL3.SDLK_CRSEL,
	Exsel = SDL3.SDLK_EXSEL,
	Kp00 = SDL3.SDLK_KP_00,
	Kp000 = SDL3.SDLK_KP_000,
	Thousandsseparator = SDL3.SDLK_THOUSANDSSEPARATOR,
	Decimalseparator = SDL3.SDLK_DECIMALSEPARATOR,
	Currencyunit = SDL3.SDLK_CURRENCYUNIT,
	Currencysubunit = SDL3.SDLK_CURRENCYSUBUNIT,
	KpLeftParen = SDL3.SDLK_KP_LEFTPAREN,
	KpRightParen = SDL3.SDLK_KP_RIGHTPAREN,
	KpLeftbrace = SDL3.SDLK_KP_LEFTBRACE,
	KpRightbrace = SDL3.SDLK_KP_RIGHTBRACE,
	KpTab = SDL3.SDLK_KP_TAB,
	KpBackspace = SDL3.SDLK_KP_BACKSPACE,
	KpA = SDL3.SDLK_KP_A,
	KpB = SDL3.SDLK_KP_B,
	KpC = SDL3.SDLK_KP_C,
	KpD = SDL3.SDLK_KP_D,
	KpE = SDL3.SDLK_KP_E,
	KpF = SDL3.SDLK_KP_F,
	KpXor = SDL3.SDLK_KP_XOR,
	KpPower = SDL3.SDLK_KP_POWER,
	KpPercent = SDL3.SDLK_KP_PERCENT,
	KpLess = SDL3.SDLK_KP_LESS,
	KpGreater = SDL3.SDLK_KP_GREATER,
	KpAmpersand = SDL3.SDLK_KP_AMPERSAND,
	KpDblampersand = SDL3.SDLK_KP_DBLAMPERSAND,
	KpVerticalbar = SDL3.SDLK_KP_VERTICALBAR,
	KpDblverticalbar = SDL3.SDLK_KP_DBLVERTICALBAR,
	KpColon = SDL3.SDLK_KP_COLON,
	KpHash = SDL3.SDLK_KP_HASH,
	KpSpace = SDL3.SDLK_KP_SPACE,
	KpAt = SDL3.SDLK_KP_AT,
	KpExclam = SDL3.SDLK_KP_EXCLAM,
	KpMemstore = SDL3.SDLK_KP_MEMSTORE,
	KpMemrecall = SDL3.SDLK_KP_MEMRECALL,
	KpMemclear = SDL3.SDLK_KP_MEMCLEAR,
	KpMemadd = SDL3.SDLK_KP_MEMADD,
	KpMemsubtract = SDL3.SDLK_KP_MEMSUBTRACT,
	KpMemmultiply = SDL3.SDLK_KP_MEMMULTIPLY,
	KpMemdivide = SDL3.SDLK_KP_MEMDIVIDE,
	KpPlusMinus = SDL3.SDLK_KP_PLUSMINUS,
	KpClear = SDL3.SDLK_KP_CLEAR,
	KpClearentry = SDL3.SDLK_KP_CLEARENTRY,
	KpBinary = SDL3.SDLK_KP_BINARY,
	KpOctal = SDL3.SDLK_KP_OCTAL,
	KpDecimal = SDL3.SDLK_KP_DECIMAL,
	KpHexadecimal = SDL3.SDLK_KP_HEXADECIMAL,
	LeftControl = SDL3.SDLK_LCTRL,
	LeftShift = SDL3.SDLK_LSHIFT,
	LeftAlt = SDL3.SDLK_LALT,
	LeftGui = SDL3.SDLK_LGUI,
	RightControl = SDL3.SDLK_RCTRL,
	RightShift = SDL3.SDLK_RSHIFT,
	RightAlt = SDL3.SDLK_RALT,
	RightGui = SDL3.SDLK_RGUI,
	Mode = SDL3.SDLK_MODE,
	Sleep = SDL3.SDLK_SLEEP,
	Wake = SDL3.SDLK_WAKE,
	ChannelIncrement = SDL3.SDLK_CHANNEL_INCREMENT,
	ChannelDecrement = SDL3.SDLK_CHANNEL_DECREMENT,
	MediaPlay = SDL3.SDLK_MEDIA_PLAY,
	MediaPause = SDL3.SDLK_MEDIA_PAUSE,
	MediaRecord = SDL3.SDLK_MEDIA_RECORD,
	MediaFastForward = SDL3.SDLK_MEDIA_FAST_FORWARD,
	MediaRewind = SDL3.SDLK_MEDIA_REWIND,
	MediaNextTrack = SDL3.SDLK_MEDIA_NEXT_TRACK,
	MediaPreviousTrack = SDL3.SDLK_MEDIA_PREVIOUS_TRACK,
	MediaStop = SDL3.SDLK_MEDIA_STOP,
	MediaEject = SDL3.SDLK_MEDIA_EJECT,
	MediaPlayPause = SDL3.SDLK_MEDIA_PLAY_PAUSE,
	MediaSelect = SDL3.SDLK_MEDIA_SELECT,
	AcNew = SDL3.SDLK_AC_NEW,
	AcOpen = SDL3.SDLK_AC_OPEN,
	AcClose = SDL3.SDLK_AC_CLOSE,
	AcExit = SDL3.SDLK_AC_EXIT,
	AcSave = SDL3.SDLK_AC_SAVE,
	AcPrint = SDL3.SDLK_AC_PRINT,
	AcProperties = SDL3.SDLK_AC_PROPERTIES,
	AcSearch = SDL3.SDLK_AC_SEARCH,
	AcHome = SDL3.SDLK_AC_HOME,
	AcBack = SDL3.SDLK_AC_BACK,
	AcForward = SDL3.SDLK_AC_FORWARD,
	AcStop = SDL3.SDLK_AC_STOP,
	AcRefresh = SDL3.SDLK_AC_REFRESH,
	AcBookmarks = SDL3.SDLK_AC_BOOKMARKS,
	Softleft = SDL3.SDLK_SOFTLEFT,
	Softright = SDL3.SDLK_SOFTRIGHT,
	Call = SDL3.SDLK_CALL,
	Endcall = SDL3.SDLK_ENDCALL,
	LeftTab = SDL3.SDLK_LEFT_TAB,
	Level5Shift = SDL3.SDLK_LEVEL5_SHIFT,
	MultiKeyCompose = SDL3.SDLK_MULTI_KEY_COMPOSE,
	Lmeta = SDL3.SDLK_LMETA,
	Rmeta = SDL3.SDLK_RMETA,
	Lhyper = SDL3.SDLK_LHYPER,
	Rhyper = SDL3.SDLK_RHYPER,
}

/// <summary>
/// Valid key modifiers (possibly OR'd together).<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
[Flags]
public enum SDL_Keymod : ushort
{
	None = SDL3.SDL_KMOD_NONE,
	LeftShift = SDL3.SDL_KMOD_LSHIFT,
	RightShift = SDL3.SDL_KMOD_RSHIFT,
	Level5 = SDL3.SDL_KMOD_LEVEL5,
	LeftControl = SDL3.SDL_KMOD_LCTRL,
	RightControl = SDL3.SDL_KMOD_RCTRL,
	LeftAlt = SDL3.SDL_KMOD_LALT,
	RightAlt = SDL3.SDL_KMOD_RALT,
	LeftGui = SDL3.SDL_KMOD_LGUI,
	RightGui = SDL3.SDL_KMOD_RGUI,
	Num = SDL3.SDL_KMOD_NUM,
	Caps = SDL3.SDL_KMOD_CAPS,
	Mode = SDL3.SDL_KMOD_MODE,
	Scroll = SDL3.SDL_KMOD_SCROLL,
	Ctrl = SDL3.SDL_KMOD_CTRL,
	Shift = SDL3.SDL_KMOD_SHIFT,
	Alt = SDL3.SDL_KMOD_ALT,
	Gui = SDL3.SDL_KMOD_GUI,
}

/// <summary>
/// Message box flags.<br/>
/// If supported will display warning icon, etc.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
[Flags]
public enum SDL_MessageBoxFlags : uint
{
	Error = SDL3.SDL_MESSAGEBOX_ERROR,
	Warning = SDL3.SDL_MESSAGEBOX_WARNING,
	Information = SDL3.SDL_MESSAGEBOX_INFORMATION,
	ButtonsLeftToRight = SDL3.SDL_MESSAGEBOX_BUTTONS_LEFT_TO_RIGHT,
	ButtonsRightToLeft = SDL3.SDL_MESSAGEBOX_BUTTONS_RIGHT_TO_LEFT,
}

/// <summary>
/// SDL_MessageBoxButtonData flags.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
[Flags]
public enum SDL_MessageBoxButtonFlags : uint
{
	ReturnKeyDefault = SDL3.SDL_MESSAGEBOX_BUTTON_RETURNKEY_DEFAULT,
	EscapeKeyDefault = SDL3.SDL_MESSAGEBOX_BUTTON_ESCAPEKEY_DEFAULT,
}

/// <summary>
/// This is a unique ID for a mouse for the time it is connected to the system,<br/>
/// and is never reused for the lifetime of the application.<br/>
/// If the mouse is disconnected and reconnected, it will get a new ID.<br/>
/// The value 0 is an invalid ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_MouseID : uint
{
}

/// <summary>
/// SDL pen instance IDs.<br/>
/// Zero is used to signify an invalid/null device.<br/>
/// These show up in pen events when SDL sees input from them. They remain<br/>
/// consistent as long as SDL can recognize a tool to be the same pen; but if a<br/>
/// pen physically leaves the area and returns, it might get a new ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_PenID : uint
{
}

/// <summary>
/// Pen input flags, as reported by various pen events' `pen_state` field.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
[Flags]
public enum SDL_PenInputFlags : uint
{
}

/// <summary>
/// SDL properties ID<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_PropertiesID : uint
{
}

/// <summary>
/// This is a unique ID for a sensor for the time it is connected to the<br/>
/// system, and is never reused for the lifetime of the application.<br/>
/// The value 0 is an invalid ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_SensorID : uint
{
}

/// <summary>
/// The flags on an SDL_Surface.<br/>
/// These are generally considered read-only.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
[Flags]
public enum SDL_SurfaceFlags : uint
{
	Preallocated = SDL3.SDL_SURFACE_PREALLOCATED,
	LockNeeded = SDL3.SDL_SURFACE_LOCK_NEEDED,
	Locked = SDL3.SDL_SURFACE_LOCKED,
	SimdAligned = SDL3.SDL_SURFACE_SIMD_ALIGNED,
}

/// <summary>
/// A unique numeric ID that identifies a thread.<br/>
/// These are different from SDL_Thread objects, which are generally what an<br/>
/// application will operate on, but having a way to uniquely identify a thread<br/>
/// can be useful at times.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_GetThreadID<br/>
/// @sa SDL_GetCurrentThreadID
/// </summary>
public enum SDL_ThreadID : ulong
{
}

/// <summary>
/// Definition of the timer ID type.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_TimerID : uint
{
}

/// <summary>
/// A unique ID for a touch device.<br/>
/// This ID is valid for the time the device is connected to the system, and is<br/>
/// never reused for the lifetime of the application.<br/>
/// The value 0 is an invalid ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_TouchID : ulong
{
}

/// <summary>
/// A unique ID for a single finger on a touch device.<br/>
/// This ID is valid for the time the finger (stylus, etc) is touching and will<br/>
/// be unique for all fingers currently in contact, so this ID tracks the<br/>
/// lifetime of a single continuous touch. This value may represent an index, a<br/>
/// pointer, or some other unique ID, depending on the platform.<br/>
/// The value 0 is an invalid ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_FingerID : ulong
{
}

/// <summary>
/// This is a unique ID for a display for the time it is connected to the<br/>
/// system, and is never reused for the lifetime of the application.<br/>
/// If the display is disconnected and reconnected, it will get a new ID.<br/>
/// The value 0 is an invalid ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_DisplayID : uint
{
}

/// <summary>
/// This is a unique ID for a window.<br/>
/// The value 0 is an invalid ID.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
public enum SDL_WindowID : uint
{
}

/// <summary>
/// Possible values to be set for the SDL_GL_CONTEXT_PROFILE_MASK attribute.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
[Flags]
public enum SDL_GLProfile : uint
{
	Core = SDL3.SDL_GL_CONTEXT_PROFILE_CORE,
	Compatibility = SDL3.SDL_GL_CONTEXT_PROFILE_COMPATIBILITY,
	Es = SDL3.SDL_GL_CONTEXT_PROFILE_ES,
}

/// <summary>
/// Possible values to be set for the SDL_GL_CONTEXT_RELEASE_BEHAVIOR<br/>
/// attribute.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
[Flags]
public enum SDL_GLContextReleaseFlag : uint
{
	None = SDL3.SDL_GL_CONTEXT_RELEASE_BEHAVIOR_NONE,
	Flush = SDL3.SDL_GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH,
}

/// <summary>
/// Possible values to be set SDL_GL_CONTEXT_RESET_NOTIFICATION attribute.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.
/// </summary>
[Flags]
public enum SDL_GLContextResetNotification : uint
{
	NoNotification = SDL3.SDL_GL_CONTEXT_RESET_NO_NOTIFICATION,
	LoseContext = SDL3.SDL_GL_CONTEXT_RESET_LOSE_CONTEXT,
}

/// <summary>
/// Specifies how a texture is intended to be used by the client.<br/>
/// A texture must have at least one usage flag. Note that some usage flag<br/>
/// combinations are invalid.<br/>
/// With regards to compute storage usage, READ | WRITE means that you can have<br/>
/// shader A that only writes into the texture and shader B that only reads<br/>
/// from the texture and bind the same texture to either shader respectively.<br/>
/// SIMULTANEOUS means that you can do reads and writes within the same shader<br/>
/// or compute pass. It also implies that atomic ops can be used, since those<br/>
/// are read-modify-write operations. If you use SIMULTANEOUS, you are<br/>
/// responsible for avoiding data races, as there is no data synchronization<br/>
/// within a compute pass. Note that SIMULTANEOUS usage is only supported by a<br/>
/// limited number of texture formats.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUTexture
/// </summary>
[Flags]
public enum SDL_GPUTextureUsageFlags : uint
{
	Sampler = SDL3.SDL_GPU_TEXTUREUSAGE_SAMPLER,
	ColorTarget = SDL3.SDL_GPU_TEXTUREUSAGE_COLOR_TARGET,
	DepthStencilTarget = SDL3.SDL_GPU_TEXTUREUSAGE_DEPTH_STENCIL_TARGET,
	GraphicsStorageRead = SDL3.SDL_GPU_TEXTUREUSAGE_GRAPHICS_STORAGE_READ,
	ComputeStorageRead = SDL3.SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_READ,
	ComputeStorageWrite = SDL3.SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_WRITE,
	ComputeStorageSimultaneousReadWrite = SDL3.SDL_GPU_TEXTUREUSAGE_COMPUTE_STORAGE_SIMULTANEOUS_READ_WRITE,
}

/// <summary>
/// Specifies how a buffer is intended to be used by the client.<br/>
/// A buffer must have at least one usage flag. Note that some usage flag<br/>
/// combinations are invalid.<br/>
/// Unlike textures, READ | WRITE can be used for simultaneous read-write<br/>
/// usage. The same data synchronization concerns as textures apply.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUBuffer
/// </summary>
[Flags]
public enum SDL_GPUBufferUsageFlags : uint
{
	Vertex = SDL3.SDL_GPU_BUFFERUSAGE_VERTEX,
	Index = SDL3.SDL_GPU_BUFFERUSAGE_INDEX,
	Indirect = SDL3.SDL_GPU_BUFFERUSAGE_INDIRECT,
	GraphicsStorageRead = SDL3.SDL_GPU_BUFFERUSAGE_GRAPHICS_STORAGE_READ,
	ComputeStorageRead = SDL3.SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_READ,
	ComputeStorageWrite = SDL3.SDL_GPU_BUFFERUSAGE_COMPUTE_STORAGE_WRITE,
}

/// <summary>
/// Specifies the format of shader code.<br/>
/// Each format corresponds to a specific backend that accepts it.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUShader
/// </summary>
[Flags]
public enum SDL_GPUShaderFormat : uint
{
	Invalid = SDL3.SDL_GPU_SHADERFORMAT_INVALID,
	Private = SDL3.SDL_GPU_SHADERFORMAT_PRIVATE,
	Spirv = SDL3.SDL_GPU_SHADERFORMAT_SPIRV,
	Dxbc = SDL3.SDL_GPU_SHADERFORMAT_DXBC,
	Dxil = SDL3.SDL_GPU_SHADERFORMAT_DXIL,
	Msl = SDL3.SDL_GPU_SHADERFORMAT_MSL,
	MetalLib = SDL3.SDL_GPU_SHADERFORMAT_METALLIB,
}

/// <summary>
/// Specifies which color components are written in a graphics pipeline.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUGraphicsPipeline
/// </summary>
[Flags]
public enum SDL_GPUColorComponentFlags : byte
{
	R = SDL3.SDL_GPU_COLORCOMPONENT_R,
	G = SDL3.SDL_GPU_COLORCOMPONENT_G,
	B = SDL3.SDL_GPU_COLORCOMPONENT_B,
	A = SDL3.SDL_GPU_COLORCOMPONENT_A,
	All = R | G | B | A
}

/// <summary>
/// The asynchronous I/O operation structure.<br/>
/// This operates as an opaque handle. One can then request read or write<br/>
/// operations on it.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_AsyncIOFromFile
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_AsyncIO(nint value) : IEquatable<SDL_AsyncIO>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_AsyncIO Null => new(0);
	public static implicit operator nint(SDL_AsyncIO value) => value.Value;
	public static implicit operator SDL_AsyncIO(nint value) => new(value);
	public static bool operator ==(SDL_AsyncIO left, SDL_AsyncIO right) => left.Value == right.Value;
	public static bool operator !=(SDL_AsyncIO left, SDL_AsyncIO right) => left.Value != right.Value;
	public static bool operator ==(SDL_AsyncIO left, nint right) => left.Value == right;
	public static bool operator !=(SDL_AsyncIO left, nint right) => left.Value != right;
	public bool Equals(SDL_AsyncIO other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_AsyncIO other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_AsyncIO)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// A queue of completed asynchronous I/O tasks.<br/>
/// When starting an asynchronous operation, you specify a queue for the new<br/>
/// task. A queue can be asked later if any tasks in it have completed,<br/>
/// allowing an app to manage multiple pending tasks in one place, in whatever<br/>
/// order they complete.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateAsyncIOQueue<br/>
/// @sa SDL_ReadAsyncIO<br/>
/// @sa SDL_WriteAsyncIO<br/>
/// @sa SDL_GetAsyncIOResult<br/>
/// @sa SDL_WaitAsyncIOResult
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_AsyncIOQueue(nint value) : IEquatable<SDL_AsyncIOQueue>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_AsyncIOQueue Null => new(0);
	public static implicit operator nint(SDL_AsyncIOQueue value) => value.Value;
	public static implicit operator SDL_AsyncIOQueue(nint value) => new(value);
	public static bool operator ==(SDL_AsyncIOQueue left, SDL_AsyncIOQueue right) => left.Value == right.Value;
	public static bool operator !=(SDL_AsyncIOQueue left, SDL_AsyncIOQueue right) => left.Value != right.Value;
	public static bool operator ==(SDL_AsyncIOQueue left, nint right) => left.Value == right;
	public static bool operator !=(SDL_AsyncIOQueue left, nint right) => left.Value != right;
	public bool Equals(SDL_AsyncIOQueue other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_AsyncIOQueue other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_AsyncIOQueue)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// The opaque handle that represents an audio stream.<br/>
/// SDL_AudioStream is an audio conversion interface.<br/>
/// - It can handle resampling data in chunks without generating artifacts,<br/>
/// when it doesn't have the complete buffer available.<br/>
/// - It can handle incoming data in any variable size.<br/>
/// - It can handle input/output format changes on the fly.<br/>
/// - It can remap audio channels between inputs and outputs.<br/>
/// - You push data as you have it, and pull it when you need it<br/>
/// - It can also function as a basic audio data queue even if you just have<br/>
/// sound that needs to pass from one place to another.<br/>
/// - You can hook callbacks up to them when more data is added or requested,<br/>
/// to manage data on-the-fly.<br/>
/// Audio streams are the core of the SDL3 audio interface. You create one or<br/>
/// more of them, bind them to an opened audio device, and feed data to them<br/>
/// (or for recording, consume data from them).<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateAudioStream
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_AudioStream(nint value) : IEquatable<SDL_AudioStream>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_AudioStream Null => new(0);
	public static implicit operator nint(SDL_AudioStream value) => value.Value;
	public static implicit operator SDL_AudioStream(nint value) => new(value);
	public static bool operator ==(SDL_AudioStream left, SDL_AudioStream right) => left.Value == right.Value;
	public static bool operator !=(SDL_AudioStream left, SDL_AudioStream right) => left.Value != right.Value;
	public static bool operator ==(SDL_AudioStream left, nint right) => left.Value == right;
	public static bool operator !=(SDL_AudioStream left, nint right) => left.Value != right;
	public bool Equals(SDL_AudioStream other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_AudioStream other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_AudioStream)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// The opaque structure used to identify an opened SDL camera.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Camera(nint value) : IEquatable<SDL_Camera>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Camera Null => new(0);
	public static implicit operator nint(SDL_Camera value) => value.Value;
	public static implicit operator SDL_Camera(nint value) => new(value);
	public static bool operator ==(SDL_Camera left, SDL_Camera right) => left.Value == right.Value;
	public static bool operator !=(SDL_Camera left, SDL_Camera right) => left.Value != right.Value;
	public static bool operator ==(SDL_Camera left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Camera left, nint right) => left.Value != right;
	public bool Equals(SDL_Camera other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Camera other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Camera)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// The structure used to identify an SDL gamepad<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Gamepad(nint value) : IEquatable<SDL_Gamepad>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Gamepad Null => new(0);
	public static implicit operator nint(SDL_Gamepad value) => value.Value;
	public static implicit operator SDL_Gamepad(nint value) => new(value);
	public static bool operator ==(SDL_Gamepad left, SDL_Gamepad right) => left.Value == right.Value;
	public static bool operator !=(SDL_Gamepad left, SDL_Gamepad right) => left.Value != right.Value;
	public static bool operator ==(SDL_Gamepad left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Gamepad left, nint right) => left.Value != right;
	public bool Equals(SDL_Gamepad other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Gamepad other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Gamepad)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// The haptic structure used to identify an SDL haptic.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_OpenHaptic<br/>
/// @sa SDL_OpenHapticFromJoystick<br/>
/// @sa SDL_CloseHaptic
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Haptic(nint value) : IEquatable<SDL_Haptic>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Haptic Null => new(0);
	public static implicit operator nint(SDL_Haptic value) => value.Value;
	public static implicit operator SDL_Haptic(nint value) => new(value);
	public static bool operator ==(SDL_Haptic left, SDL_Haptic right) => left.Value == right.Value;
	public static bool operator !=(SDL_Haptic left, SDL_Haptic right) => left.Value != right.Value;
	public static bool operator ==(SDL_Haptic left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Haptic left, nint right) => left.Value != right;
	public bool Equals(SDL_Haptic other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Haptic other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Haptic)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing an open HID device.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_hid_device(nint value) : IEquatable<SDL_hid_device>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_hid_device Null => new(0);
	public static implicit operator nint(SDL_hid_device value) => value.Value;
	public static implicit operator SDL_hid_device(nint value) => new(value);
	public static bool operator ==(SDL_hid_device left, SDL_hid_device right) => left.Value == right.Value;
	public static bool operator !=(SDL_hid_device left, SDL_hid_device right) => left.Value != right.Value;
	public static bool operator ==(SDL_hid_device left, nint right) => left.Value == right;
	public static bool operator !=(SDL_hid_device left, nint right) => left.Value != right;
	public bool Equals(SDL_hid_device other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_hid_device other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_hid_device)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// The read/write operation structure.<br/>
/// This operates as an opaque handle. There are several APIs to create various<br/>
/// types of I/O streams, or an app can supply an SDL_IOStreamInterface to<br/>
/// SDL_OpenIO() to provide their own stream implementation behind this<br/>
/// struct's abstract interface.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_IOStream(nint value) : IEquatable<SDL_IOStream>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_IOStream Null => new(0);
	public static implicit operator nint(SDL_IOStream value) => value.Value;
	public static implicit operator SDL_IOStream(nint value) => new(value);
	public static bool operator ==(SDL_IOStream left, SDL_IOStream right) => left.Value == right.Value;
	public static bool operator !=(SDL_IOStream left, SDL_IOStream right) => left.Value != right.Value;
	public static bool operator ==(SDL_IOStream left, nint right) => left.Value == right;
	public static bool operator !=(SDL_IOStream left, nint right) => left.Value != right;
	public bool Equals(SDL_IOStream other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_IOStream other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_IOStream)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// The joystick structure used to identify an SDL joystick.<br/>
/// This is opaque data.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Joystick(nint value) : IEquatable<SDL_Joystick>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Joystick Null => new(0);
	public static implicit operator nint(SDL_Joystick value) => value.Value;
	public static implicit operator SDL_Joystick(nint value) => new(value);
	public static bool operator ==(SDL_Joystick left, SDL_Joystick right) => left.Value == right.Value;
	public static bool operator !=(SDL_Joystick left, SDL_Joystick right) => left.Value != right.Value;
	public static bool operator ==(SDL_Joystick left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Joystick left, nint right) => left.Value != right;
	public bool Equals(SDL_Joystick other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Joystick other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Joystick)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque datatype that represents a loaded shared object.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_LoadObject<br/>
/// @sa SDL_LoadFunction<br/>
/// @sa SDL_UnloadObject
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_SharedObject(nint value) : IEquatable<SDL_SharedObject>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_SharedObject Null => new(0);
	public static implicit operator nint(SDL_SharedObject value) => value.Value;
	public static implicit operator SDL_SharedObject(nint value) => new(value);
	public static bool operator ==(SDL_SharedObject left, SDL_SharedObject right) => left.Value == right.Value;
	public static bool operator !=(SDL_SharedObject left, SDL_SharedObject right) => left.Value != right.Value;
	public static bool operator ==(SDL_SharedObject left, nint right) => left.Value == right;
	public static bool operator !=(SDL_SharedObject left, nint right) => left.Value != right;
	public bool Equals(SDL_SharedObject other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_SharedObject other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_SharedObject)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// The structure used to identify an SDL cursor.<br/>
/// This is opaque data.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Cursor(nint value) : IEquatable<SDL_Cursor>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Cursor Null => new(0);
	public static implicit operator nint(SDL_Cursor value) => value.Value;
	public static implicit operator SDL_Cursor(nint value) => new(value);
	public static bool operator ==(SDL_Cursor left, SDL_Cursor right) => left.Value == right.Value;
	public static bool operator !=(SDL_Cursor left, SDL_Cursor right) => left.Value != right.Value;
	public static bool operator ==(SDL_Cursor left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Cursor left, nint right) => left.Value != right;
	public bool Equals(SDL_Cursor other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Cursor other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Cursor)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// A means to serialize access to a resource between threads.<br/>
/// Mutexes (short for "mutual exclusion") are a synchronization primitive that<br/>
/// allows exactly one thread to proceed at a time.<br/>
/// Wikipedia has a thorough explanation of the concept:<br/>
/// https://en.wikipedia.org/wiki/Mutex<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Mutex(nint value) : IEquatable<SDL_Mutex>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Mutex Null => new(0);
	public static implicit operator nint(SDL_Mutex value) => value.Value;
	public static implicit operator SDL_Mutex(nint value) => new(value);
	public static bool operator ==(SDL_Mutex left, SDL_Mutex right) => left.Value == right.Value;
	public static bool operator !=(SDL_Mutex left, SDL_Mutex right) => left.Value != right.Value;
	public static bool operator ==(SDL_Mutex left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Mutex left, nint right) => left.Value != right;
	public bool Equals(SDL_Mutex other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Mutex other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Mutex)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// A mutex that allows read-only threads to run in parallel.<br/>
/// A rwlock is roughly the same concept as SDL_Mutex, but allows threads that<br/>
/// request read-only access to all hold the lock at the same time. If a thread<br/>
/// requests write access, it will block until all read-only threads have<br/>
/// released the lock, and no one else can hold the thread (for reading or<br/>
/// writing) at the same time as the writing thread.<br/>
/// This can be more efficient in cases where several threads need to access<br/>
/// data frequently, but changes to that data are rare.<br/>
/// There are other rules that apply to rwlocks that don't apply to mutexes,<br/>
/// about how threads are scheduled and when they can be recursively locked.<br/>
/// These are documented in the other rwlock functions.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_RWLock(nint value) : IEquatable<SDL_RWLock>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_RWLock Null => new(0);
	public static implicit operator nint(SDL_RWLock value) => value.Value;
	public static implicit operator SDL_RWLock(nint value) => new(value);
	public static bool operator ==(SDL_RWLock left, SDL_RWLock right) => left.Value == right.Value;
	public static bool operator !=(SDL_RWLock left, SDL_RWLock right) => left.Value != right.Value;
	public static bool operator ==(SDL_RWLock left, nint right) => left.Value == right;
	public static bool operator !=(SDL_RWLock left, nint right) => left.Value != right;
	public bool Equals(SDL_RWLock other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_RWLock other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_RWLock)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// A means to manage access to a resource, by count, between threads.<br/>
/// Semaphores (specifically, "counting semaphores"), let X number of threads<br/>
/// request access at the same time, each thread granted access decrementing a<br/>
/// counter. When the counter reaches zero, future requests block until a prior<br/>
/// thread releases their request, incrementing the counter again.<br/>
/// Wikipedia has a thorough explanation of the concept:<br/>
/// https://en.wikipedia.org/wiki/Semaphore_(programming)<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Semaphore(nint value) : IEquatable<SDL_Semaphore>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Semaphore Null => new(0);
	public static implicit operator nint(SDL_Semaphore value) => value.Value;
	public static implicit operator SDL_Semaphore(nint value) => new(value);
	public static bool operator ==(SDL_Semaphore left, SDL_Semaphore right) => left.Value == right.Value;
	public static bool operator !=(SDL_Semaphore left, SDL_Semaphore right) => left.Value != right.Value;
	public static bool operator ==(SDL_Semaphore left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Semaphore left, nint right) => left.Value != right;
	public bool Equals(SDL_Semaphore other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Semaphore other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Semaphore)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// A means to block multiple threads until a condition is satisfied.<br/>
/// Condition variables, paired with an SDL_Mutex, let an app halt multiple<br/>
/// threads until a condition has occurred, at which time the app can release<br/>
/// one or all waiting threads.<br/>
/// Wikipedia has a thorough explanation of the concept:<br/>
/// https://en.wikipedia.org/wiki/Condition_variable<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Condition(nint value) : IEquatable<SDL_Condition>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Condition Null => new(0);
	public static implicit operator nint(SDL_Condition value) => value.Value;
	public static implicit operator SDL_Condition(nint value) => new(value);
	public static bool operator ==(SDL_Condition left, SDL_Condition right) => left.Value == right.Value;
	public static bool operator !=(SDL_Condition left, SDL_Condition right) => left.Value != right.Value;
	public static bool operator ==(SDL_Condition left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Condition left, nint right) => left.Value != right;
	public bool Equals(SDL_Condition other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Condition other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Condition)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// A structure representing rendering state<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Renderer(nint value) : IEquatable<SDL_Renderer>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Renderer Null => new(0);
	public static implicit operator nint(SDL_Renderer value) => value.Value;
	public static implicit operator SDL_Renderer(nint value) => new(value);
	public static bool operator ==(SDL_Renderer left, SDL_Renderer right) => left.Value == right.Value;
	public static bool operator !=(SDL_Renderer left, SDL_Renderer right) => left.Value != right.Value;
	public static bool operator ==(SDL_Renderer left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Renderer left, nint right) => left.Value != right;
	public bool Equals(SDL_Renderer other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Renderer other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Renderer)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// The opaque structure used to identify an opened SDL sensor.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Sensor(nint value) : IEquatable<SDL_Sensor>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Sensor Null => new(0);
	public static implicit operator nint(SDL_Sensor value) => value.Value;
	public static implicit operator SDL_Sensor(nint value) => new(value);
	public static bool operator ==(SDL_Sensor left, SDL_Sensor right) => left.Value == right.Value;
	public static bool operator !=(SDL_Sensor left, SDL_Sensor right) => left.Value != right.Value;
	public static bool operator ==(SDL_Sensor left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Sensor left, nint right) => left.Value != right;
	public bool Equals(SDL_Sensor other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Sensor other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Sensor)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// A thread-safe set of environment variables<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_GetEnvironment<br/>
/// @sa SDL_CreateEnvironment<br/>
/// @sa SDL_GetEnvironmentVariable<br/>
/// @sa SDL_GetEnvironmentVariables<br/>
/// @sa SDL_SetEnvironmentVariable<br/>
/// @sa SDL_UnsetEnvironmentVariable<br/>
/// @sa SDL_DestroyEnvironment
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Environment(nint value) : IEquatable<SDL_Environment>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Environment Null => new(0);
	public static implicit operator nint(SDL_Environment value) => value.Value;
	public static implicit operator SDL_Environment(nint value) => new(value);
	public static bool operator ==(SDL_Environment left, SDL_Environment right) => left.Value == right.Value;
	public static bool operator !=(SDL_Environment left, SDL_Environment right) => left.Value != right.Value;
	public static bool operator ==(SDL_Environment left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Environment left, nint right) => left.Value != right;
	public bool Equals(SDL_Environment other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Environment other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Environment)} [0x{Value.ToString("X")}]";
}

[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_iconv_data_t(nint value) : IEquatable<SDL_iconv_data_t>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_iconv_data_t Null => new(0);
	public static implicit operator nint(SDL_iconv_data_t value) => value.Value;
	public static implicit operator SDL_iconv_data_t(nint value) => new(value);
	public static bool operator ==(SDL_iconv_data_t left, SDL_iconv_data_t right) => left.Value == right.Value;
	public static bool operator !=(SDL_iconv_data_t left, SDL_iconv_data_t right) => left.Value != right.Value;
	public static bool operator ==(SDL_iconv_data_t left, nint right) => left.Value == right;
	public static bool operator !=(SDL_iconv_data_t left, nint right) => left.Value != right;
	public bool Equals(SDL_iconv_data_t other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_iconv_data_t other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_iconv_data_t)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An abstract interface for filesystem access.<br/>
/// This is an opaque datatype. One can create this object using standard SDL<br/>
/// functions like SDL_OpenTitleStorage or SDL_OpenUserStorage, etc, or create<br/>
/// an object with a custom implementation using SDL_OpenStorage.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Storage(nint value) : IEquatable<SDL_Storage>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Storage Null => new(0);
	public static implicit operator nint(SDL_Storage value) => value.Value;
	public static implicit operator SDL_Storage(nint value) => new(value);
	public static bool operator ==(SDL_Storage left, SDL_Storage right) => left.Value == right.Value;
	public static bool operator !=(SDL_Storage left, SDL_Storage right) => left.Value != right.Value;
	public static bool operator ==(SDL_Storage left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Storage left, nint right) => left.Value != right;
	public bool Equals(SDL_Storage other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Storage other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Storage)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// The SDL thread object.<br/>
/// These are opaque data.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateThread<br/>
/// @sa SDL_WaitThread
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Thread(nint value) : IEquatable<SDL_Thread>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Thread Null => new(0);
	public static implicit operator nint(SDL_Thread value) => value.Value;
	public static implicit operator SDL_Thread(nint value) => new(value);
	public static bool operator ==(SDL_Thread left, SDL_Thread right) => left.Value == right.Value;
	public static bool operator !=(SDL_Thread left, SDL_Thread right) => left.Value != right.Value;
	public static bool operator ==(SDL_Thread left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Thread left, nint right) => left.Value != right;
	public bool Equals(SDL_Thread other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Thread other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Thread)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// Internal display mode data.<br/>
/// This lives as a field in SDL_DisplayMode, as opaque data.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_DisplayMode
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_DisplayModeData(nint value) : IEquatable<SDL_DisplayModeData>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_DisplayModeData Null => new(0);
	public static implicit operator nint(SDL_DisplayModeData value) => value.Value;
	public static implicit operator SDL_DisplayModeData(nint value) => new(value);
	public static bool operator ==(SDL_DisplayModeData left, SDL_DisplayModeData right) => left.Value == right.Value;
	public static bool operator !=(SDL_DisplayModeData left, SDL_DisplayModeData right) => left.Value != right.Value;
	public static bool operator ==(SDL_DisplayModeData left, nint right) => left.Value == right;
	public static bool operator !=(SDL_DisplayModeData left, nint right) => left.Value != right;
	public bool Equals(SDL_DisplayModeData other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_DisplayModeData other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_DisplayModeData)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// The struct used as an opaque handle to a window.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateWindow
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Window(nint value) : IEquatable<SDL_Window>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Window Null => new(0);
	public static implicit operator nint(SDL_Window value) => value.Value;
	public static implicit operator SDL_Window(nint value) => new(value);
	public static bool operator ==(SDL_Window left, SDL_Window right) => left.Value == right.Value;
	public static bool operator !=(SDL_Window left, SDL_Window right) => left.Value != right.Value;
	public static bool operator ==(SDL_Window left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Window left, nint right) => left.Value != right;
	public bool Equals(SDL_Window other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Window other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Window)} [0x{Value.ToString("X")}]";
}

[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GLContext(nint value) : IEquatable<SDL_GLContext>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GLContext Null => new(0);
	public static implicit operator nint(SDL_GLContext value) => value.Value;
	public static implicit operator SDL_GLContext(nint value) => new(value);
	public static bool operator ==(SDL_GLContext left, SDL_GLContext right) => left.Value == right.Value;
	public static bool operator !=(SDL_GLContext left, SDL_GLContext right) => left.Value != right.Value;
	public static bool operator ==(SDL_GLContext left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GLContext left, nint right) => left.Value != right;
	public bool Equals(SDL_GLContext other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GLContext other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GLContext)} [0x{Value.ToString("X")}]";
}

[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct tagMSG(nint value) : IEquatable<tagMSG>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static tagMSG Null => new(0);
	public static implicit operator nint(tagMSG value) => value.Value;
	public static implicit operator tagMSG(nint value) => new(value);
	public static bool operator ==(tagMSG left, tagMSG right) => left.Value == right.Value;
	public static bool operator !=(tagMSG left, tagMSG right) => left.Value != right.Value;
	public static bool operator ==(tagMSG left, nint right) => left.Value == right;
	public static bool operator !=(tagMSG left, nint right) => left.Value != right;
	public bool Equals(tagMSG other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is tagMSG other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(tagMSG)} [0x{Value.ToString("X")}]";
}

[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct _XEvent(nint value) : IEquatable<_XEvent>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static _XEvent Null => new(0);
	public static implicit operator nint(_XEvent value) => value.Value;
	public static implicit operator _XEvent(nint value) => new(value);
	public static bool operator ==(_XEvent left, _XEvent right) => left.Value == right.Value;
	public static bool operator !=(_XEvent left, _XEvent right) => left.Value != right.Value;
	public static bool operator ==(_XEvent left, nint right) => left.Value == right;
	public static bool operator !=(_XEvent left, nint right) => left.Value != right;
	public bool Equals(_XEvent other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is _XEvent other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(_XEvent)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing the SDL_GPU context.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUDevice(nint value) : IEquatable<SDL_GPUDevice>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUDevice Null => new(0);
	public static implicit operator nint(SDL_GPUDevice value) => value.Value;
	public static implicit operator SDL_GPUDevice(nint value) => new(value);
	public static bool operator ==(SDL_GPUDevice left, SDL_GPUDevice right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUDevice left, SDL_GPUDevice right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUDevice left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUDevice left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUDevice other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUDevice other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUDevice)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a buffer.<br/>
/// Used for vertices, indices, indirect draw commands, and general compute<br/>
/// data.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUBuffer<br/>
/// @sa SDL_UploadToGPUBuffer<br/>
/// @sa SDL_DownloadFromGPUBuffer<br/>
/// @sa SDL_CopyGPUBufferToBuffer<br/>
/// @sa SDL_BindGPUVertexBuffers<br/>
/// @sa SDL_BindGPUIndexBuffer<br/>
/// @sa SDL_BindGPUVertexStorageBuffers<br/>
/// @sa SDL_BindGPUFragmentStorageBuffers<br/>
/// @sa SDL_DrawGPUPrimitivesIndirect<br/>
/// @sa SDL_DrawGPUIndexedPrimitivesIndirect<br/>
/// @sa SDL_BindGPUComputeStorageBuffers<br/>
/// @sa SDL_DispatchGPUComputeIndirect<br/>
/// @sa SDL_ReleaseGPUBuffer
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUBuffer(nint value) : IEquatable<SDL_GPUBuffer>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUBuffer Null => new(0);
	public static implicit operator nint(SDL_GPUBuffer value) => value.Value;
	public static implicit operator SDL_GPUBuffer(nint value) => new(value);
	public static bool operator ==(SDL_GPUBuffer left, SDL_GPUBuffer right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUBuffer left, SDL_GPUBuffer right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUBuffer left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUBuffer left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUBuffer other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUBuffer other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUBuffer)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a transfer buffer.<br/>
/// Used for transferring data to and from the device.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUTransferBuffer<br/>
/// @sa SDL_MapGPUTransferBuffer<br/>
/// @sa SDL_UnmapGPUTransferBuffer<br/>
/// @sa SDL_UploadToGPUBuffer<br/>
/// @sa SDL_UploadToGPUTexture<br/>
/// @sa SDL_DownloadFromGPUBuffer<br/>
/// @sa SDL_DownloadFromGPUTexture<br/>
/// @sa SDL_ReleaseGPUTransferBuffer
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUTransferBuffer(nint value) : IEquatable<SDL_GPUTransferBuffer>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUTransferBuffer Null => new(0);
	public static implicit operator nint(SDL_GPUTransferBuffer value) => value.Value;
	public static implicit operator SDL_GPUTransferBuffer(nint value) => new(value);
	public static bool operator ==(SDL_GPUTransferBuffer left, SDL_GPUTransferBuffer right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUTransferBuffer left, SDL_GPUTransferBuffer right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUTransferBuffer left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUTransferBuffer left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUTransferBuffer other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUTransferBuffer other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUTransferBuffer)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a texture.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUTexture<br/>
/// @sa SDL_UploadToGPUTexture<br/>
/// @sa SDL_DownloadFromGPUTexture<br/>
/// @sa SDL_CopyGPUTextureToTexture<br/>
/// @sa SDL_BindGPUVertexSamplers<br/>
/// @sa SDL_BindGPUVertexStorageTextures<br/>
/// @sa SDL_BindGPUFragmentSamplers<br/>
/// @sa SDL_BindGPUFragmentStorageTextures<br/>
/// @sa SDL_BindGPUComputeStorageTextures<br/>
/// @sa SDL_GenerateMipmapsForGPUTexture<br/>
/// @sa SDL_BlitGPUTexture<br/>
/// @sa SDL_ReleaseGPUTexture
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUTexture(nint value) : IEquatable<SDL_GPUTexture>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUTexture Null => new(0);
	public static implicit operator nint(SDL_GPUTexture value) => value.Value;
	public static implicit operator SDL_GPUTexture(nint value) => new(value);
	public static bool operator ==(SDL_GPUTexture left, SDL_GPUTexture right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUTexture left, SDL_GPUTexture right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUTexture left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUTexture left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUTexture other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUTexture other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUTexture)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a sampler.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUSampler<br/>
/// @sa SDL_BindGPUVertexSamplers<br/>
/// @sa SDL_BindGPUFragmentSamplers<br/>
/// @sa SDL_ReleaseGPUSampler
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUSampler(nint value) : IEquatable<SDL_GPUSampler>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUSampler Null => new(0);
	public static implicit operator nint(SDL_GPUSampler value) => value.Value;
	public static implicit operator SDL_GPUSampler(nint value) => new(value);
	public static bool operator ==(SDL_GPUSampler left, SDL_GPUSampler right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUSampler left, SDL_GPUSampler right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUSampler left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUSampler left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUSampler other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUSampler other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUSampler)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a compiled shader object.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUShader<br/>
/// @sa SDL_CreateGPUGraphicsPipeline<br/>
/// @sa SDL_ReleaseGPUShader
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUShader(nint value) : IEquatable<SDL_GPUShader>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUShader Null => new(0);
	public static implicit operator nint(SDL_GPUShader value) => value.Value;
	public static implicit operator SDL_GPUShader(nint value) => new(value);
	public static bool operator ==(SDL_GPUShader left, SDL_GPUShader right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUShader left, SDL_GPUShader right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUShader left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUShader left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUShader other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUShader other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUShader)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a compute pipeline.<br/>
/// Used during compute passes.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUComputePipeline<br/>
/// @sa SDL_BindGPUComputePipeline<br/>
/// @sa SDL_ReleaseGPUComputePipeline
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUComputePipeline(nint value) : IEquatable<SDL_GPUComputePipeline>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUComputePipeline Null => new(0);
	public static implicit operator nint(SDL_GPUComputePipeline value) => value.Value;
	public static implicit operator SDL_GPUComputePipeline(nint value) => new(value);
	public static bool operator ==(SDL_GPUComputePipeline left, SDL_GPUComputePipeline right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUComputePipeline left, SDL_GPUComputePipeline right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUComputePipeline left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUComputePipeline left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUComputePipeline other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUComputePipeline other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUComputePipeline)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a graphics pipeline.<br/>
/// Used during render passes.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateGPUGraphicsPipeline<br/>
/// @sa SDL_BindGPUGraphicsPipeline<br/>
/// @sa SDL_ReleaseGPUGraphicsPipeline
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUGraphicsPipeline(nint value) : IEquatable<SDL_GPUGraphicsPipeline>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUGraphicsPipeline Null => new(0);
	public static implicit operator nint(SDL_GPUGraphicsPipeline value) => value.Value;
	public static implicit operator SDL_GPUGraphicsPipeline(nint value) => new(value);
	public static bool operator ==(SDL_GPUGraphicsPipeline left, SDL_GPUGraphicsPipeline right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUGraphicsPipeline left, SDL_GPUGraphicsPipeline right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUGraphicsPipeline left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUGraphicsPipeline left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUGraphicsPipeline other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUGraphicsPipeline other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUGraphicsPipeline)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a command buffer.<br/>
/// Most state is managed via command buffers. When setting state using a<br/>
/// command buffer, that state is local to the command buffer.<br/>
/// Commands only begin execution on the GPU once SDL_SubmitGPUCommandBuffer is<br/>
/// called. Once the command buffer is submitted, it is no longer valid to use<br/>
/// it.<br/>
/// Command buffers are executed in submission order. If you submit command<br/>
/// buffer A and then command buffer B all commands in A will begin executing<br/>
/// before any command in B begins executing.<br/>
/// In multi-threading scenarios, you should only access a command buffer on<br/>
/// the thread you acquired it from.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_AcquireGPUCommandBuffer<br/>
/// @sa SDL_SubmitGPUCommandBuffer<br/>
/// @sa SDL_SubmitGPUCommandBufferAndAcquireFence
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUCommandBuffer(nint value) : IEquatable<SDL_GPUCommandBuffer>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUCommandBuffer Null => new(0);
	public static implicit operator nint(SDL_GPUCommandBuffer value) => value.Value;
	public static implicit operator SDL_GPUCommandBuffer(nint value) => new(value);
	public static bool operator ==(SDL_GPUCommandBuffer left, SDL_GPUCommandBuffer right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUCommandBuffer left, SDL_GPUCommandBuffer right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUCommandBuffer left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUCommandBuffer left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUCommandBuffer other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUCommandBuffer other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUCommandBuffer)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a render pass.<br/>
/// This handle is transient and should not be held or referenced after<br/>
/// SDL_EndGPURenderPass is called.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_BeginGPURenderPass<br/>
/// @sa SDL_EndGPURenderPass
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPURenderPass(nint value) : IEquatable<SDL_GPURenderPass>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPURenderPass Null => new(0);
	public static implicit operator nint(SDL_GPURenderPass value) => value.Value;
	public static implicit operator SDL_GPURenderPass(nint value) => new(value);
	public static bool operator ==(SDL_GPURenderPass left, SDL_GPURenderPass right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPURenderPass left, SDL_GPURenderPass right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPURenderPass left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPURenderPass left, nint right) => left.Value != right;
	public bool Equals(SDL_GPURenderPass other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPURenderPass other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPURenderPass)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a compute pass.<br/>
/// This handle is transient and should not be held or referenced after<br/>
/// SDL_EndGPUComputePass is called.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_BeginGPUComputePass<br/>
/// @sa SDL_EndGPUComputePass
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUComputePass(nint value) : IEquatable<SDL_GPUComputePass>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUComputePass Null => new(0);
	public static implicit operator nint(SDL_GPUComputePass value) => value.Value;
	public static implicit operator SDL_GPUComputePass(nint value) => new(value);
	public static bool operator ==(SDL_GPUComputePass left, SDL_GPUComputePass right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUComputePass left, SDL_GPUComputePass right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUComputePass left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUComputePass left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUComputePass other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUComputePass other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUComputePass)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a copy pass.<br/>
/// This handle is transient and should not be held or referenced after<br/>
/// SDL_EndGPUCopyPass is called.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_BeginGPUCopyPass<br/>
/// @sa SDL_EndGPUCopyPass
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUCopyPass(nint value) : IEquatable<SDL_GPUCopyPass>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUCopyPass Null => new(0);
	public static implicit operator nint(SDL_GPUCopyPass value) => value.Value;
	public static implicit operator SDL_GPUCopyPass(nint value) => new(value);
	public static bool operator ==(SDL_GPUCopyPass left, SDL_GPUCopyPass right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUCopyPass left, SDL_GPUCopyPass right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUCopyPass left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUCopyPass left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUCopyPass other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUCopyPass other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUCopyPass)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a fence.<br/>
/// <br/>
/// @since This struct is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_SubmitGPUCommandBufferAndAcquireFence<br/>
/// @sa SDL_QueryGPUFence<br/>
/// @sa SDL_WaitForGPUFences<br/>
/// @sa SDL_ReleaseGPUFence
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_GPUFence(nint value) : IEquatable<SDL_GPUFence>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_GPUFence Null => new(0);
	public static implicit operator nint(SDL_GPUFence value) => value.Value;
	public static implicit operator SDL_GPUFence(nint value) => new(value);
	public static bool operator ==(SDL_GPUFence left, SDL_GPUFence right) => left.Value == right.Value;
	public static bool operator !=(SDL_GPUFence left, SDL_GPUFence right) => left.Value != right.Value;
	public static bool operator ==(SDL_GPUFence left, nint right) => left.Value == right;
	public static bool operator !=(SDL_GPUFence left, nint right) => left.Value != right;
	public bool Equals(SDL_GPUFence other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_GPUFence other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_GPUFence)} [0x{Value.ToString("X")}]";
}

/// <summary>
/// An opaque handle representing a system process.<br/>
/// <br/>
/// @since This datatype is available since SDL 3.2.0.<br/>
/// <br/>
/// @sa SDL_CreateProcess
/// </summary>
[DebuggerDisplay("{DebuggerDisplay,nq}")]
public readonly partial struct SDL_Process(nint value) : IEquatable<SDL_Process>
{
	public readonly nint Value = value;
	public bool IsNull => Value == 0;
	public bool IsNotNull => Value != 0;
	public static SDL_Process Null => new(0);
	public static implicit operator nint(SDL_Process value) => value.Value;
	public static implicit operator SDL_Process(nint value) => new(value);
	public static bool operator ==(SDL_Process left, SDL_Process right) => left.Value == right.Value;
	public static bool operator !=(SDL_Process left, SDL_Process right) => left.Value != right.Value;
	public static bool operator ==(SDL_Process left, nint right) => left.Value == right;
	public static bool operator !=(SDL_Process left, nint right) => left.Value != right;
	public bool Equals(SDL_Process other) => Value.Equals(other.Value);
	/// <inheritdoc/>
	public override bool Equals([NotNullWhen(true)] object? obj) => (obj is SDL_Process other) && Equals(other);
	/// <inheritdoc/>
	public override int GetHashCode() => Value.GetHashCode();
	private string DebuggerDisplay => $"{nameof(SDL_Process)} [0x{Value.ToString("X")}]";
}

